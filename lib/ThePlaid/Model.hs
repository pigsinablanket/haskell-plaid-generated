{-
   The Plaid API

   The Plaid REST API. Please see https://plaid.com/docs/api for more details.

   OpenAPI Version: 3.0.0
   The Plaid API API version: 2020-09-14_1.8.0
   Generated by OpenAPI Generator (https://openapi-generator.tech)
-}

{-|
Module : ThePlaid.Model
-}

{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveFoldable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TypeFamilies #-}
{-# OPTIONS_GHC -fno-warn-unused-matches -fno-warn-unused-binds -fno-warn-unused-imports #-}

module ThePlaid.Model where

import ThePlaid.Core
import ThePlaid.MimeTypes

import Data.Aeson ((.:),(.:!),(.:?),(.=))

import qualified Control.Arrow as P (left)
import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Base64 as B64
import qualified Data.ByteString.Char8 as BC
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (Typeable, TypeRep, typeOf, typeRep)
import qualified Data.Foldable as P
import qualified Data.HashMap.Lazy as HM
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Set as Set
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Time as TI
import qualified Lens.Micro as L
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH
import GHC.Generics (Generic)

import Control.Applicative ((<|>))
import Control.Applicative (Alternative)
import Data.Function ((&))
import Data.Monoid ((<>))
import Data.Text (Text)
import Prelude (($),(/=),(.),(<$>),(<*>),(>>=),(=<<),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty,maybe,pure,Monad,Applicative,Functor)

import qualified Prelude as P



-- * Parameter newtypes


-- ** Body
newtype Body = Body { unBody :: A.Value } deriving (P.Eq, P.Show, A.ToJSON)

-- * Models

newtype ItemId = ItemId {getItemId :: T.Text}
  deriving (P.Eq, P.Show, P.Ord)

instance A.FromJSON ItemId where
  parseJSON = fmap ItemId . A.parseJSON

instance A.ToJSON ItemId where
  toJSON = A.toJSON . getItemId

newtype AccessToken = AccessToken {getAccessToken :: T.Text}
  deriving (P.Eq, P.Show, P.Ord)

instance A.FromJSON AccessToken where
  parseJSON = fmap AccessToken . A.parseJSON

instance A.ToJSON AccessToken where
  toJSON = A.toJSON . getAccessToken

newtype Cursor = Cursor {getCursor :: T.Text}
  deriving (P.Eq, P.Show, P.Ord)

instance A.FromJSON Cursor where
  parseJSON = fmap Cursor . A.parseJSON

instance A.ToJSON Cursor where
  toJSON = A.toJSON . getCursor

-- ** APR
-- | APR
-- APR
-- 
-- Information about the APR on the account.
data APR = APR
  { aPRAprPercentage :: !(Double) -- ^ /Required/ "apr_percentage" - Annual Percentage Rate applied. 
  , aPRAprType :: !(E'AprType) -- ^ /Required/ "apr_type" - The type of balance to which the APR applies.
  , aPRBalanceSubjectToApr :: !(Maybe Double) -- ^ "balance_subject_to_apr" - Amount of money that is subjected to the APR if a balance was carried beyond payment due date. How it is calculated can vary by card issuer. It is often calculated as an average daily balance.
  , aPRInterestChargeAmount :: !(Maybe Double) -- ^ "interest_charge_amount" - Amount of money charged due to interest from last statement.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON APR
instance A.FromJSON APR where
  parseJSON = A.withObject "APR" $ \o ->
    APR
      <$> (o .:  "apr_percentage")
      <*> (o .:  "apr_type")
      <*> (o .:? "balance_subject_to_apr")
      <*> (o .:? "interest_charge_amount")

-- | ToJSON APR
instance A.ToJSON APR where
  toJSON APR {..} =
   _omitNulls
      [ "apr_percentage" .= aPRAprPercentage
      , "apr_type" .= aPRAprType
      , "balance_subject_to_apr" .= aPRBalanceSubjectToApr
      , "interest_charge_amount" .= aPRInterestChargeAmount
      ]


-- | Construct a value of type 'APR' (by applying it's required fields, if any)
mkAPR
  :: Double -- ^ 'aPRAprPercentage': Annual Percentage Rate applied. 
  -> E'AprType -- ^ 'aPRAprType': The type of balance to which the APR applies.
  -> APR
mkAPR aPRAprPercentage aPRAprType =
  APR
  { aPRAprPercentage
  , aPRAprType
  , aPRBalanceSubjectToApr = Nothing
  , aPRInterestChargeAmount = Nothing
  }

-- ** AccountAssets
-- | AccountAssets
-- AccountAssets
-- 
data AccountAssets = AccountAssets
  { accountAssetsAccountId :: !(Text) -- ^ /Required/ "account_id" - Plaid’s unique identifier for the account. This value will not change unless Plaid can&#39;t reconcile the account with the data returned by the financial institution. This may occur, for example, when the name of the account changes. If this happens a new &#x60;account_id&#x60; will be assigned to the account.  The &#x60;account_id&#x60; can also change if the &#x60;access_token&#x60; is deleted and the same credentials that were used to generate that &#x60;access_token&#x60; are used to generate a new &#x60;access_token&#x60; on a later date. In that case, the new &#x60;account_id&#x60; will be different from the old &#x60;account_id&#x60;.  Like all Plaid identifiers, the &#x60;account_id&#x60; is case sensitive.
  , accountAssetsPersistentAccountId :: !(Maybe Text) -- "persistent_account_id" - A unique and persistent identifier for accounts that can be used to trace multiple instances of the same account across different Items for depository accounts. This is currently only supported for Chase Items. Because Chase accounts have a different account number each time they are linked, this field may be used instead of the account number to uniquely identify a Chase account across multiple Items for payments use cases, helping to reduce duplicate Items or attempted fraud. In Sandbox, this field may be populated for any account; in Production, it will only be populated for Chase accounts.
  , accountAssetsBalances :: !(AccountBalance) -- ^ /Required/ "balances"
  , accountAssetsMask :: !(Maybe Text) -- ^ "mask" - The last 2-4 alphanumeric characters of an account&#39;s official account number. Note that the mask may be non-unique between an Item&#39;s accounts, and it may also not match the mask that the bank displays to the user.
  , accountAssetsName :: !(Text) -- ^ /Required/ "name" - The name of the account, either assigned by the user or by the financial institution itself
  , accountAssetsOfficialName :: !(Maybe Text) -- ^ "official_name" - The official name of the account as given by the financial institution
  , accountAssetsType :: !(AccountType) -- ^ /Required/ "type"
  , accountAssetsSubtype :: !(AccountSubtype) -- ^ /Required/ "subtype"
  , accountAssetsVerificationStatus :: !(Maybe E'VerificationStatus2) -- ^ "verification_status" - The current verification status of an Auth Item initiated through Automated or Manual micro-deposits.  Returned for Auth Items only.  &#x60;pending_automatic_verification&#x60;: The Item is pending automatic verification  &#x60;pending_manual_verification&#x60;: The Item is pending manual micro-deposit verification. Items remain in this state until the user successfully verifies the two amounts.  &#x60;automatically_verified&#x60;: The Item has successfully been automatically verified   &#x60;manually_verified&#x60;: The Item has successfully been manually verified  &#x60;verification_expired&#x60;: Plaid was unable to automatically verify the deposit within 7 calendar days and will no longer attempt to validate the Item. Users may retry by submitting their information again through Link.  &#x60;verification_failed&#x60;: The Item failed manual micro-deposit verification because the user exhausted all 3 verification attempts. Users may retry by submitting their information again through Link.   
  , accountAssetsDaysAvailable :: !(Maybe Double) -- ^ "days_available" - The duration of transaction history available for this Item, typically defined as the time since the date of the earliest transaction in that account. Only returned by Assets endpoints.
  , accountAssetsTransactions :: !(Maybe [AssetReportTransaction]) -- ^ "transactions" - Transaction history associated with the account. Only returned by Assets endpoints. Transaction history returned by endpoints such as &#x60;/transactions/get&#x60; or &#x60;/investments/transactions/get&#x60; will be returned in the top-level &#x60;transactions&#x60; field instead.
  , accountAssetsOwners :: !([Owner]) -- ^ /Required/ "owners" - Data returned by the financial institution about the account owner or owners. Only returned by Identity or Assets endpoints. Multiple owners on a single account will be represented in the same &#x60;owner&#x60; object, not in multiple owner objects within the array.
  , accountAssetsHistoricalBalances :: !(Maybe [HistoricalBalance]) -- ^ "historical_balances" - Calculated data about the historical balances on the account. Only returned by Assets endpoints.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AccountAssets
instance A.FromJSON AccountAssets where
  parseJSON = A.withObject "AccountAssets" $ \o ->
    AccountAssets
      <$> (o .:  "account_id")
      <*> (o .:?  "persistent_account_id")
      <*> (o .:  "balances")
      <*> (o .:? "mask")
      <*> (o .:  "name")
      <*> (o .:? "official_name")
      <*> (o .:  "type")
      <*> (o .:  "subtype")
      <*> (o .:? "verification_status")
      <*> (o .:? "days_available")
      <*> (o .:? "transactions")
      <*> (o .:  "owners")
      <*> (o .:? "historical_balances")

-- | ToJSON AccountAssets
instance A.ToJSON AccountAssets where
  toJSON AccountAssets {..} =
   _omitNulls
      [ "account_id" .= accountAssetsAccountId
      , "persistent_account_id" .= accountAssetsPersistentAccountId
      , "balances" .= accountAssetsBalances
      , "mask" .= accountAssetsMask
      , "name" .= accountAssetsName
      , "official_name" .= accountAssetsOfficialName
      , "type" .= accountAssetsType
      , "subtype" .= accountAssetsSubtype
      , "verification_status" .= accountAssetsVerificationStatus
      , "days_available" .= accountAssetsDaysAvailable
      , "transactions" .= accountAssetsTransactions
      , "owners" .= accountAssetsOwners
      , "historical_balances" .= accountAssetsHistoricalBalances
      ]


-- | Construct a value of type 'AccountAssets' (by applying it's required fields, if any)
mkAccountAssets
  :: Text -- ^ 'accountAssetsAccountId': Plaid’s unique identifier for the account. This value will not change unless Plaid can't reconcile the account with the data returned by the financial institution. This may occur, for example, when the name of the account changes. If this happens a new `account_id` will be assigned to the account.  The `account_id` can also change if the `access_token` is deleted and the same credentials that were used to generate that `access_token` are used to generate a new `access_token` on a later date. In that case, the new `account_id` will be different from the old `account_id`.  Like all Plaid identifiers, the `account_id` is case sensitive.
  -> AccountBalance -- ^ 'accountAssetsBalances' 
  -> Text -- ^ 'accountAssetsName': The name of the account, either assigned by the user or by the financial institution itself
  -> AccountType -- ^ 'accountAssetsType' 
  -> AccountSubtype -- ^ 'accountAssetsSubtype' 
  -> [Owner] -- ^ 'accountAssetsOwners': Data returned by the financial institution about the account owner or owners. Only returned by Identity or Assets endpoints. Multiple owners on a single account will be represented in the same `owner` object, not in multiple owner objects within the array.
  -> AccountAssets
mkAccountAssets accountAssetsAccountId accountAssetsBalances accountAssetsName accountAssetsType accountAssetsSubtype accountAssetsOwners =
  AccountAssets
  { accountAssetsAccountId
  , accountAssetsPersistentAccountId = Nothing
  , accountAssetsBalances
  , accountAssetsMask = Nothing
  , accountAssetsName
  , accountAssetsOfficialName = Nothing
  , accountAssetsType
  , accountAssetsSubtype
  , accountAssetsVerificationStatus = Nothing
  , accountAssetsDaysAvailable = Nothing
  , accountAssetsTransactions = Nothing
  , accountAssetsOwners
  , accountAssetsHistoricalBalances = Nothing
  }

-- ** AccountAssetsAllOf
-- | AccountAssetsAllOf
data AccountAssetsAllOf = AccountAssetsAllOf
  { accountAssetsAllOfDaysAvailable :: !(Maybe Double) -- ^ "days_available" - The duration of transaction history available for this Item, typically defined as the time since the date of the earliest transaction in that account. Only returned by Assets endpoints.
  , accountAssetsAllOfTransactions :: !(Maybe [AssetReportTransaction]) -- ^ "transactions" - Transaction history associated with the account. Only returned by Assets endpoints. Transaction history returned by endpoints such as &#x60;/transactions/get&#x60; or &#x60;/investments/transactions/get&#x60; will be returned in the top-level &#x60;transactions&#x60; field instead.
  , accountAssetsAllOfOwners :: !([Owner]) -- ^ /Required/ "owners" - Data returned by the financial institution about the account owner or owners. Only returned by Identity or Assets endpoints. Multiple owners on a single account will be represented in the same &#x60;owner&#x60; object, not in multiple owner objects within the array.
  , accountAssetsAllOfHistoricalBalances :: !(Maybe [HistoricalBalance]) -- ^ "historical_balances" - Calculated data about the historical balances on the account. Only returned by Assets endpoints.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AccountAssetsAllOf
instance A.FromJSON AccountAssetsAllOf where
  parseJSON = A.withObject "AccountAssetsAllOf" $ \o ->
    AccountAssetsAllOf
      <$> (o .:? "days_available")
      <*> (o .:? "transactions")
      <*> (o .:  "owners")
      <*> (o .:? "historical_balances")

-- | ToJSON AccountAssetsAllOf
instance A.ToJSON AccountAssetsAllOf where
  toJSON AccountAssetsAllOf {..} =
   _omitNulls
      [ "days_available" .= accountAssetsAllOfDaysAvailable
      , "transactions" .= accountAssetsAllOfTransactions
      , "owners" .= accountAssetsAllOfOwners
      , "historical_balances" .= accountAssetsAllOfHistoricalBalances
      ]


-- | Construct a value of type 'AccountAssetsAllOf' (by applying it's required fields, if any)
mkAccountAssetsAllOf
  :: [Owner] -- ^ 'accountAssetsAllOfOwners': Data returned by the financial institution about the account owner or owners. Only returned by Identity or Assets endpoints. Multiple owners on a single account will be represented in the same `owner` object, not in multiple owner objects within the array.
  -> AccountAssetsAllOf
mkAccountAssetsAllOf accountAssetsAllOfOwners =
  AccountAssetsAllOf
  { accountAssetsAllOfDaysAvailable = Nothing
  , accountAssetsAllOfTransactions = Nothing
  , accountAssetsAllOfOwners
  , accountAssetsAllOfHistoricalBalances = Nothing
  }

-- ** AccountBalance
-- | AccountBalance
-- AccountBalance
-- 
-- A set of fields describing the balance for an account. Balance information may be cached unless the balance object was returned by `/accounts/balance/get`.
data AccountBalance = AccountBalance
  { accountBalanceAvailable :: !(Maybe Double) -- ^ "available" - The amount of funds available to be withdrawn from the account, as determined by the financial institution.  For &#x60;credit&#x60;-type accounts, the &#x60;available&#x60; balance typically equals the &#x60;limit&#x60; less the &#x60;current&#x60; balance, less any pending outflows plus any pending inflows.  For &#x60;depository&#x60;-type accounts, the &#x60;available&#x60; balance typically equals the &#x60;current&#x60; balance less any pending outflows plus any pending inflows. For &#x60;depository&#x60;-type accounts, the &#x60;available&#x60; balance does not include the overdraft limit.  For &#x60;investment&#x60;-type accounts, the &#x60;available&#x60; balance is the total cash available to withdraw as presented by the institution.  Note that not all institutions calculate the &#x60;available&#x60;  balance. In the event that &#x60;available&#x60; balance is unavailable, Plaid will return an &#x60;available&#x60; balance value of &#x60;null&#x60;.  Available balance may be cached and is not guaranteed to be up-to-date in realtime unless the value was returned by &#x60;/accounts/balance/get&#x60;.
  , accountBalanceCurrent :: !(Maybe Double) -- ^ /Required/ "current" - The total amount of funds in or owed by the account.  For &#x60;credit&#x60;-type accounts, a positive balance indicates the amount owed; a negative amount indicates the lender owing the account holder.  For &#x60;loan&#x60;-type accounts, the current balance is the principal remaining on the loan, except in the case of student loan accounts at Sallie Mae (&#x60;ins_116944&#x60;). For Sallie Mae student loans, the account&#39;s balance includes both principal and any outstanding interest.  For &#x60;investment&#x60;-type accounts, the current balance is the total value of assets as presented by the institution.  Note that balance information may be cached unless the value was returned by &#x60;/accounts/balance/get&#x60;, and current balance information is typically not updated intra-day. If you require realtime balance information, use the &#x60;available&#x60; balance as provided by &#x60;/accounts/balance/get&#x60;.
  , accountBalanceLimit :: !(Maybe Double) -- ^ "limit" - For &#x60;credit&#x60;-type accounts, this represents the credit limit.  For &#x60;depository&#x60;-type accounts, this represents the pre-arranged overdraft limit, which is common for current (checking) accounts in Europe.  In North America, this field is typically only available for &#x60;credit&#x60;-type accounts.
  , accountBalanceIsoCurrencyCode :: !(Maybe Text) -- ^ "iso_currency_code" - The ISO-4217 currency code of the balance. Always null if &#x60;unofficial_currency_code&#x60; is non-null.
  , accountBalanceUnofficialCurrencyCode :: !(Maybe Text) -- ^ "unofficial_currency_code" - The unofficial currency code associated with the balance. Always null if &#x60;iso_currency_code&#x60; is non-null. Unofficial currency codes are used for currencies that do not have official ISO currency codes, such as cryptocurrencies and the currencies of certain countries.  See the [currency code schema](/docs/api/accounts#currency-code-schema) for a full listing of supported &#x60;unofficial_currency_code&#x60;s.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AccountBalance
instance A.FromJSON AccountBalance where
  parseJSON = A.withObject "AccountBalance" $ \o ->
    AccountBalance
      <$> (o .:? "available")
      <*> (o .:? "current")
      <*> (o .:? "limit")
      <*> (o .:? "iso_currency_code")
      <*> (o .:? "unofficial_currency_code")

-- | ToJSON AccountBalance
instance A.ToJSON AccountBalance where
  toJSON AccountBalance {..} =
   _omitNulls
      [ "available" .= accountBalanceAvailable
      , "current" .= accountBalanceCurrent
      , "limit" .= accountBalanceLimit
      , "iso_currency_code" .= accountBalanceIsoCurrencyCode
      , "unofficial_currency_code" .= accountBalanceUnofficialCurrencyCode
      ]


-- | Construct a value of type 'AccountBalance' (by applying it's required fields, if any)
mkAccountBalance
  :: Double -- ^ 'accountBalanceCurrent': The total amount of funds in or owed by the account.  For `credit`-type accounts, a positive balance indicates the amount owed; a negative amount indicates the lender owing the account holder.  For `loan`-type accounts, the current balance is the principal remaining on the loan, except in the case of student loan accounts at Sallie Mae (`ins_116944`). For Sallie Mae student loans, the account's balance includes both principal and any outstanding interest.  For `investment`-type accounts, the current balance is the total value of assets as presented by the institution.  Note that balance information may be cached unless the value was returned by `/accounts/balance/get`, and current balance information is typically not updated intra-day. If you require realtime balance information, use the `available` balance as provided by `/accounts/balance/get`.
  -> AccountBalance
mkAccountBalance accountBalanceCurrent =
  AccountBalance
  { accountBalanceAvailable = Nothing
  , accountBalanceCurrent = Just accountBalanceCurrent
  , accountBalanceLimit = Nothing
  , accountBalanceIsoCurrencyCode = Nothing
  , accountBalanceUnofficialCurrencyCode = Nothing
  }

-- ** AccountBase
-- | AccountBase
-- Account
-- 
-- A single account at a financial institution.
data AccountBase = AccountBase
  { accountBaseAccountId :: !(Text) -- ^ /Required/ "account_id" - Plaid’s unique identifier for the account. This value will not change unless Plaid can&#39;t reconcile the account with the data returned by the financial institution. This may occur, for example, when the name of the account changes. If this happens a new &#x60;account_id&#x60; will be assigned to the account.  The &#x60;account_id&#x60; can also change if the &#x60;access_token&#x60; is deleted and the same credentials that were used to generate that &#x60;access_token&#x60; are used to generate a new &#x60;access_token&#x60; on a later date. In that case, the new &#x60;account_id&#x60; will be different from the old &#x60;account_id&#x60;.  Like all Plaid identifiers, the &#x60;account_id&#x60; is case sensitive.
  , accountBasePersistentAccountId :: !(Maybe Text) -- "persistent_account_id" - A unique and persistent identifier for accounts that can be used to trace multiple instances of the same account across different Items for depository accounts. This is currently only supported for Chase Items. Because Chase accounts have a different account number each time they are linked, this field may be used instead of the account number to uniquely identify a Chase account across multiple Items for payments use cases, helping to reduce duplicate Items or attempted fraud. In Sandbox, this field may be populated for any account; in Production, it will only be populated for Chase accounts.
  , accountBaseBalances :: !(AccountBalance) -- ^ /Required/ "balances"
  , accountBaseMask :: !(Maybe Text) -- ^ "mask" - The last 2-4 alphanumeric characters of an account&#39;s official account number. Note that the mask may be non-unique between an Item&#39;s accounts, and it may also not match the mask that the bank displays to the user.
  , accountBaseName :: !(Text) -- ^ /Required/ "name" - The name of the account, either assigned by the user or by the financial institution itself
  , accountBaseOfficialName :: !(Maybe Text) -- ^ "official_name" - The official name of the account as given by the financial institution
  , accountBaseType :: !(AccountType) -- ^ /Required/ "type"
  , accountBaseSubtype :: !(AccountSubtype) -- ^ /Required/ "subtype"
  , accountBaseVerificationStatus :: !(Maybe E'VerificationStatus2) -- ^ "verification_status" - The current verification status of an Auth Item initiated through Automated or Manual micro-deposits.  Returned for Auth Items only.  &#x60;pending_automatic_verification&#x60;: The Item is pending automatic verification  &#x60;pending_manual_verification&#x60;: The Item is pending manual micro-deposit verification. Items remain in this state until the user successfully verifies the two amounts.  &#x60;automatically_verified&#x60;: The Item has successfully been automatically verified   &#x60;manually_verified&#x60;: The Item has successfully been manually verified  &#x60;verification_expired&#x60;: Plaid was unable to automatically verify the deposit within 7 calendar days and will no longer attempt to validate the Item. Users may retry by submitting their information again through Link.  &#x60;verification_failed&#x60;: The Item failed manual micro-deposit verification because the user exhausted all 3 verification attempts. Users may retry by submitting their information again through Link.   
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AccountBase
instance A.FromJSON AccountBase where
  parseJSON = A.withObject "AccountBase" $ \o ->
    AccountBase
      <$> (o .:  "account_id")
      <*> (o .:?  "persistent_account_id")
      <*> (o .:  "balances")
      <*> (o .:? "mask")
      <*> (o .:  "name")
      <*> (o .:? "official_name")
      <*> (o .:  "type")
      <*> (o .:  "subtype")
      <*> (o .:? "verification_status")

-- | ToJSON AccountBase
instance A.ToJSON AccountBase where
  toJSON AccountBase {..} =
   _omitNulls
      [ "account_id" .= accountBaseAccountId
      , "persistent_account_id" .= accountBasePersistentAccountId
      , "balances" .= accountBaseBalances
      , "mask" .= accountBaseMask
      , "name" .= accountBaseName
      , "official_name" .= accountBaseOfficialName
      , "type" .= accountBaseType
      , "subtype" .= accountBaseSubtype
      , "verification_status" .= accountBaseVerificationStatus
      ]


-- | Construct a value of type 'AccountBase' (by applying it's required fields, if any)
mkAccountBase
  :: Text -- ^ 'accountBaseAccountId': Plaid’s unique identifier for the account. This value will not change unless Plaid can't reconcile the account with the data returned by the financial institution. This may occur, for example, when the name of the account changes. If this happens a new `account_id` will be assigned to the account.  The `account_id` can also change if the `access_token` is deleted and the same credentials that were used to generate that `access_token` are used to generate a new `access_token` on a later date. In that case, the new `account_id` will be different from the old `account_id`.  Like all Plaid identifiers, the `account_id` is case sensitive.
  -> AccountBalance -- ^ 'accountBaseBalances' 
  -> Text -- ^ 'accountBaseName': The name of the account, either assigned by the user or by the financial institution itself
  -> AccountType -- ^ 'accountBaseType' 
  -> AccountSubtype -- ^ 'accountBaseSubtype' 
  -> AccountBase
mkAccountBase accountBaseAccountId accountBaseBalances accountBaseName accountBaseType accountBaseSubtype =
  AccountBase
  { accountBaseAccountId
  , accountBasePersistentAccountId = Nothing
  , accountBaseBalances
  , accountBaseMask = Nothing
  , accountBaseName
  , accountBaseOfficialName = Nothing
  , accountBaseType
  , accountBaseSubtype
  , accountBaseVerificationStatus = Nothing
  }

-- ** AccountFiltersResponse
-- | AccountFiltersResponse
-- AccountFiltersResponse
-- 
-- The `account_filters` specified in the original call to `/link/token/create`. 
data AccountFiltersResponse = AccountFiltersResponse
  { accountFiltersResponseDepository :: !(Maybe DepositoryFilter) -- ^ "depository"
  , accountFiltersResponseCredit :: !(Maybe CreditFilter) -- ^ "credit"
  , accountFiltersResponseLoan :: !(Maybe LoanFilter) -- ^ "loan"
  , accountFiltersResponseInvestment :: !(Maybe InvestmentFilter) -- ^ "investment"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AccountFiltersResponse
instance A.FromJSON AccountFiltersResponse where
  parseJSON = A.withObject "AccountFiltersResponse" $ \o ->
    AccountFiltersResponse
      <$> (o .:? "depository")
      <*> (o .:? "credit")
      <*> (o .:? "loan")
      <*> (o .:? "investment")

-- | ToJSON AccountFiltersResponse
instance A.ToJSON AccountFiltersResponse where
  toJSON AccountFiltersResponse {..} =
   _omitNulls
      [ "depository" .= accountFiltersResponseDepository
      , "credit" .= accountFiltersResponseCredit
      , "loan" .= accountFiltersResponseLoan
      , "investment" .= accountFiltersResponseInvestment
      ]


-- | Construct a value of type 'AccountFiltersResponse' (by applying it's required fields, if any)
mkAccountFiltersResponse
  :: AccountFiltersResponse
mkAccountFiltersResponse =
  AccountFiltersResponse
  { accountFiltersResponseDepository = Nothing
  , accountFiltersResponseCredit = Nothing
  , accountFiltersResponseLoan = Nothing
  , accountFiltersResponseInvestment = Nothing
  }

-- ** AccountIdentity
-- | AccountIdentity
-- AccountIdentity
-- 
data AccountIdentity = AccountIdentity
  { accountIdentityAccountId :: !(Text) -- ^ /Required/ "account_id" - Plaid’s unique identifier for the account. This value will not change unless Plaid can&#39;t reconcile the account with the data returned by the financial institution. This may occur, for example, when the name of the account changes. If this happens a new &#x60;account_id&#x60; will be assigned to the account.  The &#x60;account_id&#x60; can also change if the &#x60;access_token&#x60; is deleted and the same credentials that were used to generate that &#x60;access_token&#x60; are used to generate a new &#x60;access_token&#x60; on a later date. In that case, the new &#x60;account_id&#x60; will be different from the old &#x60;account_id&#x60;.  Like all Plaid identifiers, the &#x60;account_id&#x60; is case sensitive.
  , accountIdentityBalances :: !(AccountBalance) -- ^ /Required/ "balances"
  , accountIdentityMask :: !(Maybe Text) -- ^ "mask" - The last 2-4 alphanumeric characters of an account&#39;s official account number. Note that the mask may be non-unique between an Item&#39;s accounts, and it may also not match the mask that the bank displays to the user.
  , accountIdentityName :: !(Text) -- ^ /Required/ "name" - The name of the account, either assigned by the user or by the financial institution itself
  , accountIdentityOfficialName :: !(Maybe Text) -- ^ "official_name" - The official name of the account as given by the financial institution
  , accountIdentityType :: !(AccountType) -- ^ /Required/ "type"
  , accountIdentitySubtype :: !(AccountSubtype) -- ^ /Required/ "subtype"
  , accountIdentityVerificationStatus :: !(Maybe E'VerificationStatus2) -- ^ "verification_status" - The current verification status of an Auth Item initiated through Automated or Manual micro-deposits.  Returned for Auth Items only.  &#x60;pending_automatic_verification&#x60;: The Item is pending automatic verification  &#x60;pending_manual_verification&#x60;: The Item is pending manual micro-deposit verification. Items remain in this state until the user successfully verifies the two amounts.  &#x60;automatically_verified&#x60;: The Item has successfully been automatically verified   &#x60;manually_verified&#x60;: The Item has successfully been manually verified  &#x60;verification_expired&#x60;: Plaid was unable to automatically verify the deposit within 7 calendar days and will no longer attempt to validate the Item. Users may retry by submitting their information again through Link.  &#x60;verification_failed&#x60;: The Item failed manual micro-deposit verification because the user exhausted all 3 verification attempts. Users may retry by submitting their information again through Link.   
  , accountIdentityOwners :: !([Owner]) -- ^ /Required/ "owners" - Data returned by the financial institution about the account owner or owners. Only returned by Identity or Assets endpoints. Multiple owners on a single account will be represented in the same &#x60;owner&#x60; object, not in multiple owner objects within the array.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AccountIdentity
instance A.FromJSON AccountIdentity where
  parseJSON = A.withObject "AccountIdentity" $ \o ->
    AccountIdentity
      <$> (o .:  "account_id")
      <*> (o .:  "balances")
      <*> (o .:? "mask")
      <*> (o .:  "name")
      <*> (o .:? "official_name")
      <*> (o .:  "type")
      <*> (o .:  "subtype")
      <*> (o .:? "verification_status")
      <*> (o .:  "owners")

-- | ToJSON AccountIdentity
instance A.ToJSON AccountIdentity where
  toJSON AccountIdentity {..} =
   _omitNulls
      [ "account_id" .= accountIdentityAccountId
      , "balances" .= accountIdentityBalances
      , "mask" .= accountIdentityMask
      , "name" .= accountIdentityName
      , "official_name" .= accountIdentityOfficialName
      , "type" .= accountIdentityType
      , "subtype" .= accountIdentitySubtype
      , "verification_status" .= accountIdentityVerificationStatus
      , "owners" .= accountIdentityOwners
      ]


-- | Construct a value of type 'AccountIdentity' (by applying it's required fields, if any)
mkAccountIdentity
  :: Text -- ^ 'accountIdentityAccountId': Plaid’s unique identifier for the account. This value will not change unless Plaid can't reconcile the account with the data returned by the financial institution. This may occur, for example, when the name of the account changes. If this happens a new `account_id` will be assigned to the account.  The `account_id` can also change if the `access_token` is deleted and the same credentials that were used to generate that `access_token` are used to generate a new `access_token` on a later date. In that case, the new `account_id` will be different from the old `account_id`.  Like all Plaid identifiers, the `account_id` is case sensitive.
  -> AccountBalance -- ^ 'accountIdentityBalances' 
  -> Text -- ^ 'accountIdentityName': The name of the account, either assigned by the user or by the financial institution itself
  -> AccountType -- ^ 'accountIdentityType' 
  -> AccountSubtype -- ^ 'accountIdentitySubtype' 
  -> [Owner] -- ^ 'accountIdentityOwners': Data returned by the financial institution about the account owner or owners. Only returned by Identity or Assets endpoints. Multiple owners on a single account will be represented in the same `owner` object, not in multiple owner objects within the array.
  -> AccountIdentity
mkAccountIdentity accountIdentityAccountId accountIdentityBalances accountIdentityName accountIdentityType accountIdentitySubtype accountIdentityOwners =
  AccountIdentity
  { accountIdentityAccountId
  , accountIdentityBalances
  , accountIdentityMask = Nothing
  , accountIdentityName
  , accountIdentityOfficialName = Nothing
  , accountIdentityType
  , accountIdentitySubtype
  , accountIdentityVerificationStatus = Nothing
  , accountIdentityOwners
  }

-- ** AccountIdentityAllOf
-- | AccountIdentityAllOf
data AccountIdentityAllOf = AccountIdentityAllOf
  { accountIdentityAllOfOwners :: !([Owner]) -- ^ /Required/ "owners" - Data returned by the financial institution about the account owner or owners. Only returned by Identity or Assets endpoints. Multiple owners on a single account will be represented in the same &#x60;owner&#x60; object, not in multiple owner objects within the array.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AccountIdentityAllOf
instance A.FromJSON AccountIdentityAllOf where
  parseJSON = A.withObject "AccountIdentityAllOf" $ \o ->
    AccountIdentityAllOf
      <$> (o .:  "owners")

-- | ToJSON AccountIdentityAllOf
instance A.ToJSON AccountIdentityAllOf where
  toJSON AccountIdentityAllOf {..} =
   _omitNulls
      [ "owners" .= accountIdentityAllOfOwners
      ]


-- | Construct a value of type 'AccountIdentityAllOf' (by applying it's required fields, if any)
mkAccountIdentityAllOf
  :: [Owner] -- ^ 'accountIdentityAllOfOwners': Data returned by the financial institution about the account owner or owners. Only returned by Identity or Assets endpoints. Multiple owners on a single account will be represented in the same `owner` object, not in multiple owner objects within the array.
  -> AccountIdentityAllOf
mkAccountIdentityAllOf accountIdentityAllOfOwners =
  AccountIdentityAllOf
  { accountIdentityAllOfOwners
  }

-- ** AccountsBalanceGetRequest
-- | AccountsBalanceGetRequest
-- AccountsBalanceGetRequest defines the request schema for `/accounts/balance/get`
data AccountsBalanceGetRequest = AccountsBalanceGetRequest
  { accountsBalanceGetRequestAccessToken :: !(AccessToken) -- ^ /Required/ "access_token" - The access token associated with the Item data is being requested for.
  , accountsBalanceGetRequestSecret :: !(Maybe Text) -- ^ "secret" - Your Plaid API &#x60;secret&#x60;.
  , accountsBalanceGetRequestClientId :: !(Maybe Text) -- ^ "client_id" - Your Plaid API &#x60;client_id&#x60;.
  , accountsBalanceGetRequestOptions :: !(Maybe AccountsBalanceGetRequestOptions) -- ^ "options"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AccountsBalanceGetRequest
instance A.FromJSON AccountsBalanceGetRequest where
  parseJSON = A.withObject "AccountsBalanceGetRequest" $ \o ->
    AccountsBalanceGetRequest
      <$> (o .:  "access_token")
      <*> (o .:? "secret")
      <*> (o .:? "client_id")
      <*> (o .:? "options")

-- | ToJSON AccountsBalanceGetRequest
instance A.ToJSON AccountsBalanceGetRequest where
  toJSON AccountsBalanceGetRequest {..} =
   _omitNulls
      [ "access_token" .= accountsBalanceGetRequestAccessToken
      , "secret" .= accountsBalanceGetRequestSecret
      , "client_id" .= accountsBalanceGetRequestClientId
      , "options" .= accountsBalanceGetRequestOptions
      ]


-- | Construct a value of type 'AccountsBalanceGetRequest' (by applying it's required fields, if any)
mkAccountsBalanceGetRequest
  :: AccessToken -- ^ 'accountsBalanceGetRequestAccessToken': The access token associated with the Item data is being requested for.
  -> AccountsBalanceGetRequest
mkAccountsBalanceGetRequest accountsBalanceGetRequestAccessToken =
  AccountsBalanceGetRequest
  { accountsBalanceGetRequestAccessToken
  , accountsBalanceGetRequestSecret = Nothing
  , accountsBalanceGetRequestClientId = Nothing
  , accountsBalanceGetRequestOptions = Nothing
  }

-- ** AccountsBalanceGetRequestOptions
-- | AccountsBalanceGetRequestOptions
-- An optional object to filter `/accounts/balance/get` results.
data AccountsBalanceGetRequestOptions = AccountsBalanceGetRequestOptions
  { accountsBalanceGetRequestOptionsAccountIds :: !(Maybe [Text]) -- ^ "account_ids" - A list of &#x60;account_ids&#x60; to retrieve for the Item. The default value is &#x60;null&#x60;.  Note: An error will be returned if a provided &#x60;account_id&#x60; is not associated with the Item.
  , accountsBalanceGetRequestOptionsMinLastUpdatedDatetime :: !(Maybe TI.UTCTime)
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AccountsBalanceGetRequestOptions
instance A.FromJSON AccountsBalanceGetRequestOptions where
  parseJSON = A.withObject "AccountsBalanceGetRequestOptions" $ \o ->
    AccountsBalanceGetRequestOptions
      <$> (o .:? "account_ids")
      <*> (o .:? "min_last_updated_datetime")

-- | ToJSON AccountsBalanceGetRequestOptions
instance A.ToJSON AccountsBalanceGetRequestOptions where
  toJSON AccountsBalanceGetRequestOptions {..} =
   _omitNulls
      [ "account_ids" .= accountsBalanceGetRequestOptionsAccountIds
      , "min_last_updated_datetime" .= accountsBalanceGetRequestOptionsMinLastUpdatedDatetime
      ]


-- | Construct a value of type 'AccountsBalanceGetRequestOptions' (by applying it's required fields, if any)
mkAccountsBalanceGetRequestOptions
  :: AccountsBalanceGetRequestOptions
mkAccountsBalanceGetRequestOptions =
  AccountsBalanceGetRequestOptions
  { accountsBalanceGetRequestOptionsAccountIds = Nothing
  , accountsBalanceGetRequestOptionsMinLastUpdatedDatetime = Nothing
  }

-- ** AccountsGetRequest
-- | AccountsGetRequest
-- AccountsGetRequest defines the request schema for `/accounts/get`
data AccountsGetRequest = AccountsGetRequest
  { accountsGetRequestClientId :: !(Maybe Text) -- ^ "client_id" - Your Plaid API &#x60;client_id&#x60;.
  , accountsGetRequestSecret :: !(Maybe Text) -- ^ "secret" - Your Plaid API &#x60;secret&#x60;.
  , accountsGetRequestAccessToken :: !(AccessToken) -- ^ /Required/ "access_token" - The access token associated with the Item data is being requested for.
  , accountsGetRequestOptions :: !(Maybe AccountsGetRequestOptions) -- ^ "options"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AccountsGetRequest
instance A.FromJSON AccountsGetRequest where
  parseJSON = A.withObject "AccountsGetRequest" $ \o ->
    AccountsGetRequest
      <$> (o .:? "client_id")
      <*> (o .:? "secret")
      <*> (o .:  "access_token")
      <*> (o .:? "options")

-- | ToJSON AccountsGetRequest
instance A.ToJSON AccountsGetRequest where
  toJSON AccountsGetRequest {..} =
   _omitNulls
      [ "client_id" .= accountsGetRequestClientId
      , "secret" .= accountsGetRequestSecret
      , "access_token" .= accountsGetRequestAccessToken
      , "options" .= accountsGetRequestOptions
      ]


-- | Construct a value of type 'AccountsGetRequest' (by applying it's required fields, if any)
mkAccountsGetRequest
  :: AccessToken -- ^ 'accountsGetRequestAccessToken': The access token associated with the Item data is being requested for.
  -> AccountsGetRequest
mkAccountsGetRequest accountsGetRequestAccessToken =
  AccountsGetRequest
  { accountsGetRequestClientId = Nothing
  , accountsGetRequestSecret = Nothing
  , accountsGetRequestAccessToken
  , accountsGetRequestOptions = Nothing
  }

-- ** AccountsGetRequestOptions
-- | AccountsGetRequestOptions
-- An optional object to filter `/accounts/get` results.
data AccountsGetRequestOptions = AccountsGetRequestOptions
  { accountsGetRequestOptionsAccountIds :: !(Maybe [Text]) -- ^ "account_ids" - An array of &#x60;account_ids&#x60; to retrieve for the Account.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AccountsGetRequestOptions
instance A.FromJSON AccountsGetRequestOptions where
  parseJSON = A.withObject "AccountsGetRequestOptions" $ \o ->
    AccountsGetRequestOptions
      <$> (o .:? "account_ids")

-- | ToJSON AccountsGetRequestOptions
instance A.ToJSON AccountsGetRequestOptions where
  toJSON AccountsGetRequestOptions {..} =
   _omitNulls
      [ "account_ids" .= accountsGetRequestOptionsAccountIds
      ]


-- | Construct a value of type 'AccountsGetRequestOptions' (by applying it's required fields, if any)
mkAccountsGetRequestOptions
  :: AccountsGetRequestOptions
mkAccountsGetRequestOptions =
  AccountsGetRequestOptions
  { accountsGetRequestOptionsAccountIds = Nothing
  }

-- ** AccountsGetResponse
-- | AccountsGetResponse
-- AccountsGetResponse defines the response schema for `/accounts/get` and `/accounts/balance/get`.
data AccountsGetResponse = AccountsGetResponse
  { accountsGetResponseAccounts :: !([AccountBase]) -- ^ /Required/ "accounts" - An array of financial institution accounts associated with the Item. If &#x60;/accounts/balance/get&#x60; was called, each account will include real-time balance information.
  , accountsGetResponseItem :: !(Item) -- ^ /Required/ "item"
  , accountsGetResponseRequestId :: !(Text) -- ^ /Required/ "request_id" - A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AccountsGetResponse
instance A.FromJSON AccountsGetResponse where
  parseJSON = A.withObject "AccountsGetResponse" $ \o ->
    AccountsGetResponse
      <$> (o .:  "accounts")
      <*> (o .:  "item")
      <*> (o .:  "request_id")

-- | ToJSON AccountsGetResponse
instance A.ToJSON AccountsGetResponse where
  toJSON AccountsGetResponse {..} =
   _omitNulls
      [ "accounts" .= accountsGetResponseAccounts
      , "item" .= accountsGetResponseItem
      , "request_id" .= accountsGetResponseRequestId
      ]


-- | Construct a value of type 'AccountsGetResponse' (by applying it's required fields, if any)
mkAccountsGetResponse
  :: [AccountBase] -- ^ 'accountsGetResponseAccounts': An array of financial institution accounts associated with the Item. If `/accounts/balance/get` was called, each account will include real-time balance information.
  -> Item -- ^ 'accountsGetResponseItem' 
  -> Text -- ^ 'accountsGetResponseRequestId': A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  -> AccountsGetResponse
mkAccountsGetResponse accountsGetResponseAccounts accountsGetResponseItem accountsGetResponseRequestId =
  AccountsGetResponse
  { accountsGetResponseAccounts
  , accountsGetResponseItem
  , accountsGetResponseRequestId
  }

-- ** Address
-- | Address
-- Address
-- 
-- A physical mailing address.
data Address = Address
  { addressData :: !(AddressData) -- ^ /Required/ "data"
  , addressPrimary :: !(Maybe Bool) -- ^ "primary" - When &#x60;true&#x60;, identifies the address as the primary address on an account.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Address
instance A.FromJSON Address where
  parseJSON = A.withObject "Address" $ \o ->
    Address
      <$> (o .:  "data")
      <*> (o .:? "primary")

-- | ToJSON Address
instance A.ToJSON Address where
  toJSON Address {..} =
   _omitNulls
      [ "data" .= addressData
      , "primary" .= addressPrimary
      ]


-- | Construct a value of type 'Address' (by applying it's required fields, if any)
mkAddress
  :: AddressData -- ^ 'addressData' 
  -> Address
mkAddress addressData =
  Address
  { addressData
  , addressPrimary = Nothing
  }

-- ** AddressData
-- | AddressData
-- AddressData
-- 
-- Data about the components comprising an address.
data AddressData = AddressData
  { addressDataCity :: !(Text) -- ^ /Required/ "city" - The full city name
  , addressDataRegion :: !(Maybe Text) -- ^ "region" - The region or state Example: &#x60;\&quot;NC\&quot;&#x60;
  , addressDataStreet :: !(Text) -- ^ /Required/ "street" - The full street address Example: &#x60;\&quot;564 Main Street, APT 15\&quot;&#x60;
  , addressDataPostalCode :: !(Maybe Text) -- ^ "postal_code" - The postal code
  , addressDataCountry :: !(Maybe Text) -- ^ "country" - The ISO 3166-1 alpha-2 country code
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AddressData
instance A.FromJSON AddressData where
  parseJSON = A.withObject "AddressData" $ \o ->
    AddressData
      <$> (o .:  "city")
      <*> (o .:? "region")
      <*> (o .:  "street")
      <*> (o .:? "postal_code")
      <*> (o .:?  "country")

-- | ToJSON AddressData
instance A.ToJSON AddressData where
  toJSON AddressData {..} =
   _omitNulls
      [ "city" .= addressDataCity
      , "region" .= addressDataRegion
      , "street" .= addressDataStreet
      , "postal_code" .= addressDataPostalCode
      , "country" .= addressDataCountry
      ]


-- | Construct a value of type 'AddressData' (by applying it's required fields, if any)
mkAddressData
  :: Text -- ^ 'addressDataCity': The full city name
  -> Text -- ^ 'addressDataStreet': The full street address Example: `\"564 Main Street, APT 15\"`
  -> AddressData
mkAddressData addressDataCity addressDataStreet =
  AddressData
  { addressDataCity
  , addressDataRegion = Nothing
  , addressDataStreet
  , addressDataPostalCode = Nothing
  , addressDataCountry = Nothing
  }

-- ** Amount
-- | Amount
-- Amount
-- 
-- A payment amount.
data Amount = Amount
  { amountCurrency :: !(E'Currency) -- ^ /Required/ "currency" - The ISO-4217 currency code of the payment. For standing orders, &#x60;\&quot;GBP\&quot;&#x60; must be used.
  , amountValue :: !(Double) -- ^ /Required/ "value" - The amount of the payment. Must contain at most two digits of precision e.g. &#x60;1.23&#x60;. Minimum accepted value is &#x60;1&#x60;.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Amount
instance A.FromJSON Amount where
  parseJSON = A.withObject "Amount" $ \o ->
    Amount
      <$> (o .:  "currency")
      <*> (o .:  "value")

-- | ToJSON Amount
instance A.ToJSON Amount where
  toJSON Amount {..} =
   _omitNulls
      [ "currency" .= amountCurrency
      , "value" .= amountValue
      ]


-- | Construct a value of type 'Amount' (by applying it's required fields, if any)
mkAmount
  :: E'Currency -- ^ 'amountCurrency': The ISO-4217 currency code of the payment. For standing orders, `\"GBP\"` must be used.
  -> Double -- ^ 'amountValue': The amount of the payment. Must contain at most two digits of precision e.g. `1.23`. Minimum accepted value is `1`.
  -> Amount
mkAmount amountCurrency amountValue =
  Amount
  { amountCurrency
  , amountValue
  }

-- ** AssetReport
-- | AssetReport
-- AssetReport
-- 
-- An object representing an Asset Report
data AssetReport = AssetReport
  { assetReportAssetReportId :: !(Text) -- ^ /Required/ "asset_report_id" - A unique ID identifying an Asset Report. Like all Plaid identifiers, this ID is case sensitive.
  , assetReportClientReportId :: !(Text) -- ^ /Required/ "client_report_id" - An identifier you determine and submit for the Asset Report.
  , assetReportDateGenerated :: !(Text) -- ^ /Required/ "date_generated" - The date and time when the Asset Report was created, in ISO 8601 format (e.g. \&quot;2018-04-12T03:32:11Z\&quot;).
  , assetReportDaysRequested :: !(Double) -- ^ /Required/ "days_requested" - The duration of transaction history you requested
  , assetReportUser :: !(AssetReportUser) -- ^ /Required/ "user"
  , assetReportItems :: !([AssetReportItem]) -- ^ /Required/ "items" - Data returned by Plaid about each of the Items included in the Asset Report.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AssetReport
instance A.FromJSON AssetReport where
  parseJSON = A.withObject "AssetReport" $ \o ->
    AssetReport
      <$> (o .:  "asset_report_id")
      <*> (o .:  "client_report_id")
      <*> (o .:  "date_generated")
      <*> (o .:  "days_requested")
      <*> (o .:  "user")
      <*> (o .:  "items")

-- | ToJSON AssetReport
instance A.ToJSON AssetReport where
  toJSON AssetReport {..} =
   _omitNulls
      [ "asset_report_id" .= assetReportAssetReportId
      , "client_report_id" .= assetReportClientReportId
      , "date_generated" .= assetReportDateGenerated
      , "days_requested" .= assetReportDaysRequested
      , "user" .= assetReportUser
      , "items" .= assetReportItems
      ]


-- | Construct a value of type 'AssetReport' (by applying it's required fields, if any)
mkAssetReport
  :: Text -- ^ 'assetReportAssetReportId': A unique ID identifying an Asset Report. Like all Plaid identifiers, this ID is case sensitive.
  -> Text -- ^ 'assetReportClientReportId': An identifier you determine and submit for the Asset Report.
  -> Text -- ^ 'assetReportDateGenerated': The date and time when the Asset Report was created, in ISO 8601 format (e.g. \"2018-04-12T03:32:11Z\").
  -> Double -- ^ 'assetReportDaysRequested': The duration of transaction history you requested
  -> AssetReportUser -- ^ 'assetReportUser' 
  -> [AssetReportItem] -- ^ 'assetReportItems': Data returned by Plaid about each of the Items included in the Asset Report.
  -> AssetReport
mkAssetReport assetReportAssetReportId assetReportClientReportId assetReportDateGenerated assetReportDaysRequested assetReportUser assetReportItems =
  AssetReport
  { assetReportAssetReportId
  , assetReportClientReportId
  , assetReportDateGenerated
  , assetReportDaysRequested
  , assetReportUser
  , assetReportItems
  }

-- ** AssetReportAuditCopyCreateRequest
-- | AssetReportAuditCopyCreateRequest
-- AssetReportAuditCopyCreateRequest defines the request schema for `/asset_report/audit_copy/get`
data AssetReportAuditCopyCreateRequest = AssetReportAuditCopyCreateRequest
  { assetReportAuditCopyCreateRequestClientId :: !(Maybe Text) -- ^ "client_id" - Your Plaid API &#x60;client_id&#x60;.
  , assetReportAuditCopyCreateRequestSecret :: !(Maybe Text) -- ^ "secret" - Your Plaid API &#x60;secret&#x60;.
  , assetReportAuditCopyCreateRequestAssetReportToken :: !(Text) -- ^ /Required/ "asset_report_token" - A token that can be provided to endpoints such as &#x60;/asset_report/get&#x60; or &#x60;/asset_report/pdf/get&#x60; to fetch or update an Asset Report.
  , assetReportAuditCopyCreateRequestAuditorId :: !(Text) -- ^ /Required/ "auditor_id" - The &#x60;auditor_id&#x60; of the third party with whom you would like to share the Asset Report.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AssetReportAuditCopyCreateRequest
instance A.FromJSON AssetReportAuditCopyCreateRequest where
  parseJSON = A.withObject "AssetReportAuditCopyCreateRequest" $ \o ->
    AssetReportAuditCopyCreateRequest
      <$> (o .:? "client_id")
      <*> (o .:? "secret")
      <*> (o .:  "asset_report_token")
      <*> (o .:  "auditor_id")

-- | ToJSON AssetReportAuditCopyCreateRequest
instance A.ToJSON AssetReportAuditCopyCreateRequest where
  toJSON AssetReportAuditCopyCreateRequest {..} =
   _omitNulls
      [ "client_id" .= assetReportAuditCopyCreateRequestClientId
      , "secret" .= assetReportAuditCopyCreateRequestSecret
      , "asset_report_token" .= assetReportAuditCopyCreateRequestAssetReportToken
      , "auditor_id" .= assetReportAuditCopyCreateRequestAuditorId
      ]


-- | Construct a value of type 'AssetReportAuditCopyCreateRequest' (by applying it's required fields, if any)
mkAssetReportAuditCopyCreateRequest
  :: Text -- ^ 'assetReportAuditCopyCreateRequestAssetReportToken': A token that can be provided to endpoints such as `/asset_report/get` or `/asset_report/pdf/get` to fetch or update an Asset Report.
  -> Text -- ^ 'assetReportAuditCopyCreateRequestAuditorId': The `auditor_id` of the third party with whom you would like to share the Asset Report.
  -> AssetReportAuditCopyCreateRequest
mkAssetReportAuditCopyCreateRequest assetReportAuditCopyCreateRequestAssetReportToken assetReportAuditCopyCreateRequestAuditorId =
  AssetReportAuditCopyCreateRequest
  { assetReportAuditCopyCreateRequestClientId = Nothing
  , assetReportAuditCopyCreateRequestSecret = Nothing
  , assetReportAuditCopyCreateRequestAssetReportToken
  , assetReportAuditCopyCreateRequestAuditorId
  }

-- ** AssetReportAuditCopyCreateResponse
-- | AssetReportAuditCopyCreateResponse
-- AssetReportAuditCopyCreateResponse defines the response schema for `/asset_report/audit_copy/get`
data AssetReportAuditCopyCreateResponse = AssetReportAuditCopyCreateResponse
  { assetReportAuditCopyCreateResponseAuditCopyToken :: !(Text) -- ^ /Required/ "audit_copy_token" - A token that can be shared with a third party auditor to allow them to obtain access to the Asset Report. This token should be stored securely.
  , assetReportAuditCopyCreateResponseRequestId :: !(Text) -- ^ /Required/ "request_id" - A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AssetReportAuditCopyCreateResponse
instance A.FromJSON AssetReportAuditCopyCreateResponse where
  parseJSON = A.withObject "AssetReportAuditCopyCreateResponse" $ \o ->
    AssetReportAuditCopyCreateResponse
      <$> (o .:  "audit_copy_token")
      <*> (o .:  "request_id")

-- | ToJSON AssetReportAuditCopyCreateResponse
instance A.ToJSON AssetReportAuditCopyCreateResponse where
  toJSON AssetReportAuditCopyCreateResponse {..} =
   _omitNulls
      [ "audit_copy_token" .= assetReportAuditCopyCreateResponseAuditCopyToken
      , "request_id" .= assetReportAuditCopyCreateResponseRequestId
      ]


-- | Construct a value of type 'AssetReportAuditCopyCreateResponse' (by applying it's required fields, if any)
mkAssetReportAuditCopyCreateResponse
  :: Text -- ^ 'assetReportAuditCopyCreateResponseAuditCopyToken': A token that can be shared with a third party auditor to allow them to obtain access to the Asset Report. This token should be stored securely.
  -> Text -- ^ 'assetReportAuditCopyCreateResponseRequestId': A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  -> AssetReportAuditCopyCreateResponse
mkAssetReportAuditCopyCreateResponse assetReportAuditCopyCreateResponseAuditCopyToken assetReportAuditCopyCreateResponseRequestId =
  AssetReportAuditCopyCreateResponse
  { assetReportAuditCopyCreateResponseAuditCopyToken
  , assetReportAuditCopyCreateResponseRequestId
  }

-- ** AssetReportAuditCopyGetRequest
-- | AssetReportAuditCopyGetRequest
-- AssetReportAuditCopyGetRequest
-- 
-- AssetReportAuditCopyGetRequest defines the request schema for `/asset_report/audit_copy/get`
data AssetReportAuditCopyGetRequest = AssetReportAuditCopyGetRequest
  { assetReportAuditCopyGetRequestClientId :: !(Maybe Text) -- ^ "client_id" - Your Plaid API &#x60;client_id&#x60;.
  , assetReportAuditCopyGetRequestSecret :: !(Maybe Text) -- ^ "secret" - Your Plaid API &#x60;secret&#x60;.
  , assetReportAuditCopyGetRequestAuditCopyToken :: !(Text) -- ^ /Required/ "audit_copy_token" - The &#x60;audit_copy_token&#x60; granting access to the Audit Copy you would like to get.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AssetReportAuditCopyGetRequest
instance A.FromJSON AssetReportAuditCopyGetRequest where
  parseJSON = A.withObject "AssetReportAuditCopyGetRequest" $ \o ->
    AssetReportAuditCopyGetRequest
      <$> (o .:? "client_id")
      <*> (o .:? "secret")
      <*> (o .:  "audit_copy_token")

-- | ToJSON AssetReportAuditCopyGetRequest
instance A.ToJSON AssetReportAuditCopyGetRequest where
  toJSON AssetReportAuditCopyGetRequest {..} =
   _omitNulls
      [ "client_id" .= assetReportAuditCopyGetRequestClientId
      , "secret" .= assetReportAuditCopyGetRequestSecret
      , "audit_copy_token" .= assetReportAuditCopyGetRequestAuditCopyToken
      ]


-- | Construct a value of type 'AssetReportAuditCopyGetRequest' (by applying it's required fields, if any)
mkAssetReportAuditCopyGetRequest
  :: Text -- ^ 'assetReportAuditCopyGetRequestAuditCopyToken': The `audit_copy_token` granting access to the Audit Copy you would like to get.
  -> AssetReportAuditCopyGetRequest
mkAssetReportAuditCopyGetRequest assetReportAuditCopyGetRequestAuditCopyToken =
  AssetReportAuditCopyGetRequest
  { assetReportAuditCopyGetRequestClientId = Nothing
  , assetReportAuditCopyGetRequestSecret = Nothing
  , assetReportAuditCopyGetRequestAuditCopyToken
  }

-- ** AssetReportAuditCopyRemoveRequest
-- | AssetReportAuditCopyRemoveRequest
-- AssetReportAuditCopyRemoveRequest defines the request schema for `/asset_report/audit_copy/remove`
data AssetReportAuditCopyRemoveRequest = AssetReportAuditCopyRemoveRequest
  { assetReportAuditCopyRemoveRequestClientId :: !(Maybe Text) -- ^ "client_id" - Your Plaid API &#x60;client_id&#x60;.
  , assetReportAuditCopyRemoveRequestSecret :: !(Maybe Text) -- ^ "secret" - Your Plaid API &#x60;secret&#x60;.
  , assetReportAuditCopyRemoveRequestAuditCopyToken :: !(Text) -- ^ /Required/ "audit_copy_token" - The &#x60;audit_copy_token&#x60; granting access to the Audit Copy you would like to revoke.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AssetReportAuditCopyRemoveRequest
instance A.FromJSON AssetReportAuditCopyRemoveRequest where
  parseJSON = A.withObject "AssetReportAuditCopyRemoveRequest" $ \o ->
    AssetReportAuditCopyRemoveRequest
      <$> (o .:? "client_id")
      <*> (o .:? "secret")
      <*> (o .:  "audit_copy_token")

-- | ToJSON AssetReportAuditCopyRemoveRequest
instance A.ToJSON AssetReportAuditCopyRemoveRequest where
  toJSON AssetReportAuditCopyRemoveRequest {..} =
   _omitNulls
      [ "client_id" .= assetReportAuditCopyRemoveRequestClientId
      , "secret" .= assetReportAuditCopyRemoveRequestSecret
      , "audit_copy_token" .= assetReportAuditCopyRemoveRequestAuditCopyToken
      ]


-- | Construct a value of type 'AssetReportAuditCopyRemoveRequest' (by applying it's required fields, if any)
mkAssetReportAuditCopyRemoveRequest
  :: Text -- ^ 'assetReportAuditCopyRemoveRequestAuditCopyToken': The `audit_copy_token` granting access to the Audit Copy you would like to revoke.
  -> AssetReportAuditCopyRemoveRequest
mkAssetReportAuditCopyRemoveRequest assetReportAuditCopyRemoveRequestAuditCopyToken =
  AssetReportAuditCopyRemoveRequest
  { assetReportAuditCopyRemoveRequestClientId = Nothing
  , assetReportAuditCopyRemoveRequestSecret = Nothing
  , assetReportAuditCopyRemoveRequestAuditCopyToken
  }

-- ** AssetReportAuditCopyRemoveResponse
-- | AssetReportAuditCopyRemoveResponse
-- AssetReportAuditCopyRemoveResponse defines the response schema for `/asset_report/audit_copy/remove`
data AssetReportAuditCopyRemoveResponse = AssetReportAuditCopyRemoveResponse
  { assetReportAuditCopyRemoveResponseRemoved :: !(Bool) -- ^ /Required/ "removed" - &#x60;true&#x60; if the Audit Copy was successfully removed.
  , assetReportAuditCopyRemoveResponseRequestId :: !(Text) -- ^ /Required/ "request_id" - A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AssetReportAuditCopyRemoveResponse
instance A.FromJSON AssetReportAuditCopyRemoveResponse where
  parseJSON = A.withObject "AssetReportAuditCopyRemoveResponse" $ \o ->
    AssetReportAuditCopyRemoveResponse
      <$> (o .:  "removed")
      <*> (o .:  "request_id")

-- | ToJSON AssetReportAuditCopyRemoveResponse
instance A.ToJSON AssetReportAuditCopyRemoveResponse where
  toJSON AssetReportAuditCopyRemoveResponse {..} =
   _omitNulls
      [ "removed" .= assetReportAuditCopyRemoveResponseRemoved
      , "request_id" .= assetReportAuditCopyRemoveResponseRequestId
      ]


-- | Construct a value of type 'AssetReportAuditCopyRemoveResponse' (by applying it's required fields, if any)
mkAssetReportAuditCopyRemoveResponse
  :: Bool -- ^ 'assetReportAuditCopyRemoveResponseRemoved': `true` if the Audit Copy was successfully removed.
  -> Text -- ^ 'assetReportAuditCopyRemoveResponseRequestId': A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  -> AssetReportAuditCopyRemoveResponse
mkAssetReportAuditCopyRemoveResponse assetReportAuditCopyRemoveResponseRemoved assetReportAuditCopyRemoveResponseRequestId =
  AssetReportAuditCopyRemoveResponse
  { assetReportAuditCopyRemoveResponseRemoved
  , assetReportAuditCopyRemoveResponseRequestId
  }

-- ** AssetReportCreateRequest
-- | AssetReportCreateRequest
-- AssetReportCreateRequest defines the request schema for `/asset_report/create`
data AssetReportCreateRequest = AssetReportCreateRequest
  { assetReportCreateRequestClientId :: !(Maybe Text) -- ^ "client_id" - Your Plaid API &#x60;client_id&#x60;.
  , assetReportCreateRequestSecret :: !(Maybe Text) -- ^ "secret" - Your Plaid API &#x60;secret&#x60;.
  , assetReportCreateRequestAccessTokens :: !([AccessToken]) -- ^ /Required/ "access_tokens" - An array of access tokens corresponding to the Items that will be included in the report. The &#x60;assets&#x60; product must have been initialized for the Items during link; the Assets product cannot be added after initialization.
  , assetReportCreateRequestDaysRequested :: !(Int) -- ^ /Required/ "days_requested" - The maximum integer number of days of history to include in the Asset Report. If using Fannie Mae Day 1 Certainty, &#x60;days_requested&#x60; must be at least 61 for new originations or at least 31 for refinancings.
  , assetReportCreateRequestOptions :: !(Maybe AssetReportCreateRequestOptions) -- ^ "options"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AssetReportCreateRequest
instance A.FromJSON AssetReportCreateRequest where
  parseJSON = A.withObject "AssetReportCreateRequest" $ \o ->
    AssetReportCreateRequest
      <$> (o .:? "client_id")
      <*> (o .:? "secret")
      <*> (o .:  "access_tokens")
      <*> (o .:  "days_requested")
      <*> (o .:? "options")

-- | ToJSON AssetReportCreateRequest
instance A.ToJSON AssetReportCreateRequest where
  toJSON AssetReportCreateRequest {..} =
   _omitNulls
      [ "client_id" .= assetReportCreateRequestClientId
      , "secret" .= assetReportCreateRequestSecret
      , "access_tokens" .= assetReportCreateRequestAccessTokens
      , "days_requested" .= assetReportCreateRequestDaysRequested
      , "options" .= assetReportCreateRequestOptions
      ]


-- | Construct a value of type 'AssetReportCreateRequest' (by applying it's required fields, if any)
mkAssetReportCreateRequest
  :: [AccessToken] -- ^ 'assetReportCreateRequestAccessTokens': An array of access tokens corresponding to the Items that will be included in the report. The `assets` product must have been initialized for the Items during link; the Assets product cannot be added after initialization.
  -> Int -- ^ 'assetReportCreateRequestDaysRequested': The maximum integer number of days of history to include in the Asset Report. If using Fannie Mae Day 1 Certainty, `days_requested` must be at least 61 for new originations or at least 31 for refinancings.
  -> AssetReportCreateRequest
mkAssetReportCreateRequest assetReportCreateRequestAccessTokens assetReportCreateRequestDaysRequested =
  AssetReportCreateRequest
  { assetReportCreateRequestClientId = Nothing
  , assetReportCreateRequestSecret = Nothing
  , assetReportCreateRequestAccessTokens
  , assetReportCreateRequestDaysRequested
  , assetReportCreateRequestOptions = Nothing
  }

-- ** AssetReportCreateRequestOptions
-- | AssetReportCreateRequestOptions
-- An optional object to filter `/asset_report/create` results. If provided, must be non-`null`. The optional `user` object is required for the report to be eligible for Fannie Mae's Day 1 Certainty program.
data AssetReportCreateRequestOptions = AssetReportCreateRequestOptions
  { assetReportCreateRequestOptionsClientReportId :: !(Maybe Text) -- ^ "client_report_id" - Client-generated identifier, which can be used by lenders to track loan applications.
  , assetReportCreateRequestOptionsWebhook :: !(Maybe Text) -- ^ "webhook" - URL to which Plaid will send Assets webhooks, for example when the requested Asset Report is ready.
  , assetReportCreateRequestOptionsUser :: !(Maybe AssetReportUser) -- ^ "user"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AssetReportCreateRequestOptions
instance A.FromJSON AssetReportCreateRequestOptions where
  parseJSON = A.withObject "AssetReportCreateRequestOptions" $ \o ->
    AssetReportCreateRequestOptions
      <$> (o .:? "client_report_id")
      <*> (o .:? "webhook")
      <*> (o .:? "user")

-- | ToJSON AssetReportCreateRequestOptions
instance A.ToJSON AssetReportCreateRequestOptions where
  toJSON AssetReportCreateRequestOptions {..} =
   _omitNulls
      [ "client_report_id" .= assetReportCreateRequestOptionsClientReportId
      , "webhook" .= assetReportCreateRequestOptionsWebhook
      , "user" .= assetReportCreateRequestOptionsUser
      ]


-- | Construct a value of type 'AssetReportCreateRequestOptions' (by applying it's required fields, if any)
mkAssetReportCreateRequestOptions
  :: AssetReportCreateRequestOptions
mkAssetReportCreateRequestOptions =
  AssetReportCreateRequestOptions
  { assetReportCreateRequestOptionsClientReportId = Nothing
  , assetReportCreateRequestOptionsWebhook = Nothing
  , assetReportCreateRequestOptionsUser = Nothing
  }

-- ** AssetReportCreateResponse
-- | AssetReportCreateResponse
-- AssetReportCreateResponse defines the response schema for `/asset_report/create`
data AssetReportCreateResponse = AssetReportCreateResponse
  { assetReportCreateResponseAssetReportToken :: !(Text) -- ^ /Required/ "asset_report_token" - A token that can be provided to endpoints such as &#x60;/asset_report/get&#x60; or &#x60;/asset_report/pdf/get&#x60; to fetch or update an Asset Report.
  , assetReportCreateResponseAssetReportId :: !(Text) -- ^ /Required/ "asset_report_id" - A unique ID identifying an Asset Report. Like all Plaid identifiers, this ID is case sensitive.
  , assetReportCreateResponseRequestId :: !(Text) -- ^ /Required/ "request_id" - A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AssetReportCreateResponse
instance A.FromJSON AssetReportCreateResponse where
  parseJSON = A.withObject "AssetReportCreateResponse" $ \o ->
    AssetReportCreateResponse
      <$> (o .:  "asset_report_token")
      <*> (o .:  "asset_report_id")
      <*> (o .:  "request_id")

-- | ToJSON AssetReportCreateResponse
instance A.ToJSON AssetReportCreateResponse where
  toJSON AssetReportCreateResponse {..} =
   _omitNulls
      [ "asset_report_token" .= assetReportCreateResponseAssetReportToken
      , "asset_report_id" .= assetReportCreateResponseAssetReportId
      , "request_id" .= assetReportCreateResponseRequestId
      ]


-- | Construct a value of type 'AssetReportCreateResponse' (by applying it's required fields, if any)
mkAssetReportCreateResponse
  :: Text -- ^ 'assetReportCreateResponseAssetReportToken': A token that can be provided to endpoints such as `/asset_report/get` or `/asset_report/pdf/get` to fetch or update an Asset Report.
  -> Text -- ^ 'assetReportCreateResponseAssetReportId': A unique ID identifying an Asset Report. Like all Plaid identifiers, this ID is case sensitive.
  -> Text -- ^ 'assetReportCreateResponseRequestId': A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  -> AssetReportCreateResponse
mkAssetReportCreateResponse assetReportCreateResponseAssetReportToken assetReportCreateResponseAssetReportId assetReportCreateResponseRequestId =
  AssetReportCreateResponse
  { assetReportCreateResponseAssetReportToken
  , assetReportCreateResponseAssetReportId
  , assetReportCreateResponseRequestId
  }

-- ** AssetReportFilterRequest
-- | AssetReportFilterRequest
-- AssetReportFilterRequest defines the request schema for `/asset_report/filter`
data AssetReportFilterRequest = AssetReportFilterRequest
  { assetReportFilterRequestClientId :: !(Maybe Text) -- ^ "client_id" - Your Plaid API &#x60;client_id&#x60;.
  , assetReportFilterRequestSecret :: !(Maybe Text) -- ^ "secret" - Your Plaid API &#x60;secret&#x60;.
  , assetReportFilterRequestAssetReportToken :: !(Text) -- ^ /Required/ "asset_report_token" - A token that can be provided to endpoints such as &#x60;/asset_report/get&#x60; or &#x60;/asset_report/pdf/get&#x60; to fetch or update an Asset Report.
  , assetReportFilterRequestAccountIdsToExclude :: !([Text]) -- ^ /Required/ "account_ids_to_exclude" - The accounts to exclude from the Asset Report, identified by &#x60;account_id&#x60;.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AssetReportFilterRequest
instance A.FromJSON AssetReportFilterRequest where
  parseJSON = A.withObject "AssetReportFilterRequest" $ \o ->
    AssetReportFilterRequest
      <$> (o .:? "client_id")
      <*> (o .:? "secret")
      <*> (o .:  "asset_report_token")
      <*> (o .:  "account_ids_to_exclude")

-- | ToJSON AssetReportFilterRequest
instance A.ToJSON AssetReportFilterRequest where
  toJSON AssetReportFilterRequest {..} =
   _omitNulls
      [ "client_id" .= assetReportFilterRequestClientId
      , "secret" .= assetReportFilterRequestSecret
      , "asset_report_token" .= assetReportFilterRequestAssetReportToken
      , "account_ids_to_exclude" .= assetReportFilterRequestAccountIdsToExclude
      ]


-- | Construct a value of type 'AssetReportFilterRequest' (by applying it's required fields, if any)
mkAssetReportFilterRequest
  :: Text -- ^ 'assetReportFilterRequestAssetReportToken': A token that can be provided to endpoints such as `/asset_report/get` or `/asset_report/pdf/get` to fetch or update an Asset Report.
  -> [Text] -- ^ 'assetReportFilterRequestAccountIdsToExclude': The accounts to exclude from the Asset Report, identified by `account_id`.
  -> AssetReportFilterRequest
mkAssetReportFilterRequest assetReportFilterRequestAssetReportToken assetReportFilterRequestAccountIdsToExclude =
  AssetReportFilterRequest
  { assetReportFilterRequestClientId = Nothing
  , assetReportFilterRequestSecret = Nothing
  , assetReportFilterRequestAssetReportToken
  , assetReportFilterRequestAccountIdsToExclude
  }

-- ** AssetReportFilterResponse
-- | AssetReportFilterResponse
-- AssetReportFilterResponse defines the response schema for `/asset_report/filter`
data AssetReportFilterResponse = AssetReportFilterResponse
  { assetReportFilterResponseAssetReportToken :: !(Text) -- ^ /Required/ "asset_report_token" - A token that can be provided to endpoints such as &#x60;/asset_report/get&#x60; or &#x60;/asset_report/pdf/get&#x60; to fetch or update an Asset Report.
  , assetReportFilterResponseAssetReportId :: !(Text) -- ^ /Required/ "asset_report_id" - A unique ID identifying an Asset Report. Like all Plaid identifiers, this ID is case sensitive.
  , assetReportFilterResponseRequestId :: !(Text) -- ^ /Required/ "request_id" - A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AssetReportFilterResponse
instance A.FromJSON AssetReportFilterResponse where
  parseJSON = A.withObject "AssetReportFilterResponse" $ \o ->
    AssetReportFilterResponse
      <$> (o .:  "asset_report_token")
      <*> (o .:  "asset_report_id")
      <*> (o .:  "request_id")

-- | ToJSON AssetReportFilterResponse
instance A.ToJSON AssetReportFilterResponse where
  toJSON AssetReportFilterResponse {..} =
   _omitNulls
      [ "asset_report_token" .= assetReportFilterResponseAssetReportToken
      , "asset_report_id" .= assetReportFilterResponseAssetReportId
      , "request_id" .= assetReportFilterResponseRequestId
      ]


-- | Construct a value of type 'AssetReportFilterResponse' (by applying it's required fields, if any)
mkAssetReportFilterResponse
  :: Text -- ^ 'assetReportFilterResponseAssetReportToken': A token that can be provided to endpoints such as `/asset_report/get` or `/asset_report/pdf/get` to fetch or update an Asset Report.
  -> Text -- ^ 'assetReportFilterResponseAssetReportId': A unique ID identifying an Asset Report. Like all Plaid identifiers, this ID is case sensitive.
  -> Text -- ^ 'assetReportFilterResponseRequestId': A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  -> AssetReportFilterResponse
mkAssetReportFilterResponse assetReportFilterResponseAssetReportToken assetReportFilterResponseAssetReportId assetReportFilterResponseRequestId =
  AssetReportFilterResponse
  { assetReportFilterResponseAssetReportToken
  , assetReportFilterResponseAssetReportId
  , assetReportFilterResponseRequestId
  }

-- ** AssetReportGetRequest
-- | AssetReportGetRequest
-- AssetReportGetRequest defines the request schema for `/asset_report/get`
data AssetReportGetRequest = AssetReportGetRequest
  { assetReportGetRequestClientId :: !(Maybe Text) -- ^ "client_id" - Your Plaid API &#x60;client_id&#x60;.
  , assetReportGetRequestSecret :: !(Maybe Text) -- ^ "secret" - Your Plaid API &#x60;secret&#x60;.
  , assetReportGetRequestAssetReportToken :: !(Text) -- ^ /Required/ "asset_report_token" - A token that can be provided to endpoints such as &#x60;/asset_report/get&#x60; or &#x60;/asset_report/pdf/get&#x60; to fetch or update an Asset Report.
  , assetReportGetRequestIncludeInsights :: !(Maybe Bool) -- ^ "include_insights" - &#x60;true&#x60; if you would like to retrieve the Asset Report with Insights, &#x60;false&#x60; otherwise. This field defaults to &#x60;false&#x60; if omitted. [Contact Plaid Support](https://dashboard.plaid.com/support) to get access to this feature.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AssetReportGetRequest
instance A.FromJSON AssetReportGetRequest where
  parseJSON = A.withObject "AssetReportGetRequest" $ \o ->
    AssetReportGetRequest
      <$> (o .:? "client_id")
      <*> (o .:? "secret")
      <*> (o .:  "asset_report_token")
      <*> (o .:? "include_insights")

-- | ToJSON AssetReportGetRequest
instance A.ToJSON AssetReportGetRequest where
  toJSON AssetReportGetRequest {..} =
   _omitNulls
      [ "client_id" .= assetReportGetRequestClientId
      , "secret" .= assetReportGetRequestSecret
      , "asset_report_token" .= assetReportGetRequestAssetReportToken
      , "include_insights" .= assetReportGetRequestIncludeInsights
      ]


-- | Construct a value of type 'AssetReportGetRequest' (by applying it's required fields, if any)
mkAssetReportGetRequest
  :: Text -- ^ 'assetReportGetRequestAssetReportToken': A token that can be provided to endpoints such as `/asset_report/get` or `/asset_report/pdf/get` to fetch or update an Asset Report.
  -> AssetReportGetRequest
mkAssetReportGetRequest assetReportGetRequestAssetReportToken =
  AssetReportGetRequest
  { assetReportGetRequestClientId = Nothing
  , assetReportGetRequestSecret = Nothing
  , assetReportGetRequestAssetReportToken
  , assetReportGetRequestIncludeInsights = Nothing
  }

-- ** AssetReportGetResponse
-- | AssetReportGetResponse
-- AssetReportGetResponse defines the response schema for `/asset_report/get`
data AssetReportGetResponse = AssetReportGetResponse
  { assetReportGetResponseReport :: !(AssetReport) -- ^ /Required/ "report"
  , assetReportGetResponseWarnings :: !([Warning]) -- ^ /Required/ "warnings" - If the Asset Report generation was successful but identity information cannot be returned, this array will contain information about the errors causing identity information to be missing
  , assetReportGetResponseRequestId :: !(Text) -- ^ /Required/ "request_id" - A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AssetReportGetResponse
instance A.FromJSON AssetReportGetResponse where
  parseJSON = A.withObject "AssetReportGetResponse" $ \o ->
    AssetReportGetResponse
      <$> (o .:  "report")
      <*> (o .:  "warnings")
      <*> (o .:  "request_id")

-- | ToJSON AssetReportGetResponse
instance A.ToJSON AssetReportGetResponse where
  toJSON AssetReportGetResponse {..} =
   _omitNulls
      [ "report" .= assetReportGetResponseReport
      , "warnings" .= assetReportGetResponseWarnings
      , "request_id" .= assetReportGetResponseRequestId
      ]


-- | Construct a value of type 'AssetReportGetResponse' (by applying it's required fields, if any)
mkAssetReportGetResponse
  :: AssetReport -- ^ 'assetReportGetResponseReport' 
  -> [Warning] -- ^ 'assetReportGetResponseWarnings': If the Asset Report generation was successful but identity information cannot be returned, this array will contain information about the errors causing identity information to be missing
  -> Text -- ^ 'assetReportGetResponseRequestId': A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  -> AssetReportGetResponse
mkAssetReportGetResponse assetReportGetResponseReport assetReportGetResponseWarnings assetReportGetResponseRequestId =
  AssetReportGetResponse
  { assetReportGetResponseReport
  , assetReportGetResponseWarnings
  , assetReportGetResponseRequestId
  }

-- ** AssetReportItem
-- | AssetReportItem
-- AssetReportItem
-- 
-- A representation of an Item within an Asset Report.
data AssetReportItem = AssetReportItem
  { assetReportItemItemId :: !(ItemId) -- ^ /Required/ "item_id" - The &#x60;item_id&#x60; of the Item associated with this webhook, warning, or error
  , assetReportItemInstitutionName :: !(Text) -- ^ /Required/ "institution_name" - The full financial institution name associated with the Item.
  , assetReportItemInstitutionId :: !(Text) -- ^ /Required/ "institution_id" - The id of the financial institution associated with the Item.
  , assetReportItemDateLastUpdated :: !(Text) -- ^ /Required/ "date_last_updated" - The date and time when this Item’s data was last retrieved from the financial institution, in ISO 8601 format.
  , assetReportItemAccounts :: !([AccountAssets]) -- ^ /Required/ "accounts" - Data about each of the accounts open on the Item.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AssetReportItem
instance A.FromJSON AssetReportItem where
  parseJSON = A.withObject "AssetReportItem" $ \o ->
    AssetReportItem
      <$> (o .:  "item_id")
      <*> (o .:  "institution_name")
      <*> (o .:  "institution_id")
      <*> (o .:  "date_last_updated")
      <*> (o .:  "accounts")

-- | ToJSON AssetReportItem
instance A.ToJSON AssetReportItem where
  toJSON AssetReportItem {..} =
   _omitNulls
      [ "item_id" .= assetReportItemItemId
      , "institution_name" .= assetReportItemInstitutionName
      , "institution_id" .= assetReportItemInstitutionId
      , "date_last_updated" .= assetReportItemDateLastUpdated
      , "accounts" .= assetReportItemAccounts
      ]


-- | Construct a value of type 'AssetReportItem' (by applying it's required fields, if any)
mkAssetReportItem
  :: ItemId -- ^ 'assetReportItemItemId': The `item_id` of the Item associated with this webhook, warning, or error
  -> Text -- ^ 'assetReportItemInstitutionName': The full financial institution name associated with the Item.
  -> Text -- ^ 'assetReportItemInstitutionId': The id of the financial institution associated with the Item.
  -> Text -- ^ 'assetReportItemDateLastUpdated': The date and time when this Item’s data was last retrieved from the financial institution, in ISO 8601 format.
  -> [AccountAssets] -- ^ 'assetReportItemAccounts': Data about each of the accounts open on the Item.
  -> AssetReportItem
mkAssetReportItem assetReportItemItemId assetReportItemInstitutionName assetReportItemInstitutionId assetReportItemDateLastUpdated assetReportItemAccounts =
  AssetReportItem
  { assetReportItemItemId
  , assetReportItemInstitutionName
  , assetReportItemInstitutionId
  , assetReportItemDateLastUpdated
  , assetReportItemAccounts
  }

-- ** AssetReportPDFGetRequest
-- | AssetReportPDFGetRequest
-- AssetReportPDFGetRequest defines the request schema for `/asset_report/pdf/get`
data AssetReportPDFGetRequest = AssetReportPDFGetRequest
  { assetReportPDFGetRequestClientId :: !(Maybe Text) -- ^ "client_id" - Your Plaid API &#x60;client_id&#x60;.
  , assetReportPDFGetRequestSecret :: !(Maybe Text) -- ^ "secret" - Your Plaid API &#x60;secret&#x60;.
  , assetReportPDFGetRequestAssetReportToken :: !(Text) -- ^ /Required/ "asset_report_token" - A token that can be provided to endpoints such as &#x60;/asset_report/get&#x60; or &#x60;/asset_report/pdf/get&#x60; to fetch or update an Asset Report.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AssetReportPDFGetRequest
instance A.FromJSON AssetReportPDFGetRequest where
  parseJSON = A.withObject "AssetReportPDFGetRequest" $ \o ->
    AssetReportPDFGetRequest
      <$> (o .:? "client_id")
      <*> (o .:? "secret")
      <*> (o .:  "asset_report_token")

-- | ToJSON AssetReportPDFGetRequest
instance A.ToJSON AssetReportPDFGetRequest where
  toJSON AssetReportPDFGetRequest {..} =
   _omitNulls
      [ "client_id" .= assetReportPDFGetRequestClientId
      , "secret" .= assetReportPDFGetRequestSecret
      , "asset_report_token" .= assetReportPDFGetRequestAssetReportToken
      ]


-- | Construct a value of type 'AssetReportPDFGetRequest' (by applying it's required fields, if any)
mkAssetReportPDFGetRequest
  :: Text -- ^ 'assetReportPDFGetRequestAssetReportToken': A token that can be provided to endpoints such as `/asset_report/get` or `/asset_report/pdf/get` to fetch or update an Asset Report.
  -> AssetReportPDFGetRequest
mkAssetReportPDFGetRequest assetReportPDFGetRequestAssetReportToken =
  AssetReportPDFGetRequest
  { assetReportPDFGetRequestClientId = Nothing
  , assetReportPDFGetRequestSecret = Nothing
  , assetReportPDFGetRequestAssetReportToken
  }

-- ** AssetReportRefreshRequest
-- | AssetReportRefreshRequest
-- AssetReportRefreshRequest defines the request schema for `/asset_report/refresh`
data AssetReportRefreshRequest = AssetReportRefreshRequest
  { assetReportRefreshRequestClientId :: !(Maybe Text) -- ^ "client_id" - Your Plaid API &#x60;client_id&#x60;.
  , assetReportRefreshRequestSecret :: !(Maybe Text) -- ^ "secret" - Your Plaid API &#x60;secret&#x60;.
  , assetReportRefreshRequestAssetReportToken :: !(Text) -- ^ /Required/ "asset_report_token" - The &#x60;asset_report_token&#x60; returned by the original call to &#x60;/asset_report/create&#x60;
  , assetReportRefreshRequestDaysRequested :: !(Maybe Int) -- ^ "days_requested" - The maximum number of days of history to include in the Asset Report. Must be an integer. If not specified, the value from the original call to &#x60;/asset_report/create&#x60; will be used.
  , assetReportRefreshRequestOptions :: !(Maybe AssetReportRefreshRequestOptions) -- ^ "options"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AssetReportRefreshRequest
instance A.FromJSON AssetReportRefreshRequest where
  parseJSON = A.withObject "AssetReportRefreshRequest" $ \o ->
    AssetReportRefreshRequest
      <$> (o .:? "client_id")
      <*> (o .:? "secret")
      <*> (o .:  "asset_report_token")
      <*> (o .:? "days_requested")
      <*> (o .:? "options")

-- | ToJSON AssetReportRefreshRequest
instance A.ToJSON AssetReportRefreshRequest where
  toJSON AssetReportRefreshRequest {..} =
   _omitNulls
      [ "client_id" .= assetReportRefreshRequestClientId
      , "secret" .= assetReportRefreshRequestSecret
      , "asset_report_token" .= assetReportRefreshRequestAssetReportToken
      , "days_requested" .= assetReportRefreshRequestDaysRequested
      , "options" .= assetReportRefreshRequestOptions
      ]


-- | Construct a value of type 'AssetReportRefreshRequest' (by applying it's required fields, if any)
mkAssetReportRefreshRequest
  :: Text -- ^ 'assetReportRefreshRequestAssetReportToken': The `asset_report_token` returned by the original call to `/asset_report/create`
  -> AssetReportRefreshRequest
mkAssetReportRefreshRequest assetReportRefreshRequestAssetReportToken =
  AssetReportRefreshRequest
  { assetReportRefreshRequestClientId = Nothing
  , assetReportRefreshRequestSecret = Nothing
  , assetReportRefreshRequestAssetReportToken
  , assetReportRefreshRequestDaysRequested = Nothing
  , assetReportRefreshRequestOptions = Nothing
  }

-- ** AssetReportRefreshRequestOptions
-- | AssetReportRefreshRequestOptions
-- An optional object to filter `/asset_report/refresh` results. If provided, cannot be `null`. If not specified, the `options` from the original call to `/asset_report/create` will be used.
data AssetReportRefreshRequestOptions = AssetReportRefreshRequestOptions
  { assetReportRefreshRequestOptionsClientReportId :: !(Maybe Text) -- ^ "client_report_id" - Client-generated identifier, which can be used by lenders to track loan applications.
  , assetReportRefreshRequestOptionsWebhook :: !(Maybe Text) -- ^ "webhook" - URL to which Plaid will send Assets webhooks, for example when the requested Asset Report is ready.
  , assetReportRefreshRequestOptionsUser :: !(Maybe AssetReportUser) -- ^ "user"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AssetReportRefreshRequestOptions
instance A.FromJSON AssetReportRefreshRequestOptions where
  parseJSON = A.withObject "AssetReportRefreshRequestOptions" $ \o ->
    AssetReportRefreshRequestOptions
      <$> (o .:? "client_report_id")
      <*> (o .:? "webhook")
      <*> (o .:? "user")

-- | ToJSON AssetReportRefreshRequestOptions
instance A.ToJSON AssetReportRefreshRequestOptions where
  toJSON AssetReportRefreshRequestOptions {..} =
   _omitNulls
      [ "client_report_id" .= assetReportRefreshRequestOptionsClientReportId
      , "webhook" .= assetReportRefreshRequestOptionsWebhook
      , "user" .= assetReportRefreshRequestOptionsUser
      ]


-- | Construct a value of type 'AssetReportRefreshRequestOptions' (by applying it's required fields, if any)
mkAssetReportRefreshRequestOptions
  :: AssetReportRefreshRequestOptions
mkAssetReportRefreshRequestOptions =
  AssetReportRefreshRequestOptions
  { assetReportRefreshRequestOptionsClientReportId = Nothing
  , assetReportRefreshRequestOptionsWebhook = Nothing
  , assetReportRefreshRequestOptionsUser = Nothing
  }

-- ** AssetReportRefreshResponse
-- | AssetReportRefreshResponse
-- AssetReportRefreshResponse defines the response schema for `/asset_report/refresh`
data AssetReportRefreshResponse = AssetReportRefreshResponse
  { assetReportRefreshResponseAssetReportId :: !(Text) -- ^ /Required/ "asset_report_id" - A unique ID identifying an Asset Report. Like all Plaid identifiers, this ID is case sensitive.
  , assetReportRefreshResponseAssetReportToken :: !(Text) -- ^ /Required/ "asset_report_token" - A token that can be provided to endpoints such as &#x60;/asset_report/get&#x60; or &#x60;/asset_report/pdf/get&#x60; to fetch or update an Asset Report.
  , assetReportRefreshResponseRequestId :: !(Text) -- ^ /Required/ "request_id" - A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AssetReportRefreshResponse
instance A.FromJSON AssetReportRefreshResponse where
  parseJSON = A.withObject "AssetReportRefreshResponse" $ \o ->
    AssetReportRefreshResponse
      <$> (o .:  "asset_report_id")
      <*> (o .:  "asset_report_token")
      <*> (o .:  "request_id")

-- | ToJSON AssetReportRefreshResponse
instance A.ToJSON AssetReportRefreshResponse where
  toJSON AssetReportRefreshResponse {..} =
   _omitNulls
      [ "asset_report_id" .= assetReportRefreshResponseAssetReportId
      , "asset_report_token" .= assetReportRefreshResponseAssetReportToken
      , "request_id" .= assetReportRefreshResponseRequestId
      ]


-- | Construct a value of type 'AssetReportRefreshResponse' (by applying it's required fields, if any)
mkAssetReportRefreshResponse
  :: Text -- ^ 'assetReportRefreshResponseAssetReportId': A unique ID identifying an Asset Report. Like all Plaid identifiers, this ID is case sensitive.
  -> Text -- ^ 'assetReportRefreshResponseAssetReportToken': A token that can be provided to endpoints such as `/asset_report/get` or `/asset_report/pdf/get` to fetch or update an Asset Report.
  -> Text -- ^ 'assetReportRefreshResponseRequestId': A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  -> AssetReportRefreshResponse
mkAssetReportRefreshResponse assetReportRefreshResponseAssetReportId assetReportRefreshResponseAssetReportToken assetReportRefreshResponseRequestId =
  AssetReportRefreshResponse
  { assetReportRefreshResponseAssetReportId
  , assetReportRefreshResponseAssetReportToken
  , assetReportRefreshResponseRequestId
  }

-- ** AssetReportRemoveRequest
-- | AssetReportRemoveRequest
-- AssetReportRemoveRequest defines the request schema for `/asset_report/remove`
data AssetReportRemoveRequest = AssetReportRemoveRequest
  { assetReportRemoveRequestClientId :: !(Maybe Text) -- ^ "client_id" - Your Plaid API &#x60;client_id&#x60;.
  , assetReportRemoveRequestSecret :: !(Maybe Text) -- ^ "secret" - Your Plaid API &#x60;secret&#x60;.
  , assetReportRemoveRequestAssetReportToken :: !(Text) -- ^ /Required/ "asset_report_token" - A token that can be provided to endpoints such as &#x60;/asset_report/get&#x60; or &#x60;/asset_report/pdf/get&#x60; to fetch or update an Asset Report.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AssetReportRemoveRequest
instance A.FromJSON AssetReportRemoveRequest where
  parseJSON = A.withObject "AssetReportRemoveRequest" $ \o ->
    AssetReportRemoveRequest
      <$> (o .:? "client_id")
      <*> (o .:? "secret")
      <*> (o .:  "asset_report_token")

-- | ToJSON AssetReportRemoveRequest
instance A.ToJSON AssetReportRemoveRequest where
  toJSON AssetReportRemoveRequest {..} =
   _omitNulls
      [ "client_id" .= assetReportRemoveRequestClientId
      , "secret" .= assetReportRemoveRequestSecret
      , "asset_report_token" .= assetReportRemoveRequestAssetReportToken
      ]


-- | Construct a value of type 'AssetReportRemoveRequest' (by applying it's required fields, if any)
mkAssetReportRemoveRequest
  :: Text -- ^ 'assetReportRemoveRequestAssetReportToken': A token that can be provided to endpoints such as `/asset_report/get` or `/asset_report/pdf/get` to fetch or update an Asset Report.
  -> AssetReportRemoveRequest
mkAssetReportRemoveRequest assetReportRemoveRequestAssetReportToken =
  AssetReportRemoveRequest
  { assetReportRemoveRequestClientId = Nothing
  , assetReportRemoveRequestSecret = Nothing
  , assetReportRemoveRequestAssetReportToken
  }

-- ** AssetReportRemoveResponse
-- | AssetReportRemoveResponse
-- AssetReportRemoveResponse defines the response schema for `/asset_report/remove`
data AssetReportRemoveResponse = AssetReportRemoveResponse
  { assetReportRemoveResponseRemoved :: !(Bool) -- ^ /Required/ "removed" - &#x60;true&#x60; if the Asset Report was successfully removed.
  , assetReportRemoveResponseRequestId :: !(Text) -- ^ /Required/ "request_id" - A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AssetReportRemoveResponse
instance A.FromJSON AssetReportRemoveResponse where
  parseJSON = A.withObject "AssetReportRemoveResponse" $ \o ->
    AssetReportRemoveResponse
      <$> (o .:  "removed")
      <*> (o .:  "request_id")

-- | ToJSON AssetReportRemoveResponse
instance A.ToJSON AssetReportRemoveResponse where
  toJSON AssetReportRemoveResponse {..} =
   _omitNulls
      [ "removed" .= assetReportRemoveResponseRemoved
      , "request_id" .= assetReportRemoveResponseRequestId
      ]


-- | Construct a value of type 'AssetReportRemoveResponse' (by applying it's required fields, if any)
mkAssetReportRemoveResponse
  :: Bool -- ^ 'assetReportRemoveResponseRemoved': `true` if the Asset Report was successfully removed.
  -> Text -- ^ 'assetReportRemoveResponseRequestId': A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  -> AssetReportRemoveResponse
mkAssetReportRemoveResponse assetReportRemoveResponseRemoved assetReportRemoveResponseRequestId =
  AssetReportRemoveResponse
  { assetReportRemoveResponseRemoved
  , assetReportRemoveResponseRequestId
  }

-- ** AssetReportTransaction
-- | AssetReportTransaction
-- AssetReportTransaction
-- 
data AssetReportTransaction = AssetReportTransaction
  { assetReportTransactionTransactionType :: !(Maybe E'TransactionType) -- ^ "transaction_type" - Please use the &#x60;payment_channel&#x60; field, &#x60;transaction_type&#x60; will be deprecated in the future.  &#x60;digital:&#x60; transactions that took place online.  &#x60;place:&#x60; transactions that were made at a physical location.  &#x60;special:&#x60; transactions that relate to banks, e.g. fees or deposits.  &#x60;unresolved:&#x60; transactions that do not fit into the other three types. 
  , assetReportTransactionTransactionId :: !(Text) -- ^ /Required/ "transaction_id" - The unique ID of the transaction. Like all Plaid identifiers, the &#x60;transaction_id&#x60; is case sensitive.
  , assetReportTransactionAccountOwner :: !(Maybe Text) -- ^ "account_owner" - The name of the account owner. This field is not typically populated and only relevant when dealing with sub-accounts.
  , assetReportTransactionPendingTransactionId :: !(Maybe Text) -- ^ "pending_transaction_id" - The ID of a posted transaction&#39;s associated pending transaction, where applicable.
  , assetReportTransactionPending :: !(Bool) -- ^ /Required/ "pending" - When &#x60;true&#x60;, identifies the transaction as pending or unsettled. Pending transaction details (name, type, amount, category ID) may change before they are settled.
  , assetReportTransactionPaymentChannel :: !(Maybe E'PaymentChannel) -- ^ "payment_channel" - The channel used to make a payment. &#x60;online:&#x60; transactions that took place online.  &#x60;in store:&#x60; transactions that were made at a physical location.  &#x60;other:&#x60; transactions that relate to banks, e.g. fees or deposits.  This field replaces the &#x60;transaction_type&#x60; field. 
  , assetReportTransactionPaymentMeta :: !(Maybe PaymentMeta) -- ^ "payment_meta"
  , assetReportTransactionName :: !(Maybe Text) -- ^ "name" - The merchant name or transaction description.  If the &#x60;transaction&#x60; object was returned by a Transactions endpoint such as &#x60;/transactions/get&#x60;, this field will always appear. If the &#x60;transaction&#x60; object was returned by an Assets endpoint such as &#x60;/asset_report/get/&#x60; or &#x60;/asset_report/pdf/get&#x60;, this field will only appear in an Asset Report with Insights.
  , assetReportTransactionMerchantName :: !(Maybe Text) -- ^ "merchant_name" - The merchant name, as extracted by Plaid from the &#x60;name&#x60; field.
  , assetReportTransactionLocation :: !(Maybe Location) -- ^ "location"
  , assetReportTransactionAuthorizedDate :: !(Maybe Text) -- ^ "authorized_date" - The date that the transaction was authorized. Dates are returned in an ISO 8601 format ( &#x60;YYYY-MM-DD&#x60; ).
  , assetReportTransactionAuthorizedDatetime :: !(Maybe Text) -- ^ "authorized_datetime" - Date and time when a transaction was authorized in ISO 8601 format ( &#x60;YYYY-MM-DDTHH:mm:ssZ&#x60; ).  This field is only populated for UK institutions. For institutions in other countries, will be &#x60;null&#x60;.
  , assetReportTransactionDate :: !(Text) -- ^ /Required/ "date" - For pending transactions, the date that the transaction occurred; for posted transactions, the date that the transaction posted. Both dates are returned in an ISO 8601 format ( &#x60;YYYY-MM-DD&#x60; ).
  , assetReportTransactionDatetime :: !(Maybe Text) -- ^ "datetime" - Date and time when a transaction was posted in ISO 8601 format ( &#x60;YYYY-MM-DDTHH:mm:ssZ&#x60; ).  This field is only populated for UK institutions. For institutions in other countries, will be &#x60;null&#x60;.
  , assetReportTransactionCategoryId :: !(Maybe Text) -- ^ "category_id" - The ID of the category to which this transaction belongs. See [Categories](https://plaid.com/docs/#category-overview).  If the &#x60;transaction&#x60; object was returned by an Assets endpoint such as &#x60;/asset_report/get/&#x60; or &#x60;/asset_report/pdf/get&#x60;, this field will only appear in an Asset Report with Insights.
  , assetReportTransactionCategory :: !(Maybe [Text]) -- ^ "category" - A hierarchical array of the categories to which this transaction belongs. See [Categories](https://plaid.com/docs/#category-overview).  If the &#x60;transaction&#x60; object was returned by an Assets endpoint such as &#x60;/asset_report/get/&#x60; or &#x60;/asset_report/pdf/get&#x60;, this field will only appear in an Asset Report with Insights.
  , assetReportTransactionUnofficialCurrencyCode :: !(Maybe Text) -- ^ "unofficial_currency_code" - The unofficial currency code associated with the transaction. Always &#x60;null&#x60; if &#x60;iso_currency_code&#x60; is non-&#x60;null&#x60;. Unofficial currency codes are used for currencies that do not have official ISO currency codes, such as cryptocurrencies and the currencies of certain countries.  See the [currency code schema](/docs/api/accounts#currency-code-schema) for a full listing of supported &#x60;iso_currency_code&#x60;s.
  , assetReportTransactionIsoCurrencyCode :: !(Maybe Text) -- ^ "iso_currency_code" - The ISO-4217 currency code of the transaction. Always &#x60;null&#x60; if &#x60;unofficial_currency_code&#x60; is non-null.
  , assetReportTransactionAmount :: !(Double) -- ^ /Required/ "amount" - The settled value of the transaction, denominated in the account&#39;s currency, as stated in &#x60;iso_currency_code&#x60; or &#x60;unofficial_currency_code&#x60;. Positive values when money moves out of the account; negative values when money moves in. For example, debit card purchases are positive; credit card payments, direct deposits, and refunds are negative.
  , assetReportTransactionAccountId :: !(Text) -- ^ /Required/ "account_id" - The ID of the account in which this transaction occurred.
  , assetReportTransactionTransactionCode :: !(Maybe TransactionCode) -- ^ "transaction_code"
  , assetReportTransactionDateTransacted :: !(Maybe Text) -- ^ "date_transacted" - The date on which the transaction took place, in IS0 8601 format.
  , assetReportTransactionOriginalDescription :: !(Text) -- ^ /Required/ "original_description" - The string returned by the financial institution to describe the transaction
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AssetReportTransaction
instance A.FromJSON AssetReportTransaction where
  parseJSON = A.withObject "AssetReportTransaction" $ \o ->
    AssetReportTransaction
      <$> (o .:? "transaction_type")
      <*> (o .:  "transaction_id")
      <*> (o .:? "account_owner")
      <*> (o .:? "pending_transaction_id")
      <*> (o .:  "pending")
      <*> (o .:? "payment_channel")
      <*> (o .:? "payment_meta")
      <*> (o .:? "name")
      <*> (o .:? "merchant_name")
      <*> (o .:? "location")
      <*> (o .:? "authorized_date")
      <*> (o .:? "authorized_datetime")
      <*> (o .:  "date")
      <*> (o .:? "datetime")
      <*> (o .:? "category_id")
      <*> (o .:? "category")
      <*> (o .:? "unofficial_currency_code")
      <*> (o .:? "iso_currency_code")
      <*> (o .:  "amount")
      <*> (o .:  "account_id")
      <*> (o .:? "transaction_code")
      <*> (o .:? "date_transacted")
      <*> (o .:  "original_description")

-- | ToJSON AssetReportTransaction
instance A.ToJSON AssetReportTransaction where
  toJSON AssetReportTransaction {..} =
   _omitNulls
      [ "transaction_type" .= assetReportTransactionTransactionType
      , "transaction_id" .= assetReportTransactionTransactionId
      , "account_owner" .= assetReportTransactionAccountOwner
      , "pending_transaction_id" .= assetReportTransactionPendingTransactionId
      , "pending" .= assetReportTransactionPending
      , "payment_channel" .= assetReportTransactionPaymentChannel
      , "payment_meta" .= assetReportTransactionPaymentMeta
      , "name" .= assetReportTransactionName
      , "merchant_name" .= assetReportTransactionMerchantName
      , "location" .= assetReportTransactionLocation
      , "authorized_date" .= assetReportTransactionAuthorizedDate
      , "authorized_datetime" .= assetReportTransactionAuthorizedDatetime
      , "date" .= assetReportTransactionDate
      , "datetime" .= assetReportTransactionDatetime
      , "category_id" .= assetReportTransactionCategoryId
      , "category" .= assetReportTransactionCategory
      , "unofficial_currency_code" .= assetReportTransactionUnofficialCurrencyCode
      , "iso_currency_code" .= assetReportTransactionIsoCurrencyCode
      , "amount" .= assetReportTransactionAmount
      , "account_id" .= assetReportTransactionAccountId
      , "transaction_code" .= assetReportTransactionTransactionCode
      , "date_transacted" .= assetReportTransactionDateTransacted
      , "original_description" .= assetReportTransactionOriginalDescription
      ]


-- | Construct a value of type 'AssetReportTransaction' (by applying it's required fields, if any)
mkAssetReportTransaction
  :: Text -- ^ 'assetReportTransactionTransactionId': The unique ID of the transaction. Like all Plaid identifiers, the `transaction_id` is case sensitive.
  -> Bool -- ^ 'assetReportTransactionPending': When `true`, identifies the transaction as pending or unsettled. Pending transaction details (name, type, amount, category ID) may change before they are settled.
  -> Text -- ^ 'assetReportTransactionDate': For pending transactions, the date that the transaction occurred; for posted transactions, the date that the transaction posted. Both dates are returned in an ISO 8601 format ( `YYYY-MM-DD` ).
  -> Double -- ^ 'assetReportTransactionAmount': The settled value of the transaction, denominated in the account's currency, as stated in `iso_currency_code` or `unofficial_currency_code`. Positive values when money moves out of the account; negative values when money moves in. For example, debit card purchases are positive; credit card payments, direct deposits, and refunds are negative.
  -> Text -- ^ 'assetReportTransactionAccountId': The ID of the account in which this transaction occurred.
  -> Text -- ^ 'assetReportTransactionOriginalDescription': The string returned by the financial institution to describe the transaction
  -> AssetReportTransaction
mkAssetReportTransaction assetReportTransactionTransactionId assetReportTransactionPending assetReportTransactionDate assetReportTransactionAmount assetReportTransactionAccountId assetReportTransactionOriginalDescription =
  AssetReportTransaction
  { assetReportTransactionTransactionType = Nothing
  , assetReportTransactionTransactionId
  , assetReportTransactionAccountOwner = Nothing
  , assetReportTransactionPendingTransactionId = Nothing
  , assetReportTransactionPending
  , assetReportTransactionPaymentChannel = Nothing
  , assetReportTransactionPaymentMeta = Nothing
  , assetReportTransactionName = Nothing
  , assetReportTransactionMerchantName = Nothing
  , assetReportTransactionLocation = Nothing
  , assetReportTransactionAuthorizedDate = Nothing
  , assetReportTransactionAuthorizedDatetime = Nothing
  , assetReportTransactionDate
  , assetReportTransactionDatetime = Nothing
  , assetReportTransactionCategoryId = Nothing
  , assetReportTransactionCategory = Nothing
  , assetReportTransactionUnofficialCurrencyCode = Nothing
  , assetReportTransactionIsoCurrencyCode = Nothing
  , assetReportTransactionAmount
  , assetReportTransactionAccountId
  , assetReportTransactionTransactionCode = Nothing
  , assetReportTransactionDateTransacted = Nothing
  , assetReportTransactionOriginalDescription
  }

-- ** AssetReportTransactionAllOf
-- | AssetReportTransactionAllOf
data AssetReportTransactionAllOf = AssetReportTransactionAllOf
  { assetReportTransactionAllOfDateTransacted :: !(Maybe Text) -- ^ "date_transacted" - The date on which the transaction took place, in IS0 8601 format.
  , assetReportTransactionAllOfOriginalDescription :: !(Text) -- ^ /Required/ "original_description" - The string returned by the financial institution to describe the transaction
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AssetReportTransactionAllOf
instance A.FromJSON AssetReportTransactionAllOf where
  parseJSON = A.withObject "AssetReportTransactionAllOf" $ \o ->
    AssetReportTransactionAllOf
      <$> (o .:? "date_transacted")
      <*> (o .:  "original_description")

-- | ToJSON AssetReportTransactionAllOf
instance A.ToJSON AssetReportTransactionAllOf where
  toJSON AssetReportTransactionAllOf {..} =
   _omitNulls
      [ "date_transacted" .= assetReportTransactionAllOfDateTransacted
      , "original_description" .= assetReportTransactionAllOfOriginalDescription
      ]


-- | Construct a value of type 'AssetReportTransactionAllOf' (by applying it's required fields, if any)
mkAssetReportTransactionAllOf
  :: Text -- ^ 'assetReportTransactionAllOfOriginalDescription': The string returned by the financial institution to describe the transaction
  -> AssetReportTransactionAllOf
mkAssetReportTransactionAllOf assetReportTransactionAllOfOriginalDescription =
  AssetReportTransactionAllOf
  { assetReportTransactionAllOfDateTransacted = Nothing
  , assetReportTransactionAllOfOriginalDescription
  }

-- ** AssetReportUser
-- | AssetReportUser
-- AssetReportUser
-- 
-- The user object allows you to provide additional information about the user to be appended to the Asset Report. All fields are optional. The `first_name`, `last_name`, and `ssn` fields are required if you would like the Report to be eligible for Fannie Mae’s Day 1 Certainty™ program.
data AssetReportUser = AssetReportUser
  { assetReportUserClientUserId :: !(Maybe Text) -- ^ "client_user_id" - An identifier you determine and submit for the user.
  , assetReportUserFirstName :: !(Maybe Text) -- ^ "first_name" - The user&#39;s first name. Required for the Fannie Mae Day 1 Certainty™ program.
  , assetReportUserMiddleName :: !(Maybe Text) -- ^ "middle_name" - The user&#39;s middle name
  , assetReportUserLastName :: !(Maybe Text) -- ^ "last_name" - The user&#39;s last name.  Required for the Fannie Mae Day 1 Certainty™ program.
  , assetReportUserSsn :: !(Maybe Text) -- ^ "ssn" - The user&#39;s Social Security Number. Required for the Fannie Mae Day 1 Certainty™ program.  Format: \&quot;ddd-dd-dddd\&quot;
  , assetReportUserPhoneNumber :: !(Maybe Text) -- ^ "phone_number" - The user&#39;s phone number, in E.164 format: +{countrycode}{number}. For example: \&quot;+14151234567\&quot;
  , assetReportUserEmail :: !(Maybe Text) -- ^ "email" - The user&#39;s email address.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AssetReportUser
instance A.FromJSON AssetReportUser where
  parseJSON = A.withObject "AssetReportUser" $ \o ->
    AssetReportUser
      <$> (o .:? "client_user_id")
      <*> (o .:? "first_name")
      <*> (o .:? "middle_name")
      <*> (o .:? "last_name")
      <*> (o .:? "ssn")
      <*> (o .:? "phone_number")
      <*> (o .:? "email")

-- | ToJSON AssetReportUser
instance A.ToJSON AssetReportUser where
  toJSON AssetReportUser {..} =
   _omitNulls
      [ "client_user_id" .= assetReportUserClientUserId
      , "first_name" .= assetReportUserFirstName
      , "middle_name" .= assetReportUserMiddleName
      , "last_name" .= assetReportUserLastName
      , "ssn" .= assetReportUserSsn
      , "phone_number" .= assetReportUserPhoneNumber
      , "email" .= assetReportUserEmail
      ]


-- | Construct a value of type 'AssetReportUser' (by applying it's required fields, if any)
mkAssetReportUser
  :: AssetReportUser
mkAssetReportUser =
  AssetReportUser
  { assetReportUserClientUserId = Nothing
  , assetReportUserFirstName = Nothing
  , assetReportUserMiddleName = Nothing
  , assetReportUserLastName = Nothing
  , assetReportUserSsn = Nothing
  , assetReportUserPhoneNumber = Nothing
  , assetReportUserEmail = Nothing
  }

-- ** AssetsErrorWebhook
-- | AssetsErrorWebhook
-- AssetsErrorWebhook
-- 
-- Fired when Asset Report generation has failed. The resulting `error` will have an `error_type` of `ASSET_REPORT_ERROR`.
data AssetsErrorWebhook = AssetsErrorWebhook
  { assetsErrorWebhookWebhookType :: !(Text) -- ^ /Required/ "webhook_type" - &#x60;ASSETS&#x60;
  , assetsErrorWebhookWebhookCode :: !(Text) -- ^ /Required/ "webhook_code" - &#x60;ERROR&#x60;
  , assetsErrorWebhookError :: !(Error) -- ^ /Required/ "error"
  , assetsErrorWebhookAssetReportId :: !(Text) -- ^ /Required/ "asset_report_id" - The ID associated with the Asset Report.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AssetsErrorWebhook
instance A.FromJSON AssetsErrorWebhook where
  parseJSON = A.withObject "AssetsErrorWebhook" $ \o ->
    AssetsErrorWebhook
      <$> (o .:  "webhook_type")
      <*> (o .:  "webhook_code")
      <*> (o .:  "error")
      <*> (o .:  "asset_report_id")

-- | ToJSON AssetsErrorWebhook
instance A.ToJSON AssetsErrorWebhook where
  toJSON AssetsErrorWebhook {..} =
   _omitNulls
      [ "webhook_type" .= assetsErrorWebhookWebhookType
      , "webhook_code" .= assetsErrorWebhookWebhookCode
      , "error" .= assetsErrorWebhookError
      , "asset_report_id" .= assetsErrorWebhookAssetReportId
      ]


-- | Construct a value of type 'AssetsErrorWebhook' (by applying it's required fields, if any)
mkAssetsErrorWebhook
  :: Text -- ^ 'assetsErrorWebhookWebhookType': `ASSETS`
  -> Text -- ^ 'assetsErrorWebhookWebhookCode': `ERROR`
  -> Error -- ^ 'assetsErrorWebhookError' 
  -> Text -- ^ 'assetsErrorWebhookAssetReportId': The ID associated with the Asset Report.
  -> AssetsErrorWebhook
mkAssetsErrorWebhook assetsErrorWebhookWebhookType assetsErrorWebhookWebhookCode assetsErrorWebhookError assetsErrorWebhookAssetReportId =
  AssetsErrorWebhook
  { assetsErrorWebhookWebhookType
  , assetsErrorWebhookWebhookCode
  , assetsErrorWebhookError
  , assetsErrorWebhookAssetReportId
  }

-- ** AssetsProductReadyWebhook
-- | AssetsProductReadyWebhook
-- AssetsProductReadyWebhook
-- 
-- Fired when the Asset Report has been generated and `/asset_report/get` is ready to be called.  If you attempt to retrieve an Asset Report before this webhook has fired, you’ll receive a response with the HTTP status code 400 and a Plaid error code of `PRODUCT_NOT_READY`.
data AssetsProductReadyWebhook = AssetsProductReadyWebhook
  { assetsProductReadyWebhookWebhookType :: !(Text) -- ^ /Required/ "webhook_type" - &#x60;ASSETS&#x60;
  , assetsProductReadyWebhookWebhookCode :: !(Text) -- ^ /Required/ "webhook_code" - &#x60;PRODUCT_READY&#x60;
  , assetsProductReadyWebhookAssetReportId :: !(Text) -- ^ /Required/ "asset_report_id" - The &#x60;asset_report_id&#x60; that can be provided to &#x60;/asset_report/get&#x60; to retrieve the Asset Report.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AssetsProductReadyWebhook
instance A.FromJSON AssetsProductReadyWebhook where
  parseJSON = A.withObject "AssetsProductReadyWebhook" $ \o ->
    AssetsProductReadyWebhook
      <$> (o .:  "webhook_type")
      <*> (o .:  "webhook_code")
      <*> (o .:  "asset_report_id")

-- | ToJSON AssetsProductReadyWebhook
instance A.ToJSON AssetsProductReadyWebhook where
  toJSON AssetsProductReadyWebhook {..} =
   _omitNulls
      [ "webhook_type" .= assetsProductReadyWebhookWebhookType
      , "webhook_code" .= assetsProductReadyWebhookWebhookCode
      , "asset_report_id" .= assetsProductReadyWebhookAssetReportId
      ]


-- | Construct a value of type 'AssetsProductReadyWebhook' (by applying it's required fields, if any)
mkAssetsProductReadyWebhook
  :: Text -- ^ 'assetsProductReadyWebhookWebhookType': `ASSETS`
  -> Text -- ^ 'assetsProductReadyWebhookWebhookCode': `PRODUCT_READY`
  -> Text -- ^ 'assetsProductReadyWebhookAssetReportId': The `asset_report_id` that can be provided to `/asset_report/get` to retrieve the Asset Report.
  -> AssetsProductReadyWebhook
mkAssetsProductReadyWebhook assetsProductReadyWebhookWebhookType assetsProductReadyWebhookWebhookCode assetsProductReadyWebhookAssetReportId =
  AssetsProductReadyWebhook
  { assetsProductReadyWebhookWebhookType
  , assetsProductReadyWebhookWebhookCode
  , assetsProductReadyWebhookAssetReportId
  }

-- ** AuthGetNumbers
-- | AuthGetNumbers
-- An object containing identifying numbers used for making electronic transfers to and from the `accounts`. The identifying number type (ACH, EFT, IBAN, or BACS) used will depend on the country of the account. An account may have more than one number type. If a particular identifying number type is not used by any `accounts` for which data has been requested, the array for that type will be empty.
data AuthGetNumbers = AuthGetNumbers
  { authGetNumbersAch :: !(Maybe [NumbersACH]) -- ^ "ach" - An array of ACH numbers identifying accounts.
  , authGetNumbersEft :: !(Maybe [NumbersEFT]) -- ^ "eft" - An array of EFT numbers identifying accounts.
  , authGetNumbersInternational :: !(Maybe [NumbersInternationals]) -- ^ "international" - An array of IBAN numbers identifying accounts.
  , authGetNumbersBacs :: !(Maybe [NumbersBACS]) -- ^ "bacs" - An array of BACS numbers identifying accounts.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AuthGetNumbers
instance A.FromJSON AuthGetNumbers where
  parseJSON = A.withObject "AuthGetNumbers" $ \o ->
    AuthGetNumbers
      <$> (o .:? "ach")
      <*> (o .:? "eft")
      <*> (o .:? "international")
      <*> (o .:? "bacs")

-- | ToJSON AuthGetNumbers
instance A.ToJSON AuthGetNumbers where
  toJSON AuthGetNumbers {..} =
   _omitNulls
      [ "ach" .= authGetNumbersAch
      , "eft" .= authGetNumbersEft
      , "international" .= authGetNumbersInternational
      , "bacs" .= authGetNumbersBacs
      ]


-- | Construct a value of type 'AuthGetNumbers' (by applying it's required fields, if any)
mkAuthGetNumbers
  :: AuthGetNumbers
mkAuthGetNumbers =
  AuthGetNumbers
  { authGetNumbersAch = Nothing
  , authGetNumbersEft = Nothing
  , authGetNumbersInternational = Nothing
  , authGetNumbersBacs = Nothing
  }

-- ** AuthGetRequest
-- | AuthGetRequest
-- AuthGetRequest defines the request schema for `/auth/get`
data AuthGetRequest = AuthGetRequest
  { authGetRequestClientId :: !(Maybe Text) -- ^ "client_id" - Your Plaid API &#x60;client_id&#x60;.
  , authGetRequestSecret :: !(Maybe Text) -- ^ "secret" - Your Plaid API &#x60;secret&#x60;.
  , authGetRequestAccessToken :: !(AccessToken) -- ^ /Required/ "access_token" - The access token associated with the Item data is being requested for.
  , authGetRequestOptions :: !(Maybe AuthGetRequestOptions) -- ^ "options"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AuthGetRequest
instance A.FromJSON AuthGetRequest where
  parseJSON = A.withObject "AuthGetRequest" $ \o ->
    AuthGetRequest
      <$> (o .:? "client_id")
      <*> (o .:? "secret")
      <*> (o .:  "access_token")
      <*> (o .:? "options")

-- | ToJSON AuthGetRequest
instance A.ToJSON AuthGetRequest where
  toJSON AuthGetRequest {..} =
   _omitNulls
      [ "client_id" .= authGetRequestClientId
      , "secret" .= authGetRequestSecret
      , "access_token" .= authGetRequestAccessToken
      , "options" .= authGetRequestOptions
      ]


-- | Construct a value of type 'AuthGetRequest' (by applying it's required fields, if any)
mkAuthGetRequest
  :: AccessToken -- ^ 'authGetRequestAccessToken': The access token associated with the Item data is being requested for.
  -> AuthGetRequest
mkAuthGetRequest authGetRequestAccessToken =
  AuthGetRequest
  { authGetRequestClientId = Nothing
  , authGetRequestSecret = Nothing
  , authGetRequestAccessToken
  , authGetRequestOptions = Nothing
  }

-- ** AuthGetRequestOptions
-- | AuthGetRequestOptions
-- An optional object to filter `/auth/get` results.
data AuthGetRequestOptions = AuthGetRequestOptions
  { authGetRequestOptionsAccountIds :: !(Maybe [Text]) -- ^ "account_ids" - A list of &#x60;account_ids&#x60; to retrieve for the Item. Note: An error will be returned if a provided &#x60;account_id&#x60; is not associated with the Item.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AuthGetRequestOptions
instance A.FromJSON AuthGetRequestOptions where
  parseJSON = A.withObject "AuthGetRequestOptions" $ \o ->
    AuthGetRequestOptions
      <$> (o .:? "account_ids")

-- | ToJSON AuthGetRequestOptions
instance A.ToJSON AuthGetRequestOptions where
  toJSON AuthGetRequestOptions {..} =
   _omitNulls
      [ "account_ids" .= authGetRequestOptionsAccountIds
      ]


-- | Construct a value of type 'AuthGetRequestOptions' (by applying it's required fields, if any)
mkAuthGetRequestOptions
  :: AuthGetRequestOptions
mkAuthGetRequestOptions =
  AuthGetRequestOptions
  { authGetRequestOptionsAccountIds = Nothing
  }

-- ** AuthGetResponse
-- | AuthGetResponse
-- AuthGetResponse defines the response schema for `/auth/get`
data AuthGetResponse = AuthGetResponse
  { authGetResponseAccounts :: !([AccountBase]) -- ^ /Required/ "accounts" - The &#x60;accounts&#x60; for which numbers are being retrieved.
  , authGetResponseNumbers :: !(AuthGetNumbers) -- ^ /Required/ "numbers"
  , authGetResponseItem :: !(Item) -- ^ /Required/ "item"
  , authGetResponseRequestId :: !(Text) -- ^ /Required/ "request_id" - A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AuthGetResponse
instance A.FromJSON AuthGetResponse where
  parseJSON = A.withObject "AuthGetResponse" $ \o ->
    AuthGetResponse
      <$> (o .:  "accounts")
      <*> (o .:  "numbers")
      <*> (o .:  "item")
      <*> (o .:  "request_id")

-- | ToJSON AuthGetResponse
instance A.ToJSON AuthGetResponse where
  toJSON AuthGetResponse {..} =
   _omitNulls
      [ "accounts" .= authGetResponseAccounts
      , "numbers" .= authGetResponseNumbers
      , "item" .= authGetResponseItem
      , "request_id" .= authGetResponseRequestId
      ]


-- | Construct a value of type 'AuthGetResponse' (by applying it's required fields, if any)
mkAuthGetResponse
  :: [AccountBase] -- ^ 'authGetResponseAccounts': The `accounts` for which numbers are being retrieved.
  -> AuthGetNumbers -- ^ 'authGetResponseNumbers' 
  -> Item -- ^ 'authGetResponseItem' 
  -> Text -- ^ 'authGetResponseRequestId': A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  -> AuthGetResponse
mkAuthGetResponse authGetResponseAccounts authGetResponseNumbers authGetResponseItem authGetResponseRequestId =
  AuthGetResponse
  { authGetResponseAccounts
  , authGetResponseNumbers
  , authGetResponseItem
  , authGetResponseRequestId
  }

-- ** AutomaticallyVerifiedWebhook
-- | AutomaticallyVerifiedWebhook
-- AutomaticallyVerifiedWebhook
-- 
-- Fired when an Item is verified via micro-deposits. We recommend communicating to your users when this event is received to notify them that their account is verified and ready for use.
data AutomaticallyVerifiedWebhook = AutomaticallyVerifiedWebhook
  { automaticallyVerifiedWebhookWebhookType :: !(Text) -- ^ /Required/ "webhook_type" - &#x60;AUTH&#x60;
  , automaticallyVerifiedWebhookWebhookCode :: !(Text) -- ^ /Required/ "webhook_code" - &#x60;AUTOMATICALLY_VERIFIED&#x60;
  , automaticallyVerifiedWebhookAccountId :: !(Text) -- ^ /Required/ "account_id" - The &#x60;account_id&#x60; of the account associated with the webhook
  , automaticallyVerifiedWebhookItemId :: !(ItemId) -- ^ /Required/ "item_id" - The &#x60;item_id&#x60; of the Item associated with this webhook, warning, or error
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AutomaticallyVerifiedWebhook
instance A.FromJSON AutomaticallyVerifiedWebhook where
  parseJSON = A.withObject "AutomaticallyVerifiedWebhook" $ \o ->
    AutomaticallyVerifiedWebhook
      <$> (o .:  "webhook_type")
      <*> (o .:  "webhook_code")
      <*> (o .:  "account_id")
      <*> (o .:  "item_id")

-- | ToJSON AutomaticallyVerifiedWebhook
instance A.ToJSON AutomaticallyVerifiedWebhook where
  toJSON AutomaticallyVerifiedWebhook {..} =
   _omitNulls
      [ "webhook_type" .= automaticallyVerifiedWebhookWebhookType
      , "webhook_code" .= automaticallyVerifiedWebhookWebhookCode
      , "account_id" .= automaticallyVerifiedWebhookAccountId
      , "item_id" .= automaticallyVerifiedWebhookItemId
      ]


-- | Construct a value of type 'AutomaticallyVerifiedWebhook' (by applying it's required fields, if any)
mkAutomaticallyVerifiedWebhook
  :: Text -- ^ 'automaticallyVerifiedWebhookWebhookType': `AUTH`
  -> Text -- ^ 'automaticallyVerifiedWebhookWebhookCode': `AUTOMATICALLY_VERIFIED`
  -> Text -- ^ 'automaticallyVerifiedWebhookAccountId': The `account_id` of the account associated with the webhook
  -> ItemId -- ^ 'automaticallyVerifiedWebhookItemId': The `item_id` of the Item associated with this webhook, warning, or error
  -> AutomaticallyVerifiedWebhook
mkAutomaticallyVerifiedWebhook automaticallyVerifiedWebhookWebhookType automaticallyVerifiedWebhookWebhookCode automaticallyVerifiedWebhookAccountId automaticallyVerifiedWebhookItemId =
  AutomaticallyVerifiedWebhook
  { automaticallyVerifiedWebhookWebhookType
  , automaticallyVerifiedWebhookWebhookCode
  , automaticallyVerifiedWebhookAccountId
  , automaticallyVerifiedWebhookItemId
  }

-- ** BankTransfer
-- | BankTransfer
-- BankTransfer
-- 
-- Represents a bank transfer within the Bank Transfers API.
data BankTransfer = BankTransfer
  { bankTransferId :: !(Text) -- ^ /Required/ "id" - Plaid’s unique identifier for a bank transfer.
  , bankTransferAchClass :: !(ACHClass) -- ^ /Required/ "ach_class"
  , bankTransferAccountId :: !(Text) -- ^ /Required/ "account_id" - The account ID that should be credited/debited for this bank transfer.
  , bankTransferType :: !(BankTransferType) -- ^ /Required/ "type"
  , bankTransferUser :: !(BankTransferUser) -- ^ /Required/ "user"
  , bankTransferAmount :: !(Text) -- ^ /Required/ "amount" - The amount of the transfer (decimal string with two digits of precision e.g. “10.00”).
  , bankTransferIsoCurrencyCode :: !(Text) -- ^ /Required/ "iso_currency_code" - The currency of the transfer amount, e.g. \&quot;USD\&quot;
  , bankTransferDescription :: !(Text) -- ^ /Required/ "description" - The description of the transfer.
  , bankTransferCreated :: !(Text) -- ^ /Required/ "created" - The datetime when this bank transfer was created. This will be of the form &#x60;2006-01-02T15:04:05Z&#x60;
  , bankTransferStatus :: !(BankTransferStatus) -- ^ /Required/ "status"
  , bankTransferNetwork :: !(BankTransferNetwork) -- ^ /Required/ "network"
  , bankTransferCancellable :: !(Bool) -- ^ /Required/ "cancellable" - When &#x60;true&#x60;, you can still cancel this bank transfer.
  , bankTransferFailureReason :: !(Maybe BankTransferFailure) -- ^ "failure_reason"
  , bankTransferCustomTag :: !(Maybe Text) -- ^ "custom_tag" - A string containing the custom tag provided by the client in the create request. Will be null if not provided.
  , bankTransferMetadata :: !((Map.Map String Text)) -- ^ /Required/ "metadata" - The Metadata object is a mapping of client-provided string fields to any string value. The following limitations apply: - The JSON values must be Strings (no nested JSON objects allowed) - Only ASCII characters may be used - Maximum of 50 key/value pairs - Maximum key length of 40 characters - Maximum value length of 500 characters 
  , bankTransferOriginationAccountId :: !(Text) -- ^ /Required/ "origination_account_id" - Plaid’s unique identifier for the origination account that was used for this transfer.
  , bankTransferDirection :: !(BankTransferDirection) -- ^ /Required/ "direction"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BankTransfer
instance A.FromJSON BankTransfer where
  parseJSON = A.withObject "BankTransfer" $ \o ->
    BankTransfer
      <$> (o .:  "id")
      <*> (o .:  "ach_class")
      <*> (o .:  "account_id")
      <*> (o .:  "type")
      <*> (o .:  "user")
      <*> (o .:  "amount")
      <*> (o .:  "iso_currency_code")
      <*> (o .:  "description")
      <*> (o .:  "created")
      <*> (o .:  "status")
      <*> (o .:  "network")
      <*> (o .:  "cancellable")
      <*> (o .:? "failure_reason")
      <*> (o .:? "custom_tag")
      <*> (o .:  "metadata")
      <*> (o .:  "origination_account_id")
      <*> (o .:  "direction")

-- | ToJSON BankTransfer
instance A.ToJSON BankTransfer where
  toJSON BankTransfer {..} =
   _omitNulls
      [ "id" .= bankTransferId
      , "ach_class" .= bankTransferAchClass
      , "account_id" .= bankTransferAccountId
      , "type" .= bankTransferType
      , "user" .= bankTransferUser
      , "amount" .= bankTransferAmount
      , "iso_currency_code" .= bankTransferIsoCurrencyCode
      , "description" .= bankTransferDescription
      , "created" .= bankTransferCreated
      , "status" .= bankTransferStatus
      , "network" .= bankTransferNetwork
      , "cancellable" .= bankTransferCancellable
      , "failure_reason" .= bankTransferFailureReason
      , "custom_tag" .= bankTransferCustomTag
      , "metadata" .= bankTransferMetadata
      , "origination_account_id" .= bankTransferOriginationAccountId
      , "direction" .= bankTransferDirection
      ]


-- | Construct a value of type 'BankTransfer' (by applying it's required fields, if any)
mkBankTransfer
  :: Text -- ^ 'bankTransferId': Plaid’s unique identifier for a bank transfer.
  -> ACHClass -- ^ 'bankTransferAchClass' 
  -> Text -- ^ 'bankTransferAccountId': The account ID that should be credited/debited for this bank transfer.
  -> BankTransferType -- ^ 'bankTransferType' 
  -> BankTransferUser -- ^ 'bankTransferUser' 
  -> Text -- ^ 'bankTransferAmount': The amount of the transfer (decimal string with two digits of precision e.g. “10.00”).
  -> Text -- ^ 'bankTransferIsoCurrencyCode': The currency of the transfer amount, e.g. \"USD\"
  -> Text -- ^ 'bankTransferDescription': The description of the transfer.
  -> Text -- ^ 'bankTransferCreated': The datetime when this bank transfer was created. This will be of the form `2006-01-02T15:04:05Z`
  -> BankTransferStatus -- ^ 'bankTransferStatus' 
  -> BankTransferNetwork -- ^ 'bankTransferNetwork' 
  -> Bool -- ^ 'bankTransferCancellable': When `true`, you can still cancel this bank transfer.
  -> (Map.Map String Text) -- ^ 'bankTransferMetadata': The Metadata object is a mapping of client-provided string fields to any string value. The following limitations apply: - The JSON values must be Strings (no nested JSON objects allowed) - Only ASCII characters may be used - Maximum of 50 key/value pairs - Maximum key length of 40 characters - Maximum value length of 500 characters 
  -> Text -- ^ 'bankTransferOriginationAccountId': Plaid’s unique identifier for the origination account that was used for this transfer.
  -> BankTransferDirection -- ^ 'bankTransferDirection' 
  -> BankTransfer
mkBankTransfer bankTransferId bankTransferAchClass bankTransferAccountId bankTransferType bankTransferUser bankTransferAmount bankTransferIsoCurrencyCode bankTransferDescription bankTransferCreated bankTransferStatus bankTransferNetwork bankTransferCancellable bankTransferMetadata bankTransferOriginationAccountId bankTransferDirection =
  BankTransfer
  { bankTransferId
  , bankTransferAchClass
  , bankTransferAccountId
  , bankTransferType
  , bankTransferUser
  , bankTransferAmount
  , bankTransferIsoCurrencyCode
  , bankTransferDescription
  , bankTransferCreated
  , bankTransferStatus
  , bankTransferNetwork
  , bankTransferCancellable
  , bankTransferFailureReason = Nothing
  , bankTransferCustomTag = Nothing
  , bankTransferMetadata
  , bankTransferOriginationAccountId
  , bankTransferDirection
  }

-- ** BankTransferBalance
-- | BankTransferBalance
-- BankTransferBalance
-- 
data BankTransferBalance = BankTransferBalance
  { bankTransferBalanceAvailable :: !(Text) -- ^ /Required/ "available" - The total available balance - the sum of all successful debit transfer amounts minus all credit transfer amounts.
  , bankTransferBalanceTransactable :: !(Text) -- ^ /Required/ "transactable" - The transactable balance shows the amount in your account that you are able to use for transfers, and is essentially your available balance minus your minimum balance.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BankTransferBalance
instance A.FromJSON BankTransferBalance where
  parseJSON = A.withObject "BankTransferBalance" $ \o ->
    BankTransferBalance
      <$> (o .:  "available")
      <*> (o .:  "transactable")

-- | ToJSON BankTransferBalance
instance A.ToJSON BankTransferBalance where
  toJSON BankTransferBalance {..} =
   _omitNulls
      [ "available" .= bankTransferBalanceAvailable
      , "transactable" .= bankTransferBalanceTransactable
      ]


-- | Construct a value of type 'BankTransferBalance' (by applying it's required fields, if any)
mkBankTransferBalance
  :: Text -- ^ 'bankTransferBalanceAvailable': The total available balance - the sum of all successful debit transfer amounts minus all credit transfer amounts.
  -> Text -- ^ 'bankTransferBalanceTransactable': The transactable balance shows the amount in your account that you are able to use for transfers, and is essentially your available balance minus your minimum balance.
  -> BankTransferBalance
mkBankTransferBalance bankTransferBalanceAvailable bankTransferBalanceTransactable =
  BankTransferBalance
  { bankTransferBalanceAvailable
  , bankTransferBalanceTransactable
  }

-- ** BankTransferBalanceGetRequest
-- | BankTransferBalanceGetRequest
-- BankTransferBalanceGetRequest
-- 
-- BankTransferBalanceGetRequest defines the request schema for `/bank_transfer/balance/get`
data BankTransferBalanceGetRequest = BankTransferBalanceGetRequest
  { bankTransferBalanceGetRequestClientId :: !(Maybe Text) -- ^ "client_id" - Your Plaid API &#x60;client_id&#x60;.
  , bankTransferBalanceGetRequestSecret :: !(Maybe Text) -- ^ "secret" - Your Plaid API &#x60;secret&#x60;.
  , bankTransferBalanceGetRequestOriginationAccountId :: !(Maybe Text) -- ^ "origination_account_id" - If multiple origination accounts are available, &#x60;origination_account_id&#x60; must be used to specify the account for which balance will be returned.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BankTransferBalanceGetRequest
instance A.FromJSON BankTransferBalanceGetRequest where
  parseJSON = A.withObject "BankTransferBalanceGetRequest" $ \o ->
    BankTransferBalanceGetRequest
      <$> (o .:? "client_id")
      <*> (o .:? "secret")
      <*> (o .:? "origination_account_id")

-- | ToJSON BankTransferBalanceGetRequest
instance A.ToJSON BankTransferBalanceGetRequest where
  toJSON BankTransferBalanceGetRequest {..} =
   _omitNulls
      [ "client_id" .= bankTransferBalanceGetRequestClientId
      , "secret" .= bankTransferBalanceGetRequestSecret
      , "origination_account_id" .= bankTransferBalanceGetRequestOriginationAccountId
      ]


-- | Construct a value of type 'BankTransferBalanceGetRequest' (by applying it's required fields, if any)
mkBankTransferBalanceGetRequest
  :: BankTransferBalanceGetRequest
mkBankTransferBalanceGetRequest =
  BankTransferBalanceGetRequest
  { bankTransferBalanceGetRequestClientId = Nothing
  , bankTransferBalanceGetRequestSecret = Nothing
  , bankTransferBalanceGetRequestOriginationAccountId = Nothing
  }

-- ** BankTransferBalanceGetResponse
-- | BankTransferBalanceGetResponse
-- BankTransferBalanceGetResponse
-- 
-- BankTransferBalanceGetResponse defines the response schema for `/bank_transfer/balance/get`
data BankTransferBalanceGetResponse = BankTransferBalanceGetResponse
  { bankTransferBalanceGetResponseBalance :: !(BankTransferBalance) -- ^ /Required/ "balance"
  , bankTransferBalanceGetResponseOriginationAccountId :: !(Text) -- ^ /Required/ "origination_account_id" - The ID of the origination account that this balance belongs to.
  , bankTransferBalanceGetResponseRequestId :: !(Text) -- ^ /Required/ "request_id" - A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BankTransferBalanceGetResponse
instance A.FromJSON BankTransferBalanceGetResponse where
  parseJSON = A.withObject "BankTransferBalanceGetResponse" $ \o ->
    BankTransferBalanceGetResponse
      <$> (o .:  "balance")
      <*> (o .:  "origination_account_id")
      <*> (o .:  "request_id")

-- | ToJSON BankTransferBalanceGetResponse
instance A.ToJSON BankTransferBalanceGetResponse where
  toJSON BankTransferBalanceGetResponse {..} =
   _omitNulls
      [ "balance" .= bankTransferBalanceGetResponseBalance
      , "origination_account_id" .= bankTransferBalanceGetResponseOriginationAccountId
      , "request_id" .= bankTransferBalanceGetResponseRequestId
      ]


-- | Construct a value of type 'BankTransferBalanceGetResponse' (by applying it's required fields, if any)
mkBankTransferBalanceGetResponse
  :: BankTransferBalance -- ^ 'bankTransferBalanceGetResponseBalance' 
  -> Text -- ^ 'bankTransferBalanceGetResponseOriginationAccountId': The ID of the origination account that this balance belongs to.
  -> Text -- ^ 'bankTransferBalanceGetResponseRequestId': A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  -> BankTransferBalanceGetResponse
mkBankTransferBalanceGetResponse bankTransferBalanceGetResponseBalance bankTransferBalanceGetResponseOriginationAccountId bankTransferBalanceGetResponseRequestId =
  BankTransferBalanceGetResponse
  { bankTransferBalanceGetResponseBalance
  , bankTransferBalanceGetResponseOriginationAccountId
  , bankTransferBalanceGetResponseRequestId
  }

-- ** BankTransferCancelRequest
-- | BankTransferCancelRequest
-- BankTransferCancelRequest
-- 
-- BankTransferCancelRequest defines the request schema for `/bank_transfer/cancel`
data BankTransferCancelRequest = BankTransferCancelRequest
  { bankTransferCancelRequestClientId :: !(Maybe Text) -- ^ "client_id" - Your Plaid API &#x60;client_id&#x60;.
  , bankTransferCancelRequestSecret :: !(Maybe Text) -- ^ "secret" - Your Plaid API &#x60;secret&#x60;.
  , bankTransferCancelRequestBankTransferId :: !(Text) -- ^ /Required/ "bank_transfer_id" - Plaid’s unique identifier for a bank transfer.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BankTransferCancelRequest
instance A.FromJSON BankTransferCancelRequest where
  parseJSON = A.withObject "BankTransferCancelRequest" $ \o ->
    BankTransferCancelRequest
      <$> (o .:? "client_id")
      <*> (o .:? "secret")
      <*> (o .:  "bank_transfer_id")

-- | ToJSON BankTransferCancelRequest
instance A.ToJSON BankTransferCancelRequest where
  toJSON BankTransferCancelRequest {..} =
   _omitNulls
      [ "client_id" .= bankTransferCancelRequestClientId
      , "secret" .= bankTransferCancelRequestSecret
      , "bank_transfer_id" .= bankTransferCancelRequestBankTransferId
      ]


-- | Construct a value of type 'BankTransferCancelRequest' (by applying it's required fields, if any)
mkBankTransferCancelRequest
  :: Text -- ^ 'bankTransferCancelRequestBankTransferId': Plaid’s unique identifier for a bank transfer.
  -> BankTransferCancelRequest
mkBankTransferCancelRequest bankTransferCancelRequestBankTransferId =
  BankTransferCancelRequest
  { bankTransferCancelRequestClientId = Nothing
  , bankTransferCancelRequestSecret = Nothing
  , bankTransferCancelRequestBankTransferId
  }

-- ** BankTransferCancelResponse
-- | BankTransferCancelResponse
-- BankTransferCancelResponse
-- 
-- BankTransferCancelResponse defines the response schema for `/bank_transfer/cancel`
data BankTransferCancelResponse = BankTransferCancelResponse
  { bankTransferCancelResponseRequestId :: !(Text) -- ^ /Required/ "request_id" - A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BankTransferCancelResponse
instance A.FromJSON BankTransferCancelResponse where
  parseJSON = A.withObject "BankTransferCancelResponse" $ \o ->
    BankTransferCancelResponse
      <$> (o .:  "request_id")

-- | ToJSON BankTransferCancelResponse
instance A.ToJSON BankTransferCancelResponse where
  toJSON BankTransferCancelResponse {..} =
   _omitNulls
      [ "request_id" .= bankTransferCancelResponseRequestId
      ]


-- | Construct a value of type 'BankTransferCancelResponse' (by applying it's required fields, if any)
mkBankTransferCancelResponse
  :: Text -- ^ 'bankTransferCancelResponseRequestId': A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  -> BankTransferCancelResponse
mkBankTransferCancelResponse bankTransferCancelResponseRequestId =
  BankTransferCancelResponse
  { bankTransferCancelResponseRequestId
  }

-- ** BankTransferCreateRequest
-- | BankTransferCreateRequest
-- BankTransferCreateRequest
-- 
-- BankTransferCreateRequest defines the request schema for `/bank_transfer/create`
data BankTransferCreateRequest = BankTransferCreateRequest
  { bankTransferCreateRequestClientId :: !(Maybe Text) -- ^ "client_id" - Your Plaid API &#x60;client_id&#x60;.
  , bankTransferCreateRequestSecret :: !(Maybe Text) -- ^ "secret" - Your Plaid API &#x60;secret&#x60;.
  , bankTransferCreateRequestIdempotencyKey :: !(Text) -- ^ /Required/ "idempotency_key" - A random key provided by the client, per unique bank transfer. Maximum of 50 characters.  The API supports idempotency for safely retrying requests without accidentally performing the same operation twice. For example, if a request to create a bank transfer fails due to a network connection error, you can retry the request with the same idempotency key to guarantee that only a single bank transfer is created.
  , bankTransferCreateRequestAccessToken :: !(AccessToken) -- ^ /Required/ "access_token" - The Plaid &#x60;access_token&#x60; for the account that will be debited or credited.
  , bankTransferCreateRequestAccountId :: !(Text) -- ^ /Required/ "account_id" - The Plaid &#x60;account_id&#x60; for the account that will be debited or credited.
  , bankTransferCreateRequestType :: !(BankTransferType) -- ^ /Required/ "type"
  , bankTransferCreateRequestNetwork :: !(BankTransferNetwork) -- ^ /Required/ "network"
  , bankTransferCreateRequestAmount :: !(Text) -- ^ /Required/ "amount" - The transfer amount (decimal string with two digits of precision e.g. \&quot;10.00\&quot;).
  , bankTransferCreateRequestIsoCurrencyCode :: !(Text) -- ^ /Required/ "iso_currency_code" - The currency of the transfer amount – should be set to \&quot;USD\&quot;.
  , bankTransferCreateRequestDescription :: !(Text) -- ^ /Required/ "description" - The transfer description. Maximum of 10 characters.
  , bankTransferCreateRequestAchClass :: !(Maybe ACHClass) -- ^ "ach_class"
  , bankTransferCreateRequestUser :: !(BankTransferUser) -- ^ /Required/ "user"
  , bankTransferCreateRequestCustomTag :: !(Maybe Text) -- ^ "custom_tag" - An arbitrary string provided by the client for storage with the bank transfer. Will be returned in all &#x60;BankTransfer&#x60; objects. May be up to 100 characters.
  , bankTransferCreateRequestMetadata :: !(Maybe (Map.Map String Text)) -- ^ "metadata" - The Metadata object is a mapping of client-provided string fields to any string value. The following limitations apply: - The JSON values must be Strings (no nested JSON objects allowed) - Only ASCII characters may be used - Maximum of 50 key/value pairs - Maximum key length of 40 characters - Maximum value length of 500 characters 
  , bankTransferCreateRequestOriginationAccountId :: !(Maybe Text) -- ^ "origination_account_id" - Plaid’s unique identifier for the origination account for this transfer. If you have more than one origination account, this value must be specified.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BankTransferCreateRequest
instance A.FromJSON BankTransferCreateRequest where
  parseJSON = A.withObject "BankTransferCreateRequest" $ \o ->
    BankTransferCreateRequest
      <$> (o .:? "client_id")
      <*> (o .:? "secret")
      <*> (o .:  "idempotency_key")
      <*> (o .:  "access_token")
      <*> (o .:  "account_id")
      <*> (o .:  "type")
      <*> (o .:  "network")
      <*> (o .:  "amount")
      <*> (o .:  "iso_currency_code")
      <*> (o .:  "description")
      <*> (o .:? "ach_class")
      <*> (o .:  "user")
      <*> (o .:? "custom_tag")
      <*> (o .:? "metadata")
      <*> (o .:? "origination_account_id")

-- | ToJSON BankTransferCreateRequest
instance A.ToJSON BankTransferCreateRequest where
  toJSON BankTransferCreateRequest {..} =
   _omitNulls
      [ "client_id" .= bankTransferCreateRequestClientId
      , "secret" .= bankTransferCreateRequestSecret
      , "idempotency_key" .= bankTransferCreateRequestIdempotencyKey
      , "access_token" .= bankTransferCreateRequestAccessToken
      , "account_id" .= bankTransferCreateRequestAccountId
      , "type" .= bankTransferCreateRequestType
      , "network" .= bankTransferCreateRequestNetwork
      , "amount" .= bankTransferCreateRequestAmount
      , "iso_currency_code" .= bankTransferCreateRequestIsoCurrencyCode
      , "description" .= bankTransferCreateRequestDescription
      , "ach_class" .= bankTransferCreateRequestAchClass
      , "user" .= bankTransferCreateRequestUser
      , "custom_tag" .= bankTransferCreateRequestCustomTag
      , "metadata" .= bankTransferCreateRequestMetadata
      , "origination_account_id" .= bankTransferCreateRequestOriginationAccountId
      ]


-- | Construct a value of type 'BankTransferCreateRequest' (by applying it's required fields, if any)
mkBankTransferCreateRequest
  :: Text -- ^ 'bankTransferCreateRequestIdempotencyKey': A random key provided by the client, per unique bank transfer. Maximum of 50 characters.  The API supports idempotency for safely retrying requests without accidentally performing the same operation twice. For example, if a request to create a bank transfer fails due to a network connection error, you can retry the request with the same idempotency key to guarantee that only a single bank transfer is created.
  -> AccessToken -- ^ 'bankTransferCreateRequestAccessToken': The Plaid `access_token` for the account that will be debited or credited.
  -> Text -- ^ 'bankTransferCreateRequestAccountId': The Plaid `account_id` for the account that will be debited or credited.
  -> BankTransferType -- ^ 'bankTransferCreateRequestType' 
  -> BankTransferNetwork -- ^ 'bankTransferCreateRequestNetwork' 
  -> Text -- ^ 'bankTransferCreateRequestAmount': The transfer amount (decimal string with two digits of precision e.g. \"10.00\").
  -> Text -- ^ 'bankTransferCreateRequestIsoCurrencyCode': The currency of the transfer amount – should be set to \"USD\".
  -> Text -- ^ 'bankTransferCreateRequestDescription': The transfer description. Maximum of 10 characters.
  -> BankTransferUser -- ^ 'bankTransferCreateRequestUser' 
  -> BankTransferCreateRequest
mkBankTransferCreateRequest bankTransferCreateRequestIdempotencyKey bankTransferCreateRequestAccessToken bankTransferCreateRequestAccountId bankTransferCreateRequestType bankTransferCreateRequestNetwork bankTransferCreateRequestAmount bankTransferCreateRequestIsoCurrencyCode bankTransferCreateRequestDescription bankTransferCreateRequestUser =
  BankTransferCreateRequest
  { bankTransferCreateRequestClientId = Nothing
  , bankTransferCreateRequestSecret = Nothing
  , bankTransferCreateRequestIdempotencyKey
  , bankTransferCreateRequestAccessToken
  , bankTransferCreateRequestAccountId
  , bankTransferCreateRequestType
  , bankTransferCreateRequestNetwork
  , bankTransferCreateRequestAmount
  , bankTransferCreateRequestIsoCurrencyCode
  , bankTransferCreateRequestDescription
  , bankTransferCreateRequestAchClass = Nothing
  , bankTransferCreateRequestUser
  , bankTransferCreateRequestCustomTag = Nothing
  , bankTransferCreateRequestMetadata = Nothing
  , bankTransferCreateRequestOriginationAccountId = Nothing
  }

-- ** BankTransferCreateResponse
-- | BankTransferCreateResponse
-- BankTransferCreateResponse
-- 
-- BankTransferCreateResponse defines the response schema for `/bank_transfer/create`
data BankTransferCreateResponse = BankTransferCreateResponse
  { bankTransferCreateResponseBankTransfer :: !(BankTransfer) -- ^ /Required/ "bank_transfer"
  , bankTransferCreateResponseRequestId :: !(Text) -- ^ /Required/ "request_id" - A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BankTransferCreateResponse
instance A.FromJSON BankTransferCreateResponse where
  parseJSON = A.withObject "BankTransferCreateResponse" $ \o ->
    BankTransferCreateResponse
      <$> (o .:  "bank_transfer")
      <*> (o .:  "request_id")

-- | ToJSON BankTransferCreateResponse
instance A.ToJSON BankTransferCreateResponse where
  toJSON BankTransferCreateResponse {..} =
   _omitNulls
      [ "bank_transfer" .= bankTransferCreateResponseBankTransfer
      , "request_id" .= bankTransferCreateResponseRequestId
      ]


-- | Construct a value of type 'BankTransferCreateResponse' (by applying it's required fields, if any)
mkBankTransferCreateResponse
  :: BankTransfer -- ^ 'bankTransferCreateResponseBankTransfer' 
  -> Text -- ^ 'bankTransferCreateResponseRequestId': A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  -> BankTransferCreateResponse
mkBankTransferCreateResponse bankTransferCreateResponseBankTransfer bankTransferCreateResponseRequestId =
  BankTransferCreateResponse
  { bankTransferCreateResponseBankTransfer
  , bankTransferCreateResponseRequestId
  }

-- ** BankTransferEvent
-- | BankTransferEvent
-- BankTransferEvent
-- 
-- Represents an event in the Bank Transfers API.
data BankTransferEvent = BankTransferEvent
  { bankTransferEventEventId :: !(Int) -- ^ /Required/ "event_id" - Plaid’s unique identifier for this event. IDs are sequential unsigned 64-bit integers.
  , bankTransferEventTimestamp :: !(Text) -- ^ /Required/ "timestamp" - The datetime when this event occurred. This will be of the form &#x60;2006-01-02T15:04:05Z&#x60;.
  , bankTransferEventEventType :: !(BankTransferEventType) -- ^ /Required/ "event_type"
  , bankTransferEventAccountId :: !(Text) -- ^ /Required/ "account_id" - The account ID associated with the bank transfer.
  , bankTransferEventBankTransferId :: !(Text) -- ^ /Required/ "bank_transfer_id" - Plaid’s unique identifier for a bank transfer.
  , bankTransferEventOriginationAccountId :: !(Maybe Text) -- ^ "origination_account_id" - The ID of the origination account that this balance belongs to.
  , bankTransferEventBankTransferType :: !(BankTransferType) -- ^ /Required/ "bank_transfer_type"
  , bankTransferEventBankTransferAmount :: !(Text) -- ^ /Required/ "bank_transfer_amount" - The bank transfer amount.
  , bankTransferEventBankTransferIsoCurrencyCode :: !(Text) -- ^ /Required/ "bank_transfer_iso_currency_code" - The currency of the bank transfer amount.
  , bankTransferEventFailureReason :: !(BankTransferFailure) -- ^ /Required/ "failure_reason"
  , bankTransferEventDirection :: !(BankTransferDirection) -- ^ /Required/ "direction"
  , bankTransferEventReceiverDetails :: !(BankTransferReceiverDetails) -- ^ /Required/ "receiver_details"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BankTransferEvent
instance A.FromJSON BankTransferEvent where
  parseJSON = A.withObject "BankTransferEvent" $ \o ->
    BankTransferEvent
      <$> (o .:  "event_id")
      <*> (o .:  "timestamp")
      <*> (o .:  "event_type")
      <*> (o .:  "account_id")
      <*> (o .:  "bank_transfer_id")
      <*> (o .:? "origination_account_id")
      <*> (o .:  "bank_transfer_type")
      <*> (o .:  "bank_transfer_amount")
      <*> (o .:  "bank_transfer_iso_currency_code")
      <*> (o .:  "failure_reason")
      <*> (o .:  "direction")
      <*> (o .:  "receiver_details")

-- | ToJSON BankTransferEvent
instance A.ToJSON BankTransferEvent where
  toJSON BankTransferEvent {..} =
   _omitNulls
      [ "event_id" .= bankTransferEventEventId
      , "timestamp" .= bankTransferEventTimestamp
      , "event_type" .= bankTransferEventEventType
      , "account_id" .= bankTransferEventAccountId
      , "bank_transfer_id" .= bankTransferEventBankTransferId
      , "origination_account_id" .= bankTransferEventOriginationAccountId
      , "bank_transfer_type" .= bankTransferEventBankTransferType
      , "bank_transfer_amount" .= bankTransferEventBankTransferAmount
      , "bank_transfer_iso_currency_code" .= bankTransferEventBankTransferIsoCurrencyCode
      , "failure_reason" .= bankTransferEventFailureReason
      , "direction" .= bankTransferEventDirection
      , "receiver_details" .= bankTransferEventReceiverDetails
      ]


-- | Construct a value of type 'BankTransferEvent' (by applying it's required fields, if any)
mkBankTransferEvent
  :: Int -- ^ 'bankTransferEventEventId': Plaid’s unique identifier for this event. IDs are sequential unsigned 64-bit integers.
  -> Text -- ^ 'bankTransferEventTimestamp': The datetime when this event occurred. This will be of the form `2006-01-02T15:04:05Z`.
  -> BankTransferEventType -- ^ 'bankTransferEventEventType' 
  -> Text -- ^ 'bankTransferEventAccountId': The account ID associated with the bank transfer.
  -> Text -- ^ 'bankTransferEventBankTransferId': Plaid’s unique identifier for a bank transfer.
  -> BankTransferType -- ^ 'bankTransferEventBankTransferType' 
  -> Text -- ^ 'bankTransferEventBankTransferAmount': The bank transfer amount.
  -> Text -- ^ 'bankTransferEventBankTransferIsoCurrencyCode': The currency of the bank transfer amount.
  -> BankTransferFailure -- ^ 'bankTransferEventFailureReason' 
  -> BankTransferDirection -- ^ 'bankTransferEventDirection' 
  -> BankTransferReceiverDetails -- ^ 'bankTransferEventReceiverDetails' 
  -> BankTransferEvent
mkBankTransferEvent bankTransferEventEventId bankTransferEventTimestamp bankTransferEventEventType bankTransferEventAccountId bankTransferEventBankTransferId bankTransferEventBankTransferType bankTransferEventBankTransferAmount bankTransferEventBankTransferIsoCurrencyCode bankTransferEventFailureReason bankTransferEventDirection bankTransferEventReceiverDetails =
  BankTransferEvent
  { bankTransferEventEventId
  , bankTransferEventTimestamp
  , bankTransferEventEventType
  , bankTransferEventAccountId
  , bankTransferEventBankTransferId
  , bankTransferEventOriginationAccountId = Nothing
  , bankTransferEventBankTransferType
  , bankTransferEventBankTransferAmount
  , bankTransferEventBankTransferIsoCurrencyCode
  , bankTransferEventFailureReason
  , bankTransferEventDirection
  , bankTransferEventReceiverDetails
  }

-- ** BankTransferEventListRequest
-- | BankTransferEventListRequest
-- BankTransferEventListRequest
-- 
-- BankTransferEventListRequest defines the request schema for `/bank_transfer/event/list`
data BankTransferEventListRequest = BankTransferEventListRequest
  { bankTransferEventListRequestClientId :: !(Maybe Text) -- ^ "client_id" - Your Plaid API &#x60;client_id&#x60;.
  , bankTransferEventListRequestSecret :: !(Maybe Text) -- ^ "secret" - Your Plaid API &#x60;secret&#x60;.
  , bankTransferEventListRequestStartDate :: !(Maybe DateTime) -- ^ "start_date" - The start datetime of bank transfers to list. This should be in RFC 3339 format (i.e. &#x60;2019-12-06T22:35:49Z&#x60;)
  , bankTransferEventListRequestEndDate :: !(Maybe DateTime) -- ^ "end_date" - The end datetime of bank transfers to list. This should be in RFC 3339 format (i.e. &#x60;2019-12-06T22:35:49Z&#x60;)
  , bankTransferEventListRequestBankTransferId :: !(Maybe Text) -- ^ "bank_transfer_id" - Plaid’s unique identifier for a bank transfer.
  , bankTransferEventListRequestAccountId :: !(Maybe Text) -- ^ "account_id" - The account ID to get events for all transactions to/from an account.
  , bankTransferEventListRequestBankTransferType :: !(Maybe E'BankTransferType) -- ^ "bank_transfer_type" - The type of bank transfer. This will be either &#x60;debit&#x60; or &#x60;credit&#x60;.  A &#x60;debit&#x60; indicates a transfer of money into your origination account; a &#x60;credit&#x60; indicates a transfer of money out of your origination account.
  , bankTransferEventListRequestEventTypes :: !(Maybe [BankTransferEventType]) -- ^ "event_types" - Filter events by event type.
  , bankTransferEventListRequestCount :: !(Maybe Int) -- ^ "count" - The maximum number of bank transfer events to return. If the number of events matching the above parameters is greater than &#x60;count&#x60;, the most recent events will be returned.
  , bankTransferEventListRequestOffset :: !(Maybe Int) -- ^ "offset" - The offset into the list of bank transfer events. When &#x60;count&#x60;&#x3D;25 and &#x60;offset&#x60;&#x3D;0, the first 25 events will be returned. When &#x60;count&#x60;&#x3D;25 and &#x60;offset&#x60;&#x3D;25, the next 25 bank transfer events will be returned.
  , bankTransferEventListRequestOriginationAccountId :: !(Maybe Text) -- ^ "origination_account_id" - The origination account ID to get events for transfers from a specific origination account.
  , bankTransferEventListRequestDirection :: !(Maybe Text) -- ^ "direction" - Indicates the direction of the transfer: &#x60;outbound&#x60; for API-initiated transfers, or &#x60;inbound&#x60; for payments received by the FBO account.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BankTransferEventListRequest
instance A.FromJSON BankTransferEventListRequest where
  parseJSON = A.withObject "BankTransferEventListRequest" $ \o ->
    BankTransferEventListRequest
      <$> (o .:? "client_id")
      <*> (o .:? "secret")
      <*> (o .:? "start_date")
      <*> (o .:? "end_date")
      <*> (o .:? "bank_transfer_id")
      <*> (o .:? "account_id")
      <*> (o .:? "bank_transfer_type")
      <*> (o .:? "event_types")
      <*> (o .:? "count")
      <*> (o .:? "offset")
      <*> (o .:? "origination_account_id")
      <*> (o .:? "direction")

-- | ToJSON BankTransferEventListRequest
instance A.ToJSON BankTransferEventListRequest where
  toJSON BankTransferEventListRequest {..} =
   _omitNulls
      [ "client_id" .= bankTransferEventListRequestClientId
      , "secret" .= bankTransferEventListRequestSecret
      , "start_date" .= bankTransferEventListRequestStartDate
      , "end_date" .= bankTransferEventListRequestEndDate
      , "bank_transfer_id" .= bankTransferEventListRequestBankTransferId
      , "account_id" .= bankTransferEventListRequestAccountId
      , "bank_transfer_type" .= bankTransferEventListRequestBankTransferType
      , "event_types" .= bankTransferEventListRequestEventTypes
      , "count" .= bankTransferEventListRequestCount
      , "offset" .= bankTransferEventListRequestOffset
      , "origination_account_id" .= bankTransferEventListRequestOriginationAccountId
      , "direction" .= bankTransferEventListRequestDirection
      ]


-- | Construct a value of type 'BankTransferEventListRequest' (by applying it's required fields, if any)
mkBankTransferEventListRequest
  :: BankTransferEventListRequest
mkBankTransferEventListRequest =
  BankTransferEventListRequest
  { bankTransferEventListRequestClientId = Nothing
  , bankTransferEventListRequestSecret = Nothing
  , bankTransferEventListRequestStartDate = Nothing
  , bankTransferEventListRequestEndDate = Nothing
  , bankTransferEventListRequestBankTransferId = Nothing
  , bankTransferEventListRequestAccountId = Nothing
  , bankTransferEventListRequestBankTransferType = Nothing
  , bankTransferEventListRequestEventTypes = Nothing
  , bankTransferEventListRequestCount = Nothing
  , bankTransferEventListRequestOffset = Nothing
  , bankTransferEventListRequestOriginationAccountId = Nothing
  , bankTransferEventListRequestDirection = Nothing
  }

-- ** BankTransferEventListResponse
-- | BankTransferEventListResponse
-- BankTransferEventListResponse
-- 
-- BankTransferEventListResponse defines the response schema for `/bank_transfer/event/list`
data BankTransferEventListResponse = BankTransferEventListResponse
  { bankTransferEventListResponseBankTransferEvents :: !([BankTransferEvent]) -- ^ /Required/ "bank_transfer_events"
  , bankTransferEventListResponseRequestId :: !(Text) -- ^ /Required/ "request_id" - A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BankTransferEventListResponse
instance A.FromJSON BankTransferEventListResponse where
  parseJSON = A.withObject "BankTransferEventListResponse" $ \o ->
    BankTransferEventListResponse
      <$> (o .:  "bank_transfer_events")
      <*> (o .:  "request_id")

-- | ToJSON BankTransferEventListResponse
instance A.ToJSON BankTransferEventListResponse where
  toJSON BankTransferEventListResponse {..} =
   _omitNulls
      [ "bank_transfer_events" .= bankTransferEventListResponseBankTransferEvents
      , "request_id" .= bankTransferEventListResponseRequestId
      ]


-- | Construct a value of type 'BankTransferEventListResponse' (by applying it's required fields, if any)
mkBankTransferEventListResponse
  :: [BankTransferEvent] -- ^ 'bankTransferEventListResponseBankTransferEvents' 
  -> Text -- ^ 'bankTransferEventListResponseRequestId': A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  -> BankTransferEventListResponse
mkBankTransferEventListResponse bankTransferEventListResponseBankTransferEvents bankTransferEventListResponseRequestId =
  BankTransferEventListResponse
  { bankTransferEventListResponseBankTransferEvents
  , bankTransferEventListResponseRequestId
  }

-- ** BankTransferEventSyncRequest
-- | BankTransferEventSyncRequest
-- BankTransferEventSyncRequest
-- 
-- BankTransferEventSyncRequest defines the request schema for `/bank_transfer/event/sync`
data BankTransferEventSyncRequest = BankTransferEventSyncRequest
  { bankTransferEventSyncRequestClientId :: !(Maybe Text) -- ^ "client_id" - Your Plaid API &#x60;client_id&#x60;.
  , bankTransferEventSyncRequestSecret :: !(Maybe Text) -- ^ "secret" - Your Plaid API &#x60;secret&#x60;.
  , bankTransferEventSyncRequestAfterId :: !(Int) -- ^ /Required/ "after_id" - The latest (largest) &#x60;event_id&#x60; fetched via the sync endpoint, or 0 initially.
  , bankTransferEventSyncRequestCount :: !(Maybe Int) -- ^ "count" - The maximum number of bank transfer events to return.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BankTransferEventSyncRequest
instance A.FromJSON BankTransferEventSyncRequest where
  parseJSON = A.withObject "BankTransferEventSyncRequest" $ \o ->
    BankTransferEventSyncRequest
      <$> (o .:? "client_id")
      <*> (o .:? "secret")
      <*> (o .:  "after_id")
      <*> (o .:? "count")

-- | ToJSON BankTransferEventSyncRequest
instance A.ToJSON BankTransferEventSyncRequest where
  toJSON BankTransferEventSyncRequest {..} =
   _omitNulls
      [ "client_id" .= bankTransferEventSyncRequestClientId
      , "secret" .= bankTransferEventSyncRequestSecret
      , "after_id" .= bankTransferEventSyncRequestAfterId
      , "count" .= bankTransferEventSyncRequestCount
      ]


-- | Construct a value of type 'BankTransferEventSyncRequest' (by applying it's required fields, if any)
mkBankTransferEventSyncRequest
  :: Int -- ^ 'bankTransferEventSyncRequestAfterId': The latest (largest) `event_id` fetched via the sync endpoint, or 0 initially.
  -> BankTransferEventSyncRequest
mkBankTransferEventSyncRequest bankTransferEventSyncRequestAfterId =
  BankTransferEventSyncRequest
  { bankTransferEventSyncRequestClientId = Nothing
  , bankTransferEventSyncRequestSecret = Nothing
  , bankTransferEventSyncRequestAfterId
  , bankTransferEventSyncRequestCount = Nothing
  }

-- ** BankTransferEventSyncResponse
-- | BankTransferEventSyncResponse
-- BankTransferEventSyncResponse
-- 
-- BankTransferEventSyncResponse defines the response schema for `/bank_transfer/event/sync`
data BankTransferEventSyncResponse = BankTransferEventSyncResponse
  { bankTransferEventSyncResponseBankTransferEvents :: !([BankTransferEvent]) -- ^ /Required/ "bank_transfer_events"
  , bankTransferEventSyncResponseRequestId :: !(Text) -- ^ /Required/ "request_id" - A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BankTransferEventSyncResponse
instance A.FromJSON BankTransferEventSyncResponse where
  parseJSON = A.withObject "BankTransferEventSyncResponse" $ \o ->
    BankTransferEventSyncResponse
      <$> (o .:  "bank_transfer_events")
      <*> (o .:  "request_id")

-- | ToJSON BankTransferEventSyncResponse
instance A.ToJSON BankTransferEventSyncResponse where
  toJSON BankTransferEventSyncResponse {..} =
   _omitNulls
      [ "bank_transfer_events" .= bankTransferEventSyncResponseBankTransferEvents
      , "request_id" .= bankTransferEventSyncResponseRequestId
      ]


-- | Construct a value of type 'BankTransferEventSyncResponse' (by applying it's required fields, if any)
mkBankTransferEventSyncResponse
  :: [BankTransferEvent] -- ^ 'bankTransferEventSyncResponseBankTransferEvents' 
  -> Text -- ^ 'bankTransferEventSyncResponseRequestId': A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  -> BankTransferEventSyncResponse
mkBankTransferEventSyncResponse bankTransferEventSyncResponseBankTransferEvents bankTransferEventSyncResponseRequestId =
  BankTransferEventSyncResponse
  { bankTransferEventSyncResponseBankTransferEvents
  , bankTransferEventSyncResponseRequestId
  }

-- ** BankTransferFailure
-- | BankTransferFailure
-- BankTransferFailure
-- 
-- The failure reason if the type of this transfer is `\"failed\"` or `\"reversed\"`. Null value otherwise.
data BankTransferFailure = BankTransferFailure
  { bankTransferFailureAchReturnCode :: !(Maybe Text) -- ^ "ach_return_code" - The ACH return code, e.g. &#x60;R01&#x60;.  A return code will be provided if and only if the transfer status is &#x60;reversed&#x60;. For a full listing of ACH return codes, see [Bank Transfers errors](/docs/errors/bank-transfers/#ach-return-codes).
  , bankTransferFailureDescription :: !(Maybe Text) -- ^ "description" - A human-readable description of the reason for the failure or reversal.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BankTransferFailure
instance A.FromJSON BankTransferFailure where
  parseJSON = A.withObject "BankTransferFailure" $ \o ->
    BankTransferFailure
      <$> (o .:? "ach_return_code")
      <*> (o .:? "description")

-- | ToJSON BankTransferFailure
instance A.ToJSON BankTransferFailure where
  toJSON BankTransferFailure {..} =
   _omitNulls
      [ "ach_return_code" .= bankTransferFailureAchReturnCode
      , "description" .= bankTransferFailureDescription
      ]


-- | Construct a value of type 'BankTransferFailure' (by applying it's required fields, if any)
mkBankTransferFailure
  :: BankTransferFailure
mkBankTransferFailure =
  BankTransferFailure
  { bankTransferFailureAchReturnCode = Nothing
  , bankTransferFailureDescription = Nothing
  }

-- ** BankTransferGetRequest
-- | BankTransferGetRequest
-- BankTransferGetRequest
-- 
-- BankTransferGetRequest defines the request schema for `/bank_transfer/get`
data BankTransferGetRequest = BankTransferGetRequest
  { bankTransferGetRequestClientId :: !(Maybe Text) -- ^ "client_id" - Your Plaid API &#x60;client_id&#x60;.
  , bankTransferGetRequestSecret :: !(Maybe Text) -- ^ "secret" - Your Plaid API &#x60;secret&#x60;.
  , bankTransferGetRequestBankTransferId :: !(Text) -- ^ /Required/ "bank_transfer_id" - Plaid’s unique identifier for a bank transfer.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BankTransferGetRequest
instance A.FromJSON BankTransferGetRequest where
  parseJSON = A.withObject "BankTransferGetRequest" $ \o ->
    BankTransferGetRequest
      <$> (o .:? "client_id")
      <*> (o .:? "secret")
      <*> (o .:  "bank_transfer_id")

-- | ToJSON BankTransferGetRequest
instance A.ToJSON BankTransferGetRequest where
  toJSON BankTransferGetRequest {..} =
   _omitNulls
      [ "client_id" .= bankTransferGetRequestClientId
      , "secret" .= bankTransferGetRequestSecret
      , "bank_transfer_id" .= bankTransferGetRequestBankTransferId
      ]


-- | Construct a value of type 'BankTransferGetRequest' (by applying it's required fields, if any)
mkBankTransferGetRequest
  :: Text -- ^ 'bankTransferGetRequestBankTransferId': Plaid’s unique identifier for a bank transfer.
  -> BankTransferGetRequest
mkBankTransferGetRequest bankTransferGetRequestBankTransferId =
  BankTransferGetRequest
  { bankTransferGetRequestClientId = Nothing
  , bankTransferGetRequestSecret = Nothing
  , bankTransferGetRequestBankTransferId
  }

-- ** BankTransferGetResponse
-- | BankTransferGetResponse
-- BankTransferGetResponse
-- 
-- BankTransferGetResponse defines the response schema for `/bank_transfer/get`
data BankTransferGetResponse = BankTransferGetResponse
  { bankTransferGetResponseBankTransfer :: !(BankTransfer) -- ^ /Required/ "bank_transfer"
  , bankTransferGetResponseRequestId :: !(Text) -- ^ /Required/ "request_id" - A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BankTransferGetResponse
instance A.FromJSON BankTransferGetResponse where
  parseJSON = A.withObject "BankTransferGetResponse" $ \o ->
    BankTransferGetResponse
      <$> (o .:  "bank_transfer")
      <*> (o .:  "request_id")

-- | ToJSON BankTransferGetResponse
instance A.ToJSON BankTransferGetResponse where
  toJSON BankTransferGetResponse {..} =
   _omitNulls
      [ "bank_transfer" .= bankTransferGetResponseBankTransfer
      , "request_id" .= bankTransferGetResponseRequestId
      ]


-- | Construct a value of type 'BankTransferGetResponse' (by applying it's required fields, if any)
mkBankTransferGetResponse
  :: BankTransfer -- ^ 'bankTransferGetResponseBankTransfer' 
  -> Text -- ^ 'bankTransferGetResponseRequestId': A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  -> BankTransferGetResponse
mkBankTransferGetResponse bankTransferGetResponseBankTransfer bankTransferGetResponseRequestId =
  BankTransferGetResponse
  { bankTransferGetResponseBankTransfer
  , bankTransferGetResponseRequestId
  }

-- ** BankTransferListRequest
-- | BankTransferListRequest
-- BankTransferListRequest
-- 
-- BankTransferListRequest defines the request schema for `/bank_transfer/list`
data BankTransferListRequest = BankTransferListRequest
  { bankTransferListRequestClientId :: !(Maybe Text) -- ^ "client_id" - Your Plaid API &#x60;client_id&#x60;.
  , bankTransferListRequestSecret :: !(Maybe Text) -- ^ "secret" - Your Plaid API &#x60;secret&#x60;.
  , bankTransferListRequestStartDate :: !(Maybe DateTime) -- ^ "start_date" - The start datetime of bank transfers to list. This should be in RFC 3339 format (i.e. &#x60;2019-12-06T22:35:49Z&#x60;)
  , bankTransferListRequestEndDate :: !(Maybe DateTime) -- ^ "end_date" - The end datetime of bank transfers to list. This should be in RFC 3339 format (i.e. &#x60;2019-12-06T22:35:49Z&#x60;)
  , bankTransferListRequestCount :: !(Maybe Int) -- ^ "count" - The maximum number of bank transfers to return.
  , bankTransferListRequestOffset :: !(Maybe Int) -- ^ "offset" - The number of bank transfers to skip before returning results.
  , bankTransferListRequestOriginationAccountId :: !(Maybe Text) -- ^ "origination_account_id" - Filter bank transfers to only those originated through the specified origination account.
  , bankTransferListRequestDirection :: !(Maybe BankTransferDirection) -- ^ "direction"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BankTransferListRequest
instance A.FromJSON BankTransferListRequest where
  parseJSON = A.withObject "BankTransferListRequest" $ \o ->
    BankTransferListRequest
      <$> (o .:? "client_id")
      <*> (o .:? "secret")
      <*> (o .:? "start_date")
      <*> (o .:? "end_date")
      <*> (o .:? "count")
      <*> (o .:? "offset")
      <*> (o .:? "origination_account_id")
      <*> (o .:? "direction")

-- | ToJSON BankTransferListRequest
instance A.ToJSON BankTransferListRequest where
  toJSON BankTransferListRequest {..} =
   _omitNulls
      [ "client_id" .= bankTransferListRequestClientId
      , "secret" .= bankTransferListRequestSecret
      , "start_date" .= bankTransferListRequestStartDate
      , "end_date" .= bankTransferListRequestEndDate
      , "count" .= bankTransferListRequestCount
      , "offset" .= bankTransferListRequestOffset
      , "origination_account_id" .= bankTransferListRequestOriginationAccountId
      , "direction" .= bankTransferListRequestDirection
      ]


-- | Construct a value of type 'BankTransferListRequest' (by applying it's required fields, if any)
mkBankTransferListRequest
  :: BankTransferListRequest
mkBankTransferListRequest =
  BankTransferListRequest
  { bankTransferListRequestClientId = Nothing
  , bankTransferListRequestSecret = Nothing
  , bankTransferListRequestStartDate = Nothing
  , bankTransferListRequestEndDate = Nothing
  , bankTransferListRequestCount = Nothing
  , bankTransferListRequestOffset = Nothing
  , bankTransferListRequestOriginationAccountId = Nothing
  , bankTransferListRequestDirection = Nothing
  }

-- ** BankTransferListResponse
-- | BankTransferListResponse
-- BankTransferListResponse
-- 
-- BankTransferListResponse defines the response schema for `/bank_transfer/list`
data BankTransferListResponse = BankTransferListResponse
  { bankTransferListResponseBankTransfers :: !([BankTransfer]) -- ^ /Required/ "bank_transfers"
  , bankTransferListResponseRequestId :: !(Text) -- ^ /Required/ "request_id" - A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BankTransferListResponse
instance A.FromJSON BankTransferListResponse where
  parseJSON = A.withObject "BankTransferListResponse" $ \o ->
    BankTransferListResponse
      <$> (o .:  "bank_transfers")
      <*> (o .:  "request_id")

-- | ToJSON BankTransferListResponse
instance A.ToJSON BankTransferListResponse where
  toJSON BankTransferListResponse {..} =
   _omitNulls
      [ "bank_transfers" .= bankTransferListResponseBankTransfers
      , "request_id" .= bankTransferListResponseRequestId
      ]


-- | Construct a value of type 'BankTransferListResponse' (by applying it's required fields, if any)
mkBankTransferListResponse
  :: [BankTransfer] -- ^ 'bankTransferListResponseBankTransfers' 
  -> Text -- ^ 'bankTransferListResponseRequestId': A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  -> BankTransferListResponse
mkBankTransferListResponse bankTransferListResponseBankTransfers bankTransferListResponseRequestId =
  BankTransferListResponse
  { bankTransferListResponseBankTransfers
  , bankTransferListResponseRequestId
  }

-- ** BankTransferMigrateAccountRequest
-- | BankTransferMigrateAccountRequest
-- BankTransferMigrateAccountRequest
-- 
-- BankTransferMigrateAccountRequest defines the request schema for `/bank_transfer/migrate_account`
data BankTransferMigrateAccountRequest = BankTransferMigrateAccountRequest
  { bankTransferMigrateAccountRequestClientId :: !(Maybe Text) -- ^ "client_id" - Your Plaid API &#x60;client_id&#x60;.
  , bankTransferMigrateAccountRequestSecret :: !(Maybe Text) -- ^ "secret" - Your Plaid API &#x60;secret&#x60;.
  , bankTransferMigrateAccountRequestAccountNumber :: !(Text) -- ^ /Required/ "account_number" - The user&#39;s account number.
  , bankTransferMigrateAccountRequestRoutingNumber :: !(Text) -- ^ /Required/ "routing_number" - The user&#39;s routing number.
  , bankTransferMigrateAccountRequestAccountType :: !(Text) -- ^ /Required/ "account_type" - The type of the bank account (&#x60;checking&#x60; or &#x60;savings&#x60;).
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BankTransferMigrateAccountRequest
instance A.FromJSON BankTransferMigrateAccountRequest where
  parseJSON = A.withObject "BankTransferMigrateAccountRequest" $ \o ->
    BankTransferMigrateAccountRequest
      <$> (o .:? "client_id")
      <*> (o .:? "secret")
      <*> (o .:  "account_number")
      <*> (o .:  "routing_number")
      <*> (o .:  "account_type")

-- | ToJSON BankTransferMigrateAccountRequest
instance A.ToJSON BankTransferMigrateAccountRequest where
  toJSON BankTransferMigrateAccountRequest {..} =
   _omitNulls
      [ "client_id" .= bankTransferMigrateAccountRequestClientId
      , "secret" .= bankTransferMigrateAccountRequestSecret
      , "account_number" .= bankTransferMigrateAccountRequestAccountNumber
      , "routing_number" .= bankTransferMigrateAccountRequestRoutingNumber
      , "account_type" .= bankTransferMigrateAccountRequestAccountType
      ]


-- | Construct a value of type 'BankTransferMigrateAccountRequest' (by applying it's required fields, if any)
mkBankTransferMigrateAccountRequest
  :: Text -- ^ 'bankTransferMigrateAccountRequestAccountNumber': The user's account number.
  -> Text -- ^ 'bankTransferMigrateAccountRequestRoutingNumber': The user's routing number.
  -> Text -- ^ 'bankTransferMigrateAccountRequestAccountType': The type of the bank account (`checking` or `savings`).
  -> BankTransferMigrateAccountRequest
mkBankTransferMigrateAccountRequest bankTransferMigrateAccountRequestAccountNumber bankTransferMigrateAccountRequestRoutingNumber bankTransferMigrateAccountRequestAccountType =
  BankTransferMigrateAccountRequest
  { bankTransferMigrateAccountRequestClientId = Nothing
  , bankTransferMigrateAccountRequestSecret = Nothing
  , bankTransferMigrateAccountRequestAccountNumber
  , bankTransferMigrateAccountRequestRoutingNumber
  , bankTransferMigrateAccountRequestAccountType
  }

-- ** BankTransferMigrateAccountResponse
-- | BankTransferMigrateAccountResponse
-- BankTransferMigrateAccountResponse
-- 
-- BankTransferMigrateAccountResponse defines the response schema for `/bank_transfer/migrate_account`
data BankTransferMigrateAccountResponse = BankTransferMigrateAccountResponse
  { bankTransferMigrateAccountResponseAccessToken :: !(AccessToken) -- ^ /Required/ "access_token" - The Plaid &#x60;access_token&#x60; for the newly created Item.
  , bankTransferMigrateAccountResponseAccountId :: !(Text) -- ^ /Required/ "account_id" - The Plaid &#x60;account_id&#x60; for the newly created Item.
  , bankTransferMigrateAccountResponseRequestId :: !(Text) -- ^ /Required/ "request_id" - A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BankTransferMigrateAccountResponse
instance A.FromJSON BankTransferMigrateAccountResponse where
  parseJSON = A.withObject "BankTransferMigrateAccountResponse" $ \o ->
    BankTransferMigrateAccountResponse
      <$> (o .:  "access_token")
      <*> (o .:  "account_id")
      <*> (o .:  "request_id")

-- | ToJSON BankTransferMigrateAccountResponse
instance A.ToJSON BankTransferMigrateAccountResponse where
  toJSON BankTransferMigrateAccountResponse {..} =
   _omitNulls
      [ "access_token" .= bankTransferMigrateAccountResponseAccessToken
      , "account_id" .= bankTransferMigrateAccountResponseAccountId
      , "request_id" .= bankTransferMigrateAccountResponseRequestId
      ]


-- | Construct a value of type 'BankTransferMigrateAccountResponse' (by applying it's required fields, if any)
mkBankTransferMigrateAccountResponse
  :: AccessToken -- ^ 'bankTransferMigrateAccountResponseAccessToken': The Plaid `access_token` for the newly created Item.
  -> Text -- ^ 'bankTransferMigrateAccountResponseAccountId': The Plaid `account_id` for the newly created Item.
  -> Text -- ^ 'bankTransferMigrateAccountResponseRequestId': A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  -> BankTransferMigrateAccountResponse
mkBankTransferMigrateAccountResponse bankTransferMigrateAccountResponseAccessToken bankTransferMigrateAccountResponseAccountId bankTransferMigrateAccountResponseRequestId =
  BankTransferMigrateAccountResponse
  { bankTransferMigrateAccountResponseAccessToken
  , bankTransferMigrateAccountResponseAccountId
  , bankTransferMigrateAccountResponseRequestId
  }

-- ** BankTransferReceiverDetails
-- | BankTransferReceiverDetails
-- BankTransferReceiverDetails
-- 
-- The receiver details if the type of this event is `reciever_pending` or `reciever_posted`. Null value otherwise.
data BankTransferReceiverDetails = BankTransferReceiverDetails
  { bankTransferReceiverDetailsAvailableBalance :: !(Maybe E'AvailableBalance) -- ^ "available_balance" - The sign of the available balance for the receiver bank account associated with the receiver event at the time the matching transaction was found. Can be &#x60;positive&#x60;, &#x60;negative&#x60;, or null if the balance was not available at the time.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BankTransferReceiverDetails
instance A.FromJSON BankTransferReceiverDetails where
  parseJSON = A.withObject "BankTransferReceiverDetails" $ \o ->
    BankTransferReceiverDetails
      <$> (o .:? "available_balance")

-- | ToJSON BankTransferReceiverDetails
instance A.ToJSON BankTransferReceiverDetails where
  toJSON BankTransferReceiverDetails {..} =
   _omitNulls
      [ "available_balance" .= bankTransferReceiverDetailsAvailableBalance
      ]


-- | Construct a value of type 'BankTransferReceiverDetails' (by applying it's required fields, if any)
mkBankTransferReceiverDetails
  :: BankTransferReceiverDetails
mkBankTransferReceiverDetails =
  BankTransferReceiverDetails
  { bankTransferReceiverDetailsAvailableBalance = Nothing
  }

-- ** BankTransferUser
-- | BankTransferUser
-- BankTransferUser
-- 
-- The legal name and other information for the account holder.
data BankTransferUser = BankTransferUser
  { bankTransferUserLegalName :: !(Text) -- ^ /Required/ "legal_name" - The account holder’s full legal name.
  , bankTransferUserEmailAddress :: !(Maybe Text) -- ^ "email_address" - The account holder’s email.
  , bankTransferUserRoutingNumber :: !(Maybe Text) -- ^ /ReadOnly/ "routing_number" - The account holder&#39;s routing number. This field is only used for response data. Do not provide this field when making requests.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BankTransferUser
instance A.FromJSON BankTransferUser where
  parseJSON = A.withObject "BankTransferUser" $ \o ->
    BankTransferUser
      <$> (o .:  "legal_name")
      <*> (o .:? "email_address")
      <*> (o .:? "routing_number")

-- | ToJSON BankTransferUser
instance A.ToJSON BankTransferUser where
  toJSON BankTransferUser {..} =
   _omitNulls
      [ "legal_name" .= bankTransferUserLegalName
      , "email_address" .= bankTransferUserEmailAddress
      , "routing_number" .= bankTransferUserRoutingNumber
      ]


-- | Construct a value of type 'BankTransferUser' (by applying it's required fields, if any)
mkBankTransferUser
  :: Text -- ^ 'bankTransferUserLegalName': The account holder’s full legal name.
  -> BankTransferUser
mkBankTransferUser bankTransferUserLegalName =
  BankTransferUser
  { bankTransferUserLegalName
  , bankTransferUserEmailAddress = Nothing
  , bankTransferUserRoutingNumber = Nothing
  }

-- ** CategoriesGetResponse
-- | CategoriesGetResponse
-- CategoriesGetResponse defines the response schema for `/categories/get`
data CategoriesGetResponse = CategoriesGetResponse
  { categoriesGetResponseCategories :: !([Category]) -- ^ /Required/ "categories" - An array of all of the transaction categories used by Plaid.
  , categoriesGetResponseRequestId :: !(Text) -- ^ /Required/ "request_id" - A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CategoriesGetResponse
instance A.FromJSON CategoriesGetResponse where
  parseJSON = A.withObject "CategoriesGetResponse" $ \o ->
    CategoriesGetResponse
      <$> (o .:  "categories")
      <*> (o .:  "request_id")

-- | ToJSON CategoriesGetResponse
instance A.ToJSON CategoriesGetResponse where
  toJSON CategoriesGetResponse {..} =
   _omitNulls
      [ "categories" .= categoriesGetResponseCategories
      , "request_id" .= categoriesGetResponseRequestId
      ]


-- | Construct a value of type 'CategoriesGetResponse' (by applying it's required fields, if any)
mkCategoriesGetResponse
  :: [Category] -- ^ 'categoriesGetResponseCategories': An array of all of the transaction categories used by Plaid.
  -> Text -- ^ 'categoriesGetResponseRequestId': A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  -> CategoriesGetResponse
mkCategoriesGetResponse categoriesGetResponseCategories categoriesGetResponseRequestId =
  CategoriesGetResponse
  { categoriesGetResponseCategories
  , categoriesGetResponseRequestId
  }

-- ** Category
-- | Category
-- Category
-- 
-- Information describing a transaction category
data Category = Category
  { categoryCategoryId :: !(Text) -- ^ /Required/ "category_id" - An identifying number for the category. &#x60;category_id&#x60; is a Plaid-specific identifier and does not necessarily correspond to merchant category codes.
  , categoryGroup :: !(Text) -- ^ /Required/ "group" - &#x60;place&#x60; for physical transactions or &#x60;special&#x60; for other transactions such as bank charges.
  , categoryHierarchy :: !([Text]) -- ^ /Required/ "hierarchy" - A hierarchical array of the categories to which this &#x60;category_id&#x60; belongs.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Category
instance A.FromJSON Category where
  parseJSON = A.withObject "Category" $ \o ->
    Category
      <$> (o .:  "category_id")
      <*> (o .:  "group")
      <*> (o .:  "hierarchy")

-- | ToJSON Category
instance A.ToJSON Category where
  toJSON Category {..} =
   _omitNulls
      [ "category_id" .= categoryCategoryId
      , "group" .= categoryGroup
      , "hierarchy" .= categoryHierarchy
      ]


-- | Construct a value of type 'Category' (by applying it's required fields, if any)
mkCategory
  :: Text -- ^ 'categoryCategoryId': An identifying number for the category. `category_id` is a Plaid-specific identifier and does not necessarily correspond to merchant category codes.
  -> Text -- ^ 'categoryGroup': `place` for physical transactions or `special` for other transactions such as bank charges.
  -> [Text] -- ^ 'categoryHierarchy': A hierarchical array of the categories to which this `category_id` belongs.
  -> Category
mkCategory categoryCategoryId categoryGroup categoryHierarchy =
  Category
  { categoryCategoryId
  , categoryGroup
  , categoryHierarchy
  }

-- ** Cause
-- | Cause
-- Cause
-- 
-- An error object and associated `item_id` used to identify a specific Item and error when a batch operation operating on multiple Items has encountered an error in one of the Items.
data Cause = Cause
  { causeItemId :: !(ItemId) -- ^ /Required/ "item_id" - The &#x60;item_id&#x60; of the Item associated with this webhook, warning, or error
  , causeError :: !(Error) -- ^ /Required/ "error"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Cause
instance A.FromJSON Cause where
  parseJSON = A.withObject "Cause" $ \o ->
    Cause
      <$> (o .:  "item_id")
      <*> (o .:  "error")

-- | ToJSON Cause
instance A.ToJSON Cause where
  toJSON Cause {..} =
   _omitNulls
      [ "item_id" .= causeItemId
      , "error" .= causeError
      ]


-- | Construct a value of type 'Cause' (by applying it's required fields, if any)
mkCause
  :: ItemId -- ^ 'causeItemId': The `item_id` of the Item associated with this webhook, warning, or error
  -> Error -- ^ 'causeError' 
  -> Cause
mkCause causeItemId causeError =
  Cause
  { causeItemId
  , causeError
  }

-- ** CreditCardLiability
-- | CreditCardLiability
-- CreditCardLiability
-- 
-- An object representing a credit card account.
data CreditCardLiability = CreditCardLiability
  { creditCardLiabilityAccountId :: !(Maybe Text) -- ^ "account_id" - The ID of the account that this liability belongs to.
  , creditCardLiabilityAprs :: !([APR]) -- ^ /Required/ "aprs" - The various interest rates that apply to the account.
  , creditCardLiabilityIsOverdue :: !(Maybe Bool) -- ^ "is_overdue" - true if a payment is currently overdue. Availability for this field is limited.
  , creditCardLiabilityLastPaymentAmount :: !(Maybe Double) -- ^ /Required/ "last_payment_amount" - The amount of the last payment.
  , creditCardLiabilityLastPaymentDate :: !(Maybe Text) -- ^ /Required/ "last_payment_date" - The date of the last payment. Dates are returned in an ISO 8601 format (YYYY-MM-DD). Availability for this field is limited.
  , creditCardLiabilityLastStatementBalance :: !(Maybe Double) -- ^ /Required/ "last_statement_balance" - The outstanding balance on the last statement. Availability for this field is limited.
  , creditCardLiabilityLastStatementIssueDate :: !(Maybe Text) -- ^ /Required/ "last_statement_issue_date" - The date of the last statement. Dates are returned in an ISO 8601 format (YYYY-MM-DD).
  , creditCardLiabilityMinimumPaymentAmount :: !(Maybe Double) -- ^ /Required/ "minimum_payment_amount" - The minimum payment due for the next billing cycle.
  , creditCardLiabilityNextPaymentDueDate :: !(Maybe Text) -- ^ /Required/ "next_payment_due_date" - The due date for the next payment. The due date is &#x60;null&#x60; if a payment is not expected. Dates are returned in an ISO 8601 format (YYYY-MM-DD).
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreditCardLiability
instance A.FromJSON CreditCardLiability where
  parseJSON = A.withObject "CreditCardLiability" $ \o ->
    CreditCardLiability
      <$> (o .:? "account_id")
      <*> (o .:  "aprs")
      <*> (o .:? "is_overdue")
      <*> (o .:?  "last_payment_amount")
      <*> (o .:?  "last_payment_date")
      <*> (o .:?  "last_statement_balance")
      <*> (o .:? "last_statement_issue_date")
      <*> (o .:?  "minimum_payment_amount")
      <*> (o .:?  "next_payment_due_date")

-- | ToJSON CreditCardLiability
instance A.ToJSON CreditCardLiability where
  toJSON CreditCardLiability {..} =
   _omitNulls
      [ "account_id" .= creditCardLiabilityAccountId
      , "aprs" .= creditCardLiabilityAprs
      , "is_overdue" .= creditCardLiabilityIsOverdue
      , "last_payment_amount" .= creditCardLiabilityLastPaymentAmount
      , "last_payment_date" .= creditCardLiabilityLastPaymentDate
      , "last_statement_balance" .= creditCardLiabilityLastStatementBalance
      , "last_statement_issue_date" .= creditCardLiabilityLastStatementIssueDate
      , "minimum_payment_amount" .= creditCardLiabilityMinimumPaymentAmount
      , "next_payment_due_date" .= creditCardLiabilityNextPaymentDueDate
      ]


-- | Construct a value of type 'CreditCardLiability' (by applying it's required fields, if any)
mkCreditCardLiability
  :: [APR] -- ^ 'creditCardLiabilityAprs': The various interest rates that apply to the account.
  -> Maybe Double -- ^ 'creditCardLiabilityLastPaymentAmount': The amount of the last payment.
  -> Maybe Text -- ^ 'creditCardLiabilityLastPaymentDate': The date of the last payment. Dates are returned in an ISO 8601 format (YYYY-MM-DD). Availability for this field is limited.
  -> Maybe Double -- ^ 'creditCardLiabilityLastStatementBalance': The outstanding balance on the last statement. Availability for this field is limited.
  -> Maybe Text -- ^ 'creditCardLiabilityLastStatementIssueDate': The date of the last statement. Dates are returned in an ISO 8601 format (YYYY-MM-DD).
  -> Maybe Double -- ^ 'creditCardLiabilityMinimumPaymentAmount': The minimum payment due for the next billing cycle.
  -> Maybe Text -- ^ 'creditCardLiabilityNextPaymentDueDate': The due date for the next payment. The due date is `null` if a payment is not expected. Dates are returned in an ISO 8601 format (YYYY-MM-DD).
  -> CreditCardLiability
mkCreditCardLiability creditCardLiabilityAprs creditCardLiabilityLastPaymentAmount creditCardLiabilityLastPaymentDate creditCardLiabilityLastStatementBalance creditCardLiabilityLastStatementIssueDate creditCardLiabilityMinimumPaymentAmount creditCardLiabilityNextPaymentDueDate =
  CreditCardLiability
  { creditCardLiabilityAccountId = Nothing
  , creditCardLiabilityAprs
  , creditCardLiabilityIsOverdue = Nothing
  , creditCardLiabilityLastPaymentAmount
  , creditCardLiabilityLastPaymentDate
  , creditCardLiabilityLastStatementBalance
  , creditCardLiabilityLastStatementIssueDate
  , creditCardLiabilityMinimumPaymentAmount
  , creditCardLiabilityNextPaymentDueDate
  }

-- ** CreditFilter
-- | CreditFilter
-- CreditFilter
-- 
-- A filter to apply to `credit`-type accounts
data CreditFilter = CreditFilter
  { creditFilterAccountSubtypes :: !([AccountSubtype]) -- ^ /Required/ "account_subtypes" - An array of account subtypes to display in Link. If not specified, all account subtypes will be shown. For a full list of valid types and subtypes, see the [Account schema](/docs/api/accounts#accounts-schema). 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreditFilter
instance A.FromJSON CreditFilter where
  parseJSON = A.withObject "CreditFilter" $ \o ->
    CreditFilter
      <$> (o .:  "account_subtypes")

-- | ToJSON CreditFilter
instance A.ToJSON CreditFilter where
  toJSON CreditFilter {..} =
   _omitNulls
      [ "account_subtypes" .= creditFilterAccountSubtypes
      ]


-- | Construct a value of type 'CreditFilter' (by applying it's required fields, if any)
mkCreditFilter
  :: [AccountSubtype] -- ^ 'creditFilterAccountSubtypes': An array of account subtypes to display in Link. If not specified, all account subtypes will be shown. For a full list of valid types and subtypes, see the [Account schema](/docs/api/accounts#accounts-schema). 
  -> CreditFilter
mkCreditFilter creditFilterAccountSubtypes =
  CreditFilter
  { creditFilterAccountSubtypes
  }

-- ** DefaultUpdateWebhook
-- | DefaultUpdateWebhook
-- Fired when new transaction data is available for an Item. Plaid will typically check for new transaction data several times a day. 
data DefaultUpdateWebhook = DefaultUpdateWebhook
  { defaultUpdateWebhookWebhookType :: !(Text) -- ^ /Required/ "webhook_type" - &#x60;TRANSACTIONS&#x60;
  , defaultUpdateWebhookWebhookCode :: !(Text) -- ^ /Required/ "webhook_code" - &#x60;DEFAULT_UPDATE&#x60;
  , defaultUpdateWebhookError :: !(Maybe Error) -- ^ "error"
  , defaultUpdateWebhookNewTransactions :: !(Double) -- ^ /Required/ "new_transactions" - The number of new transactions detected since the last time this webhook was fired.
  , defaultUpdateWebhookItemId :: !(ItemId) -- ^ /Required/ "item_id" - The &#x60;item_id&#x60; of the Item the webhook relates to.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DefaultUpdateWebhook
instance A.FromJSON DefaultUpdateWebhook where
  parseJSON = A.withObject "DefaultUpdateWebhook" $ \o ->
    DefaultUpdateWebhook
      <$> (o .:  "webhook_type")
      <*> (o .:  "webhook_code")
      <*> (o .:? "error")
      <*> (o .:  "new_transactions")
      <*> (o .:  "item_id")

-- | ToJSON DefaultUpdateWebhook
instance A.ToJSON DefaultUpdateWebhook where
  toJSON DefaultUpdateWebhook {..} =
   _omitNulls
      [ "webhook_type" .= defaultUpdateWebhookWebhookType
      , "webhook_code" .= defaultUpdateWebhookWebhookCode
      , "error" .= defaultUpdateWebhookError
      , "new_transactions" .= defaultUpdateWebhookNewTransactions
      , "item_id" .= defaultUpdateWebhookItemId
      ]


-- | Construct a value of type 'DefaultUpdateWebhook' (by applying it's required fields, if any)
mkDefaultUpdateWebhook
  :: Text -- ^ 'defaultUpdateWebhookWebhookType': `TRANSACTIONS`
  -> Text -- ^ 'defaultUpdateWebhookWebhookCode': `DEFAULT_UPDATE`
  -> Double -- ^ 'defaultUpdateWebhookNewTransactions': The number of new transactions detected since the last time this webhook was fired.
  -> ItemId -- ^ 'defaultUpdateWebhookItemId': The `item_id` of the Item the webhook relates to.
  -> DefaultUpdateWebhook
mkDefaultUpdateWebhook defaultUpdateWebhookWebhookType defaultUpdateWebhookWebhookCode defaultUpdateWebhookNewTransactions defaultUpdateWebhookItemId =
  DefaultUpdateWebhook
  { defaultUpdateWebhookWebhookType
  , defaultUpdateWebhookWebhookCode
  , defaultUpdateWebhookError = Nothing
  , defaultUpdateWebhookNewTransactions
  , defaultUpdateWebhookItemId
  }

-- ** DepositSwitchAddressData
-- | DepositSwitchAddressData
-- DepositSwitchAddressData
-- 
-- The user's address.
data DepositSwitchAddressData = DepositSwitchAddressData
  { depositSwitchAddressDataCity :: !(Text) -- ^ /Required/ "city" - The full city name
  , depositSwitchAddressDataRegion :: !(Text) -- ^ /Required/ "region" - The region or state Example: &#x60;\&quot;NC\&quot;&#x60;
  , depositSwitchAddressDataStreet :: !(Text) -- ^ /Required/ "street" - The full street address Example: &#x60;\&quot;564 Main Street, APT 15\&quot;&#x60;
  , depositSwitchAddressDataPostalCode :: !(Text) -- ^ /Required/ "postal_code" - The postal code
  , depositSwitchAddressDataCountry :: !(Text) -- ^ /Required/ "country" - The ISO 3166-1 alpha-2 country code
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DepositSwitchAddressData
instance A.FromJSON DepositSwitchAddressData where
  parseJSON = A.withObject "DepositSwitchAddressData" $ \o ->
    DepositSwitchAddressData
      <$> (o .:  "city")
      <*> (o .:  "region")
      <*> (o .:  "street")
      <*> (o .:  "postal_code")
      <*> (o .:  "country")

-- | ToJSON DepositSwitchAddressData
instance A.ToJSON DepositSwitchAddressData where
  toJSON DepositSwitchAddressData {..} =
   _omitNulls
      [ "city" .= depositSwitchAddressDataCity
      , "region" .= depositSwitchAddressDataRegion
      , "street" .= depositSwitchAddressDataStreet
      , "postal_code" .= depositSwitchAddressDataPostalCode
      , "country" .= depositSwitchAddressDataCountry
      ]


-- | Construct a value of type 'DepositSwitchAddressData' (by applying it's required fields, if any)
mkDepositSwitchAddressData
  :: Text -- ^ 'depositSwitchAddressDataCity': The full city name
  -> Text -- ^ 'depositSwitchAddressDataRegion': The region or state Example: `\"NC\"`
  -> Text -- ^ 'depositSwitchAddressDataStreet': The full street address Example: `\"564 Main Street, APT 15\"`
  -> Text -- ^ 'depositSwitchAddressDataPostalCode': The postal code
  -> Text -- ^ 'depositSwitchAddressDataCountry': The ISO 3166-1 alpha-2 country code
  -> DepositSwitchAddressData
mkDepositSwitchAddressData depositSwitchAddressDataCity depositSwitchAddressDataRegion depositSwitchAddressDataStreet depositSwitchAddressDataPostalCode depositSwitchAddressDataCountry =
  DepositSwitchAddressData
  { depositSwitchAddressDataCity
  , depositSwitchAddressDataRegion
  , depositSwitchAddressDataStreet
  , depositSwitchAddressDataPostalCode
  , depositSwitchAddressDataCountry
  }

-- ** DepositSwitchAltCreateRequest
-- | DepositSwitchAltCreateRequest
-- DepositSwitchAltCreateRequest
-- 
-- DepositSwitchAltCreateRequest defines the request schema for `/deposit_switch/alt/create`
data DepositSwitchAltCreateRequest = DepositSwitchAltCreateRequest
  { depositSwitchAltCreateRequestClientId :: !(Maybe Text) -- ^ "client_id" - Your Plaid API &#x60;client_id&#x60;.
  , depositSwitchAltCreateRequestSecret :: !(Maybe Text) -- ^ "secret" - Your Plaid API &#x60;secret&#x60;.
  , depositSwitchAltCreateRequestTargetAccount :: !(DepositSwitchTargetAccount) -- ^ /Required/ "target_account"
  , depositSwitchAltCreateRequestTargetUser :: !(DepositSwitchTargetUser) -- ^ /Required/ "target_user"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DepositSwitchAltCreateRequest
instance A.FromJSON DepositSwitchAltCreateRequest where
  parseJSON = A.withObject "DepositSwitchAltCreateRequest" $ \o ->
    DepositSwitchAltCreateRequest
      <$> (o .:? "client_id")
      <*> (o .:? "secret")
      <*> (o .:  "target_account")
      <*> (o .:  "target_user")

-- | ToJSON DepositSwitchAltCreateRequest
instance A.ToJSON DepositSwitchAltCreateRequest where
  toJSON DepositSwitchAltCreateRequest {..} =
   _omitNulls
      [ "client_id" .= depositSwitchAltCreateRequestClientId
      , "secret" .= depositSwitchAltCreateRequestSecret
      , "target_account" .= depositSwitchAltCreateRequestTargetAccount
      , "target_user" .= depositSwitchAltCreateRequestTargetUser
      ]


-- | Construct a value of type 'DepositSwitchAltCreateRequest' (by applying it's required fields, if any)
mkDepositSwitchAltCreateRequest
  :: DepositSwitchTargetAccount -- ^ 'depositSwitchAltCreateRequestTargetAccount' 
  -> DepositSwitchTargetUser -- ^ 'depositSwitchAltCreateRequestTargetUser' 
  -> DepositSwitchAltCreateRequest
mkDepositSwitchAltCreateRequest depositSwitchAltCreateRequestTargetAccount depositSwitchAltCreateRequestTargetUser =
  DepositSwitchAltCreateRequest
  { depositSwitchAltCreateRequestClientId = Nothing
  , depositSwitchAltCreateRequestSecret = Nothing
  , depositSwitchAltCreateRequestTargetAccount
  , depositSwitchAltCreateRequestTargetUser
  }

-- ** DepositSwitchAltCreateResponse
-- | DepositSwitchAltCreateResponse
-- DepositSwitchAltCreateResponse
-- 
-- DepositSwitchAltCreateResponse defines the response schema for `/deposit_switch/alt/create`
data DepositSwitchAltCreateResponse = DepositSwitchAltCreateResponse
  { depositSwitchAltCreateResponseDepositSwitchId :: !(Text) -- ^ /Required/ "deposit_switch_id" - ID of the deposit switch. This ID is persisted throughout the lifetime of the deposit switch.
  , depositSwitchAltCreateResponseRequestId :: !(Text) -- ^ /Required/ "request_id" - A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DepositSwitchAltCreateResponse
instance A.FromJSON DepositSwitchAltCreateResponse where
  parseJSON = A.withObject "DepositSwitchAltCreateResponse" $ \o ->
    DepositSwitchAltCreateResponse
      <$> (o .:  "deposit_switch_id")
      <*> (o .:  "request_id")

-- | ToJSON DepositSwitchAltCreateResponse
instance A.ToJSON DepositSwitchAltCreateResponse where
  toJSON DepositSwitchAltCreateResponse {..} =
   _omitNulls
      [ "deposit_switch_id" .= depositSwitchAltCreateResponseDepositSwitchId
      , "request_id" .= depositSwitchAltCreateResponseRequestId
      ]


-- | Construct a value of type 'DepositSwitchAltCreateResponse' (by applying it's required fields, if any)
mkDepositSwitchAltCreateResponse
  :: Text -- ^ 'depositSwitchAltCreateResponseDepositSwitchId': ID of the deposit switch. This ID is persisted throughout the lifetime of the deposit switch.
  -> Text -- ^ 'depositSwitchAltCreateResponseRequestId': A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  -> DepositSwitchAltCreateResponse
mkDepositSwitchAltCreateResponse depositSwitchAltCreateResponseDepositSwitchId depositSwitchAltCreateResponseRequestId =
  DepositSwitchAltCreateResponse
  { depositSwitchAltCreateResponseDepositSwitchId
  , depositSwitchAltCreateResponseRequestId
  }

-- ** DepositSwitchCreateRequest
-- | DepositSwitchCreateRequest
-- DepositSwitchCreateRequest defines the request schema for `/deposit_switch/create`
data DepositSwitchCreateRequest = DepositSwitchCreateRequest
  { depositSwitchCreateRequestClientId :: !(Maybe Text) -- ^ "client_id" - Your Plaid API &#x60;client_id&#x60;.
  , depositSwitchCreateRequestSecret :: !(Maybe Text) -- ^ "secret" - Your Plaid API &#x60;secret&#x60;.
  , depositSwitchCreateRequestTargetAccessToken :: !(AccessToken) -- ^ /Required/ "target_access_token" - Access token for the target Item, typically provided in the Import Item response.
  , depositSwitchCreateRequestTargetAccountId :: !(Text) -- ^ /Required/ "target_account_id" - Plaid Account ID that specifies the target bank account. This account will become the recipient for a user&#39;s direct deposit.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DepositSwitchCreateRequest
instance A.FromJSON DepositSwitchCreateRequest where
  parseJSON = A.withObject "DepositSwitchCreateRequest" $ \o ->
    DepositSwitchCreateRequest
      <$> (o .:? "client_id")
      <*> (o .:? "secret")
      <*> (o .:  "target_access_token")
      <*> (o .:  "target_account_id")

-- | ToJSON DepositSwitchCreateRequest
instance A.ToJSON DepositSwitchCreateRequest where
  toJSON DepositSwitchCreateRequest {..} =
   _omitNulls
      [ "client_id" .= depositSwitchCreateRequestClientId
      , "secret" .= depositSwitchCreateRequestSecret
      , "target_access_token" .= depositSwitchCreateRequestTargetAccessToken
      , "target_account_id" .= depositSwitchCreateRequestTargetAccountId
      ]


-- | Construct a value of type 'DepositSwitchCreateRequest' (by applying it's required fields, if any)
mkDepositSwitchCreateRequest
  :: AccessToken -- ^ 'depositSwitchCreateRequestTargetAccessToken': Access token for the target Item, typically provided in the Import Item response.
  -> Text -- ^ 'depositSwitchCreateRequestTargetAccountId': Plaid Account ID that specifies the target bank account. This account will become the recipient for a user's direct deposit.
  -> DepositSwitchCreateRequest
mkDepositSwitchCreateRequest depositSwitchCreateRequestTargetAccessToken depositSwitchCreateRequestTargetAccountId =
  DepositSwitchCreateRequest
  { depositSwitchCreateRequestClientId = Nothing
  , depositSwitchCreateRequestSecret = Nothing
  , depositSwitchCreateRequestTargetAccessToken
  , depositSwitchCreateRequestTargetAccountId
  }

-- ** DepositSwitchCreateResponse
-- | DepositSwitchCreateResponse
-- DepositSwitchCreateResponse defines the response schema for `/deposit_switch/create`
data DepositSwitchCreateResponse = DepositSwitchCreateResponse
  { depositSwitchCreateResponseDepositSwitchId :: !(Text) -- ^ /Required/ "deposit_switch_id" - ID of the deposit switch. This ID is persisted throughout the lifetime of the deposit switch.
  , depositSwitchCreateResponseRequestId :: !(Text) -- ^ /Required/ "request_id" - A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DepositSwitchCreateResponse
instance A.FromJSON DepositSwitchCreateResponse where
  parseJSON = A.withObject "DepositSwitchCreateResponse" $ \o ->
    DepositSwitchCreateResponse
      <$> (o .:  "deposit_switch_id")
      <*> (o .:  "request_id")

-- | ToJSON DepositSwitchCreateResponse
instance A.ToJSON DepositSwitchCreateResponse where
  toJSON DepositSwitchCreateResponse {..} =
   _omitNulls
      [ "deposit_switch_id" .= depositSwitchCreateResponseDepositSwitchId
      , "request_id" .= depositSwitchCreateResponseRequestId
      ]


-- | Construct a value of type 'DepositSwitchCreateResponse' (by applying it's required fields, if any)
mkDepositSwitchCreateResponse
  :: Text -- ^ 'depositSwitchCreateResponseDepositSwitchId': ID of the deposit switch. This ID is persisted throughout the lifetime of the deposit switch.
  -> Text -- ^ 'depositSwitchCreateResponseRequestId': A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  -> DepositSwitchCreateResponse
mkDepositSwitchCreateResponse depositSwitchCreateResponseDepositSwitchId depositSwitchCreateResponseRequestId =
  DepositSwitchCreateResponse
  { depositSwitchCreateResponseDepositSwitchId
  , depositSwitchCreateResponseRequestId
  }

-- ** DepositSwitchGetRequest
-- | DepositSwitchGetRequest
-- DepositSwitchGetRequest
-- 
-- DepositSwitchGetRequest defines the request schema for `/deposit_switch/get`
data DepositSwitchGetRequest = DepositSwitchGetRequest
  { depositSwitchGetRequestClientId :: !(Maybe Text) -- ^ "client_id" - Your Plaid API &#x60;client_id&#x60;.
  , depositSwitchGetRequestSecret :: !(Maybe Text) -- ^ "secret" - Your Plaid API &#x60;secret&#x60;.
  , depositSwitchGetRequestDepositSwitchId :: !(Text) -- ^ /Required/ "deposit_switch_id" - The ID of the deposit switch
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DepositSwitchGetRequest
instance A.FromJSON DepositSwitchGetRequest where
  parseJSON = A.withObject "DepositSwitchGetRequest" $ \o ->
    DepositSwitchGetRequest
      <$> (o .:? "client_id")
      <*> (o .:? "secret")
      <*> (o .:  "deposit_switch_id")

-- | ToJSON DepositSwitchGetRequest
instance A.ToJSON DepositSwitchGetRequest where
  toJSON DepositSwitchGetRequest {..} =
   _omitNulls
      [ "client_id" .= depositSwitchGetRequestClientId
      , "secret" .= depositSwitchGetRequestSecret
      , "deposit_switch_id" .= depositSwitchGetRequestDepositSwitchId
      ]


-- | Construct a value of type 'DepositSwitchGetRequest' (by applying it's required fields, if any)
mkDepositSwitchGetRequest
  :: Text -- ^ 'depositSwitchGetRequestDepositSwitchId': The ID of the deposit switch
  -> DepositSwitchGetRequest
mkDepositSwitchGetRequest depositSwitchGetRequestDepositSwitchId =
  DepositSwitchGetRequest
  { depositSwitchGetRequestClientId = Nothing
  , depositSwitchGetRequestSecret = Nothing
  , depositSwitchGetRequestDepositSwitchId
  }

-- ** DepositSwitchGetResponse
-- | DepositSwitchGetResponse
-- DepositSwitchGetResponse
-- 
-- DepositSwitchGetResponse defines the response schema for `/deposit_switch/get`
data DepositSwitchGetResponse = DepositSwitchGetResponse
  { depositSwitchGetResponseDepositSwitchId :: !(Text) -- ^ /Required/ "deposit_switch_id" - The ID of the deposit switch
  , depositSwitchGetResponseTargetAccountId :: !(Text) -- ^ /Required/ "target_account_id" - The ID of the bank account the direct deposit was switched to
  , depositSwitchGetResponseTargetItemId :: !(ItemId) -- ^ /Required/ "target_item_id" - The ID of the Item the direct deposit was switched to.
  , depositSwitchGetResponseState :: !(E'State) -- ^ /Required/ "state" - The state of the deposit switch.
  , depositSwitchGetResponseAccountHasMultipleAllocations :: !(Bool) -- ^ /Required/ "account_has_multiple_allocations" - When &#x60;true&#x60;, user’s direct deposit goes to multiple banks. When false, user’s direct deposit only goes to the target account. Always &#x60;null&#x60; if the deposit switch has not been completed.
  , depositSwitchGetResponseIsAllocatedRemainder :: !(Bool) -- ^ /Required/ "is_allocated_remainder" - When &#x60;true&#x60;, the target account is allocated the remainder of direct deposit after all other allocations have been deducted. When &#x60;false&#x60;, user’s direct deposit is allocated as a percent or amount. Always &#x60;null&#x60; if the deposit switch has not been completed.
  , depositSwitchGetResponsePercentAllocated :: !(Double) -- ^ /Required/ "percent_allocated" - The percentage of direct deposit allocated to the target account. Always &#x60;null&#x60; if the target account is not allocated a percentage or if the deposit switch has not been completed or if &#x60;is_allocated_remainder&#x60; is true.
  , depositSwitchGetResponseAmountAllocated :: !(Double) -- ^ /Required/ "amount_allocated" - The dollar amount of direct deposit allocated to the target account. Always &#x60;null&#x60; if the target account is not allocated an amount or if the deposit switch has not been completed.
  , depositSwitchGetResponseDateCreated :: !(Date) -- ^ /Required/ "date_created" - ISO8601 date the deposit switch was created.
  , depositSwitchGetResponseDateCompleted :: !(Date) -- ^ /Required/ "date_completed" - ISO8601 date the deposit switch was completed. Always &#x60;null&#x60; if the deposit switch has not been completed.
  , depositSwitchGetResponseRequestId :: !(Text) -- ^ /Required/ "request_id" - A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DepositSwitchGetResponse
instance A.FromJSON DepositSwitchGetResponse where
  parseJSON = A.withObject "DepositSwitchGetResponse" $ \o ->
    DepositSwitchGetResponse
      <$> (o .:  "deposit_switch_id")
      <*> (o .:  "target_account_id")
      <*> (o .:  "target_item_id")
      <*> (o .:  "state")
      <*> (o .:  "account_has_multiple_allocations")
      <*> (o .:  "is_allocated_remainder")
      <*> (o .:  "percent_allocated")
      <*> (o .:  "amount_allocated")
      <*> (o .:  "date_created")
      <*> (o .:  "date_completed")
      <*> (o .:  "request_id")

-- | ToJSON DepositSwitchGetResponse
instance A.ToJSON DepositSwitchGetResponse where
  toJSON DepositSwitchGetResponse {..} =
   _omitNulls
      [ "deposit_switch_id" .= depositSwitchGetResponseDepositSwitchId
      , "target_account_id" .= depositSwitchGetResponseTargetAccountId
      , "target_item_id" .= depositSwitchGetResponseTargetItemId
      , "state" .= depositSwitchGetResponseState
      , "account_has_multiple_allocations" .= depositSwitchGetResponseAccountHasMultipleAllocations
      , "is_allocated_remainder" .= depositSwitchGetResponseIsAllocatedRemainder
      , "percent_allocated" .= depositSwitchGetResponsePercentAllocated
      , "amount_allocated" .= depositSwitchGetResponseAmountAllocated
      , "date_created" .= depositSwitchGetResponseDateCreated
      , "date_completed" .= depositSwitchGetResponseDateCompleted
      , "request_id" .= depositSwitchGetResponseRequestId
      ]


-- | Construct a value of type 'DepositSwitchGetResponse' (by applying it's required fields, if any)
mkDepositSwitchGetResponse
  :: Text -- ^ 'depositSwitchGetResponseDepositSwitchId': The ID of the deposit switch
  -> Text -- ^ 'depositSwitchGetResponseTargetAccountId': The ID of the bank account the direct deposit was switched to
  -> ItemId -- ^ 'depositSwitchGetResponseTargetItemId': The ID of the Item the direct deposit was switched to.
  -> E'State -- ^ 'depositSwitchGetResponseState': The state of the deposit switch.
  -> Bool -- ^ 'depositSwitchGetResponseAccountHasMultipleAllocations': When `true`, user’s direct deposit goes to multiple banks. When false, user’s direct deposit only goes to the target account. Always `null` if the deposit switch has not been completed.
  -> Bool -- ^ 'depositSwitchGetResponseIsAllocatedRemainder': When `true`, the target account is allocated the remainder of direct deposit after all other allocations have been deducted. When `false`, user’s direct deposit is allocated as a percent or amount. Always `null` if the deposit switch has not been completed.
  -> Double -- ^ 'depositSwitchGetResponsePercentAllocated': The percentage of direct deposit allocated to the target account. Always `null` if the target account is not allocated a percentage or if the deposit switch has not been completed or if `is_allocated_remainder` is true.
  -> Double -- ^ 'depositSwitchGetResponseAmountAllocated': The dollar amount of direct deposit allocated to the target account. Always `null` if the target account is not allocated an amount or if the deposit switch has not been completed.
  -> Date -- ^ 'depositSwitchGetResponseDateCreated': ISO8601 date the deposit switch was created.
  -> Date -- ^ 'depositSwitchGetResponseDateCompleted': ISO8601 date the deposit switch was completed. Always `null` if the deposit switch has not been completed.
  -> Text -- ^ 'depositSwitchGetResponseRequestId': A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  -> DepositSwitchGetResponse
mkDepositSwitchGetResponse depositSwitchGetResponseDepositSwitchId depositSwitchGetResponseTargetAccountId depositSwitchGetResponseTargetItemId depositSwitchGetResponseState depositSwitchGetResponseAccountHasMultipleAllocations depositSwitchGetResponseIsAllocatedRemainder depositSwitchGetResponsePercentAllocated depositSwitchGetResponseAmountAllocated depositSwitchGetResponseDateCreated depositSwitchGetResponseDateCompleted depositSwitchGetResponseRequestId =
  DepositSwitchGetResponse
  { depositSwitchGetResponseDepositSwitchId
  , depositSwitchGetResponseTargetAccountId
  , depositSwitchGetResponseTargetItemId
  , depositSwitchGetResponseState
  , depositSwitchGetResponseAccountHasMultipleAllocations
  , depositSwitchGetResponseIsAllocatedRemainder
  , depositSwitchGetResponsePercentAllocated
  , depositSwitchGetResponseAmountAllocated
  , depositSwitchGetResponseDateCreated
  , depositSwitchGetResponseDateCompleted
  , depositSwitchGetResponseRequestId
  }

-- ** DepositSwitchTargetAccount
-- | DepositSwitchTargetAccount
-- DepositSwitchTargetAccount
-- 
data DepositSwitchTargetAccount = DepositSwitchTargetAccount
  { depositSwitchTargetAccountAccountNumber :: !(Text) -- ^ /Required/ "account_number" - Account number for deposit switch destination
  , depositSwitchTargetAccountRoutingNumber :: !(Text) -- ^ /Required/ "routing_number" - Routing number for deposit switch destination
  , depositSwitchTargetAccountAccountName :: !(Text) -- ^ /Required/ "account_name" - The name of the deposit switch destination account, as it will be displayed to the end user in the Deposit Switch interface. It is not required to match the name used in online banking.
  , depositSwitchTargetAccountAccountSubtype :: !(E'AccountSubtype) -- ^ /Required/ "account_subtype" - The account subtype of the account, either &#x60;checking&#x60; or &#x60;savings&#x60;.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DepositSwitchTargetAccount
instance A.FromJSON DepositSwitchTargetAccount where
  parseJSON = A.withObject "DepositSwitchTargetAccount" $ \o ->
    DepositSwitchTargetAccount
      <$> (o .:  "account_number")
      <*> (o .:  "routing_number")
      <*> (o .:  "account_name")
      <*> (o .:  "account_subtype")

-- | ToJSON DepositSwitchTargetAccount
instance A.ToJSON DepositSwitchTargetAccount where
  toJSON DepositSwitchTargetAccount {..} =
   _omitNulls
      [ "account_number" .= depositSwitchTargetAccountAccountNumber
      , "routing_number" .= depositSwitchTargetAccountRoutingNumber
      , "account_name" .= depositSwitchTargetAccountAccountName
      , "account_subtype" .= depositSwitchTargetAccountAccountSubtype
      ]


-- | Construct a value of type 'DepositSwitchTargetAccount' (by applying it's required fields, if any)
mkDepositSwitchTargetAccount
  :: Text -- ^ 'depositSwitchTargetAccountAccountNumber': Account number for deposit switch destination
  -> Text -- ^ 'depositSwitchTargetAccountRoutingNumber': Routing number for deposit switch destination
  -> Text -- ^ 'depositSwitchTargetAccountAccountName': The name of the deposit switch destination account, as it will be displayed to the end user in the Deposit Switch interface. It is not required to match the name used in online banking.
  -> E'AccountSubtype -- ^ 'depositSwitchTargetAccountAccountSubtype': The account subtype of the account, either `checking` or `savings`.
  -> DepositSwitchTargetAccount
mkDepositSwitchTargetAccount depositSwitchTargetAccountAccountNumber depositSwitchTargetAccountRoutingNumber depositSwitchTargetAccountAccountName depositSwitchTargetAccountAccountSubtype =
  DepositSwitchTargetAccount
  { depositSwitchTargetAccountAccountNumber
  , depositSwitchTargetAccountRoutingNumber
  , depositSwitchTargetAccountAccountName
  , depositSwitchTargetAccountAccountSubtype
  }

-- ** DepositSwitchTargetUser
-- | DepositSwitchTargetUser
-- DepositSwitchTargetUser
-- 
data DepositSwitchTargetUser = DepositSwitchTargetUser
  { depositSwitchTargetUserGivenName :: !(Text) -- ^ /Required/ "given_name" - The given name (first name) of the user.
  , depositSwitchTargetUserFamilyName :: !(Text) -- ^ /Required/ "family_name" - The family name (last name) of the user.
  , depositSwitchTargetUserPhone :: !(Text) -- ^ /Required/ "phone" - The phone number of the user. The endpoint can accept a variety of phone number formats, including E.164.
  , depositSwitchTargetUserEmail :: !(Text) -- ^ /Required/ "email" - The email address of the user.
  , depositSwitchTargetUserAddress :: !(Maybe DepositSwitchAddressData) -- ^ "address"
  , depositSwitchTargetUserTaxPayerId :: !(Maybe Text) -- ^ "tax_payer_id" - The taxpayer ID of the user, generally their SSN, EIN, or TIN.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DepositSwitchTargetUser
instance A.FromJSON DepositSwitchTargetUser where
  parseJSON = A.withObject "DepositSwitchTargetUser" $ \o ->
    DepositSwitchTargetUser
      <$> (o .:  "given_name")
      <*> (o .:  "family_name")
      <*> (o .:  "phone")
      <*> (o .:  "email")
      <*> (o .:? "address")
      <*> (o .:? "tax_payer_id")

-- | ToJSON DepositSwitchTargetUser
instance A.ToJSON DepositSwitchTargetUser where
  toJSON DepositSwitchTargetUser {..} =
   _omitNulls
      [ "given_name" .= depositSwitchTargetUserGivenName
      , "family_name" .= depositSwitchTargetUserFamilyName
      , "phone" .= depositSwitchTargetUserPhone
      , "email" .= depositSwitchTargetUserEmail
      , "address" .= depositSwitchTargetUserAddress
      , "tax_payer_id" .= depositSwitchTargetUserTaxPayerId
      ]


-- | Construct a value of type 'DepositSwitchTargetUser' (by applying it's required fields, if any)
mkDepositSwitchTargetUser
  :: Text -- ^ 'depositSwitchTargetUserGivenName': The given name (first name) of the user.
  -> Text -- ^ 'depositSwitchTargetUserFamilyName': The family name (last name) of the user.
  -> Text -- ^ 'depositSwitchTargetUserPhone': The phone number of the user. The endpoint can accept a variety of phone number formats, including E.164.
  -> Text -- ^ 'depositSwitchTargetUserEmail': The email address of the user.
  -> DepositSwitchTargetUser
mkDepositSwitchTargetUser depositSwitchTargetUserGivenName depositSwitchTargetUserFamilyName depositSwitchTargetUserPhone depositSwitchTargetUserEmail =
  DepositSwitchTargetUser
  { depositSwitchTargetUserGivenName
  , depositSwitchTargetUserFamilyName
  , depositSwitchTargetUserPhone
  , depositSwitchTargetUserEmail
  , depositSwitchTargetUserAddress = Nothing
  , depositSwitchTargetUserTaxPayerId = Nothing
  }

-- ** DepositSwitchTokenCreateRequest
-- | DepositSwitchTokenCreateRequest
-- DepositSwitchTokenCreateRequest defines the request schema for `/deposit_switch/token/create`
data DepositSwitchTokenCreateRequest = DepositSwitchTokenCreateRequest
  { depositSwitchTokenCreateRequestClientId :: !(Maybe Text) -- ^ "client_id" - Your Plaid API &#x60;client_id&#x60;.
  , depositSwitchTokenCreateRequestSecret :: !(Maybe Text) -- ^ "secret" - Your Plaid API &#x60;secret&#x60;.
  , depositSwitchTokenCreateRequestDepositSwitchId :: !(Text) -- ^ /Required/ "deposit_switch_id" - The ID of the deposit switch
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DepositSwitchTokenCreateRequest
instance A.FromJSON DepositSwitchTokenCreateRequest where
  parseJSON = A.withObject "DepositSwitchTokenCreateRequest" $ \o ->
    DepositSwitchTokenCreateRequest
      <$> (o .:? "client_id")
      <*> (o .:? "secret")
      <*> (o .:  "deposit_switch_id")

-- | ToJSON DepositSwitchTokenCreateRequest
instance A.ToJSON DepositSwitchTokenCreateRequest where
  toJSON DepositSwitchTokenCreateRequest {..} =
   _omitNulls
      [ "client_id" .= depositSwitchTokenCreateRequestClientId
      , "secret" .= depositSwitchTokenCreateRequestSecret
      , "deposit_switch_id" .= depositSwitchTokenCreateRequestDepositSwitchId
      ]


-- | Construct a value of type 'DepositSwitchTokenCreateRequest' (by applying it's required fields, if any)
mkDepositSwitchTokenCreateRequest
  :: Text -- ^ 'depositSwitchTokenCreateRequestDepositSwitchId': The ID of the deposit switch
  -> DepositSwitchTokenCreateRequest
mkDepositSwitchTokenCreateRequest depositSwitchTokenCreateRequestDepositSwitchId =
  DepositSwitchTokenCreateRequest
  { depositSwitchTokenCreateRequestClientId = Nothing
  , depositSwitchTokenCreateRequestSecret = Nothing
  , depositSwitchTokenCreateRequestDepositSwitchId
  }

-- ** DepositSwitchTokenCreateResponse
-- | DepositSwitchTokenCreateResponse
-- DepositSwitchTokenCreateResponse defines the response schema for `/deposit_switch/token/create`
data DepositSwitchTokenCreateResponse = DepositSwitchTokenCreateResponse
  { depositSwitchTokenCreateResponseDepositSwitchToken :: !(Text) -- ^ /Required/ "deposit_switch_token" - Deposit switch token, used to initialize Link for the Deposit Switch product
  , depositSwitchTokenCreateResponseDepositSwitchTokenExpirationTime :: !(Text) -- ^ /Required/ "deposit_switch_token_expiration_time" - Expiration time of the token, in ISO8601 format
  , depositSwitchTokenCreateResponseRequestId :: !(Text) -- ^ /Required/ "request_id" - A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DepositSwitchTokenCreateResponse
instance A.FromJSON DepositSwitchTokenCreateResponse where
  parseJSON = A.withObject "DepositSwitchTokenCreateResponse" $ \o ->
    DepositSwitchTokenCreateResponse
      <$> (o .:  "deposit_switch_token")
      <*> (o .:  "deposit_switch_token_expiration_time")
      <*> (o .:  "request_id")

-- | ToJSON DepositSwitchTokenCreateResponse
instance A.ToJSON DepositSwitchTokenCreateResponse where
  toJSON DepositSwitchTokenCreateResponse {..} =
   _omitNulls
      [ "deposit_switch_token" .= depositSwitchTokenCreateResponseDepositSwitchToken
      , "deposit_switch_token_expiration_time" .= depositSwitchTokenCreateResponseDepositSwitchTokenExpirationTime
      , "request_id" .= depositSwitchTokenCreateResponseRequestId
      ]


-- | Construct a value of type 'DepositSwitchTokenCreateResponse' (by applying it's required fields, if any)
mkDepositSwitchTokenCreateResponse
  :: Text -- ^ 'depositSwitchTokenCreateResponseDepositSwitchToken': Deposit switch token, used to initialize Link for the Deposit Switch product
  -> Text -- ^ 'depositSwitchTokenCreateResponseDepositSwitchTokenExpirationTime': Expiration time of the token, in ISO8601 format
  -> Text -- ^ 'depositSwitchTokenCreateResponseRequestId': A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  -> DepositSwitchTokenCreateResponse
mkDepositSwitchTokenCreateResponse depositSwitchTokenCreateResponseDepositSwitchToken depositSwitchTokenCreateResponseDepositSwitchTokenExpirationTime depositSwitchTokenCreateResponseRequestId =
  DepositSwitchTokenCreateResponse
  { depositSwitchTokenCreateResponseDepositSwitchToken
  , depositSwitchTokenCreateResponseDepositSwitchTokenExpirationTime
  , depositSwitchTokenCreateResponseRequestId
  }

-- ** DepositoryFilter
-- | DepositoryFilter
-- DepositoryFilter
-- 
-- A filter to apply to `depository`-type accounts
data DepositoryFilter = DepositoryFilter
  { depositoryFilterAccountSubtypes :: !([AccountSubtype]) -- ^ /Required/ "account_subtypes" - An array of account subtypes to display in Link. If not specified, all account subtypes will be shown. For a full list of valid types and subtypes, see the [Account schema](/docs/api/accounts#accounts-schema). 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DepositoryFilter
instance A.FromJSON DepositoryFilter where
  parseJSON = A.withObject "DepositoryFilter" $ \o ->
    DepositoryFilter
      <$> (o .:  "account_subtypes")

-- | ToJSON DepositoryFilter
instance A.ToJSON DepositoryFilter where
  toJSON DepositoryFilter {..} =
   _omitNulls
      [ "account_subtypes" .= depositoryFilterAccountSubtypes
      ]


-- | Construct a value of type 'DepositoryFilter' (by applying it's required fields, if any)
mkDepositoryFilter
  :: [AccountSubtype] -- ^ 'depositoryFilterAccountSubtypes': An array of account subtypes to display in Link. If not specified, all account subtypes will be shown. For a full list of valid types and subtypes, see the [Account schema](/docs/api/accounts#accounts-schema). 
  -> DepositoryFilter
mkDepositoryFilter depositoryFilterAccountSubtypes =
  DepositoryFilter
  { depositoryFilterAccountSubtypes
  }

-- ** Email
-- | Email
-- Email
-- 
-- An object representing an email address
data Email = Email
  { emailData :: !(Text) -- ^ /Required/ "data" - The email address.
  , emailPrimary :: !(Bool) -- ^ /Required/ "primary" - When &#x60;true&#x60;, identifies the email address as the primary email on an account.
  , emailType :: !(E'Type2) -- ^ /Required/ "type" - The type of email account as described by the financial institution.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Email
instance A.FromJSON Email where
  parseJSON = A.withObject "Email" $ \o ->
    Email
      <$> (o .:  "data")
      <*> (o .:  "primary")
      <*> (o .:  "type")

-- | ToJSON Email
instance A.ToJSON Email where
  toJSON Email {..} =
   _omitNulls
      [ "data" .= emailData
      , "primary" .= emailPrimary
      , "type" .= emailType
      ]


-- | Construct a value of type 'Email' (by applying it's required fields, if any)
mkEmail
  :: Text -- ^ 'emailData': The email address.
  -> Bool -- ^ 'emailPrimary': When `true`, identifies the email address as the primary email on an account.
  -> E'Type2 -- ^ 'emailType': The type of email account as described by the financial institution.
  -> Email
mkEmail emailData emailPrimary emailType =
  Email
  { emailData
  , emailPrimary
  , emailType
  }

-- ** Employee
-- | Employee
-- Employee
-- 
-- Data about the employee.
data Employee = Employee
  { employeeName :: !(Maybe Text) -- ^ "name" - The name of the employee.
  , employeeAddress :: !(Maybe NullableAddressData) -- ^ "address"
  , employeeSsnMasked :: !(Maybe Text) -- ^ "ssn_masked" - The SSN of the employee, with all but the last 4 digits masked out. For example: \&quot;XXX-XX-1111\&quot;.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Employee
instance A.FromJSON Employee where
  parseJSON = A.withObject "Employee" $ \o ->
    Employee
      <$> (o .:? "name")
      <*> (o .:? "address")
      <*> (o .:? "ssn_masked")

-- | ToJSON Employee
instance A.ToJSON Employee where
  toJSON Employee {..} =
   _omitNulls
      [ "name" .= employeeName
      , "address" .= employeeAddress
      , "ssn_masked" .= employeeSsnMasked
      ]


-- | Construct a value of type 'Employee' (by applying it's required fields, if any)
mkEmployee
  :: Employee
mkEmployee =
  Employee
  { employeeName = Nothing
  , employeeAddress = Nothing
  , employeeSsnMasked = Nothing
  }

-- ** EmployeeIncomeSummaryFieldString
-- | EmployeeIncomeSummaryFieldString
data EmployeeIncomeSummaryFieldString = EmployeeIncomeSummaryFieldString
  { employeeIncomeSummaryFieldStringValue :: !(Text) -- ^ /Required/ "value" - The value of the field.
  , employeeIncomeSummaryFieldStringVerificationStatus :: !(VerificationStatus) -- ^ /Required/ "verification_status"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EmployeeIncomeSummaryFieldString
instance A.FromJSON EmployeeIncomeSummaryFieldString where
  parseJSON = A.withObject "EmployeeIncomeSummaryFieldString" $ \o ->
    EmployeeIncomeSummaryFieldString
      <$> (o .:  "value")
      <*> (o .:  "verification_status")

-- | ToJSON EmployeeIncomeSummaryFieldString
instance A.ToJSON EmployeeIncomeSummaryFieldString where
  toJSON EmployeeIncomeSummaryFieldString {..} =
   _omitNulls
      [ "value" .= employeeIncomeSummaryFieldStringValue
      , "verification_status" .= employeeIncomeSummaryFieldStringVerificationStatus
      ]


-- | Construct a value of type 'EmployeeIncomeSummaryFieldString' (by applying it's required fields, if any)
mkEmployeeIncomeSummaryFieldString
  :: Text -- ^ 'employeeIncomeSummaryFieldStringValue': The value of the field.
  -> VerificationStatus -- ^ 'employeeIncomeSummaryFieldStringVerificationStatus' 
  -> EmployeeIncomeSummaryFieldString
mkEmployeeIncomeSummaryFieldString employeeIncomeSummaryFieldStringValue employeeIncomeSummaryFieldStringVerificationStatus =
  EmployeeIncomeSummaryFieldString
  { employeeIncomeSummaryFieldStringValue
  , employeeIncomeSummaryFieldStringVerificationStatus
  }

-- ** Employer
-- | Employer
-- Employer
-- 
-- Data about the employer.
data Employer = Employer
  { employerEmployerId :: !(Text) -- ^ /Required/ "employer_id" - Plaid&#39;s unique identifier for the employer.
  , employerName :: !(Text) -- ^ /Required/ "name" - The name of the employer
  , employerAddress :: !(Maybe NullableAddressData) -- ^ "address"
  , employerConfidenceScore :: !(Maybe Double) -- ^ "confidence_score" - A number from 0 to 1 indicating Plaid&#39;s level of confidence in the pairing between the employer and the institution (not yet implemented).
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Employer
instance A.FromJSON Employer where
  parseJSON = A.withObject "Employer" $ \o ->
    Employer
      <$> (o .:  "employer_id")
      <*> (o .:  "name")
      <*> (o .:? "address")
      <*> (o .:? "confidence_score")

-- | ToJSON Employer
instance A.ToJSON Employer where
  toJSON Employer {..} =
   _omitNulls
      [ "employer_id" .= employerEmployerId
      , "name" .= employerName
      , "address" .= employerAddress
      , "confidence_score" .= employerConfidenceScore
      ]


-- | Construct a value of type 'Employer' (by applying it's required fields, if any)
mkEmployer
  :: Text -- ^ 'employerEmployerId': Plaid's unique identifier for the employer.
  -> Text -- ^ 'employerName': The name of the employer
  -> Employer
mkEmployer employerEmployerId employerName =
  Employer
  { employerEmployerId
  , employerName
  , employerAddress = Nothing
  , employerConfidenceScore = Nothing
  }

-- ** EmployerIncomeSummaryFieldString
-- | EmployerIncomeSummaryFieldString
data EmployerIncomeSummaryFieldString = EmployerIncomeSummaryFieldString
  { employerIncomeSummaryFieldStringValue :: !(Text) -- ^ /Required/ "value" - The value of the field.
  , employerIncomeSummaryFieldStringVerificationStatus :: !(VerificationStatus) -- ^ /Required/ "verification_status"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EmployerIncomeSummaryFieldString
instance A.FromJSON EmployerIncomeSummaryFieldString where
  parseJSON = A.withObject "EmployerIncomeSummaryFieldString" $ \o ->
    EmployerIncomeSummaryFieldString
      <$> (o .:  "value")
      <*> (o .:  "verification_status")

-- | ToJSON EmployerIncomeSummaryFieldString
instance A.ToJSON EmployerIncomeSummaryFieldString where
  toJSON EmployerIncomeSummaryFieldString {..} =
   _omitNulls
      [ "value" .= employerIncomeSummaryFieldStringValue
      , "verification_status" .= employerIncomeSummaryFieldStringVerificationStatus
      ]


-- | Construct a value of type 'EmployerIncomeSummaryFieldString' (by applying it's required fields, if any)
mkEmployerIncomeSummaryFieldString
  :: Text -- ^ 'employerIncomeSummaryFieldStringValue': The value of the field.
  -> VerificationStatus -- ^ 'employerIncomeSummaryFieldStringVerificationStatus' 
  -> EmployerIncomeSummaryFieldString
mkEmployerIncomeSummaryFieldString employerIncomeSummaryFieldStringValue employerIncomeSummaryFieldStringVerificationStatus =
  EmployerIncomeSummaryFieldString
  { employerIncomeSummaryFieldStringValue
  , employerIncomeSummaryFieldStringVerificationStatus
  }

-- ** EmployersSearchRequest
-- | EmployersSearchRequest
-- EmployersSearchRequest
-- 
-- EmployersSearchRequest defines the request schema for `/employers/search`.
data EmployersSearchRequest = EmployersSearchRequest
  { employersSearchRequestClientId :: !(Maybe Text) -- ^ "client_id" - Your Plaid API &#x60;client_id&#x60;.
  , employersSearchRequestSecret :: !(Maybe Text) -- ^ "secret" - Your Plaid API &#x60;secret&#x60;.
  , employersSearchRequestQuery :: !(Text) -- ^ /Required/ "query" - The employer name to be searched for.
  , employersSearchRequestProducts :: !([Text]) -- ^ /Required/ "products" - The Plaid products the returned employers should support. Currently, this field must be set to &#x60;\&quot;deposit_switch\&quot;&#x60;.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EmployersSearchRequest
instance A.FromJSON EmployersSearchRequest where
  parseJSON = A.withObject "EmployersSearchRequest" $ \o ->
    EmployersSearchRequest
      <$> (o .:? "client_id")
      <*> (o .:? "secret")
      <*> (o .:  "query")
      <*> (o .:  "products")

-- | ToJSON EmployersSearchRequest
instance A.ToJSON EmployersSearchRequest where
  toJSON EmployersSearchRequest {..} =
   _omitNulls
      [ "client_id" .= employersSearchRequestClientId
      , "secret" .= employersSearchRequestSecret
      , "query" .= employersSearchRequestQuery
      , "products" .= employersSearchRequestProducts
      ]


-- | Construct a value of type 'EmployersSearchRequest' (by applying it's required fields, if any)
mkEmployersSearchRequest
  :: Text -- ^ 'employersSearchRequestQuery': The employer name to be searched for.
  -> [Text] -- ^ 'employersSearchRequestProducts': The Plaid products the returned employers should support. Currently, this field must be set to `\"deposit_switch\"`.
  -> EmployersSearchRequest
mkEmployersSearchRequest employersSearchRequestQuery employersSearchRequestProducts =
  EmployersSearchRequest
  { employersSearchRequestClientId = Nothing
  , employersSearchRequestSecret = Nothing
  , employersSearchRequestQuery
  , employersSearchRequestProducts
  }

-- ** EmployersSearchResponse
-- | EmployersSearchResponse
-- EmployersSearchResponse
-- 
-- EmployersSearchResponse defines the response schema for `/employers/search`.
data EmployersSearchResponse = EmployersSearchResponse
  { employersSearchResponseEmployers :: !([Employer]) -- ^ /Required/ "employers" - A list of employers matching the search criteria.
  , employersSearchResponseRequestId :: !(Text) -- ^ /Required/ "request_id" - A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EmployersSearchResponse
instance A.FromJSON EmployersSearchResponse where
  parseJSON = A.withObject "EmployersSearchResponse" $ \o ->
    EmployersSearchResponse
      <$> (o .:  "employers")
      <*> (o .:  "request_id")

-- | ToJSON EmployersSearchResponse
instance A.ToJSON EmployersSearchResponse where
  toJSON EmployersSearchResponse {..} =
   _omitNulls
      [ "employers" .= employersSearchResponseEmployers
      , "request_id" .= employersSearchResponseRequestId
      ]


-- | Construct a value of type 'EmployersSearchResponse' (by applying it's required fields, if any)
mkEmployersSearchResponse
  :: [Employer] -- ^ 'employersSearchResponseEmployers': A list of employers matching the search criteria.
  -> Text -- ^ 'employersSearchResponseRequestId': A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  -> EmployersSearchResponse
mkEmployersSearchResponse employersSearchResponseEmployers employersSearchResponseRequestId =
  EmployersSearchResponse
  { employersSearchResponseEmployers
  , employersSearchResponseRequestId
  }

-- ** Error
-- | Error
-- Error
-- 
-- We use standard HTTP response codes for success and failure notifications, and our errors are further classified by `error_type`. In general, 200 HTTP codes correspond to success, 40X codes are for developer- or user-related failures, and 50X codes are for Plaid-related issues.  Error fields will be `null` if no error has occurred.
data Error = Error
  { errorErrorType :: !(E'ErrorType) -- ^ /Required/ "error_type" - A broad categorization of the error. Safe for programatic use.
  , errorErrorCode :: !(Text) -- ^ /Required/ "error_code" - The particular error code. Safe for programmatic use.
  , errorErrorMessage :: !(Text) -- ^ /Required/ "error_message" - A developer-friendly representation of the error code. This may change over time and is not safe for programmatic use.
  , errorDisplayMessage :: !(Maybe Text) -- ^ "display_message" - A user-friendly representation of the error code. &#x60;null&#x60; if the error is not related to user action.  This may change over time and is not safe for programmatic use.
  , errorRequestId :: !(Maybe Text) -- ^ /Required/ "request_id" - A unique identifying the request, to be used for troubleshooting purposes. This field will be omitted in errors provided by webhooks.
  , errorCauses :: !(Maybe [A.Value]) -- ^ "causes" - In the Assets product, a request can pertain to more than one Item. If an error is returned for such a request, &#x60;causes&#x60; will return an array of errors containing a breakdown of these errors on the individual Item level, if any can be identified.  &#x60;causes&#x60; will only be provided for the &#x60;error_type&#x60; &#x60;ASSET_REPORT_ERROR&#x60;.
  , errorStatus :: !(Maybe Double) -- ^ "status" - The HTTP status code associated with the error. This will only be returned in the response body when the error information is provided via a webhook.
  , errorDocumentationUrl :: !(Maybe Text) -- ^ "documentation_url" - The URL of a Plaid documentation page with more information about the error
  , errorSuggestedAction :: !(Maybe Text) -- ^ "suggested_action" - Suggested steps for resolving the error
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Error
instance A.FromJSON Error where
  parseJSON = A.withObject "Error" $ \o ->
    Error
      <$> (o .:  "error_type")
      <*> (o .:  "error_code")
      <*> (o .:  "error_message")
      <*> (o .:? "display_message")
      <*> (o .:?  "request_id")
      <*> (o .:? "causes")
      <*> (o .:? "status")
      <*> (o .:? "documentation_url")
      <*> (o .:? "suggested_action")

-- | ToJSON Error
instance A.ToJSON Error where
  toJSON Error {..} =
   _omitNulls
      [ "error_type" .= errorErrorType
      , "error_code" .= errorErrorCode
      , "error_message" .= errorErrorMessage
      , "display_message" .= errorDisplayMessage
      , "request_id" .= errorRequestId
      , "causes" .= errorCauses
      , "status" .= errorStatus
      , "documentation_url" .= errorDocumentationUrl
      , "suggested_action" .= errorSuggestedAction
      ]


-- | Construct a value of type 'Error' (by applying it's required fields, if any)
mkError
  :: E'ErrorType -- ^ 'errorErrorType': A broad categorization of the error. Safe for programatic use.
  -> Text -- ^ 'errorErrorCode': The particular error code. Safe for programmatic use.
  -> Text -- ^ 'errorErrorMessage': A developer-friendly representation of the error code. This may change over time and is not safe for programmatic use.
  -> Maybe Text -- ^ 'errorRequestId': A unique identifying the request, to be used for troubleshooting purposes. This field will be omitted in errors provided by webhooks.
  -> Error
mkError errorErrorType errorErrorCode errorErrorMessage errorRequestId =
  Error
  { errorErrorType
  , errorErrorCode
  , errorErrorMessage
  , errorDisplayMessage = Nothing
  , errorRequestId
  , errorCauses = Nothing
  , errorStatus = Nothing
  , errorDocumentationUrl = Nothing
  , errorSuggestedAction = Nothing
  }

-- ** ExternalPaymentSchedule
-- | ExternalPaymentSchedule
-- ExternalPaymentSchedule
-- 
-- The schedule that the payment will be executed on. If a schedule is provided, the payment is automatically set up as a standing order. If no schedule is specified, the payment will be executed only once.
data ExternalPaymentSchedule = ExternalPaymentSchedule
  { externalPaymentScheduleInterval :: !(Text) -- ^ /Required/ "interval" - The frequency interval of the payment. Valid values are &#x60;\&quot;WEEKLY\&quot;&#x60; or &#x60;\&quot;MONTHLY\&quot;&#x60;.
  , externalPaymentScheduleIntervalExecutionDay :: !(Double) -- ^ /Required/ "interval_execution_day" - The day of the interval on which to schedule the payment.  If the payment interval is weekly, &#x60;interval_execution_day&#x60; should be an integer from 1 (Monday) to 7 (Sunday).  If the payment interval is monthly, &#x60;interval_execution_day&#x60; should be an integer indicating which day of the month to make the payment on. Integers from 1 to 28 can be used to make a payment on that day of the month. Negative integers from -1 to -5 can be used to make a payment relative to the end of the month. To make a payment on the last day of the month, use -1; to make the payment on the second-to-last day, use -2, and so on.
  , externalPaymentScheduleStartDate :: !(Date) -- ^ /Required/ "start_date" - A date in ISO 8601 format (YYYY-MM-DD). Standing order payments will begin on the first &#x60;interval_execution_day&#x60; on or after the &#x60;start_date&#x60;.  If the first &#x60;interval_execution_day&#x60; on or after the start date is also the same day that &#x60;/payment_initiation/payment/create&#x60; was called, the bank *may* make the first payment on that day, but it is not guaranteed to do so.
  , externalPaymentScheduleEndDate :: !(Maybe Date) -- ^ "end_date" - A date in ISO 8601 format (YYYY-MM-DD). Standing order payments will end on the last &#x60;interval_execution_day&#x60; on or before the &#x60;end_date&#x60;.  If the only &#x60;interval_execution_day&#x60; between the start date and the end date (inclusive) is also the same day that &#x60;/payment_initiation/payment/create&#x60; was called, the bank *may* make a payment on that day, but it is not guaranteed to do so.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExternalPaymentSchedule
instance A.FromJSON ExternalPaymentSchedule where
  parseJSON = A.withObject "ExternalPaymentSchedule" $ \o ->
    ExternalPaymentSchedule
      <$> (o .:  "interval")
      <*> (o .:  "interval_execution_day")
      <*> (o .:  "start_date")
      <*> (o .:? "end_date")

-- | ToJSON ExternalPaymentSchedule
instance A.ToJSON ExternalPaymentSchedule where
  toJSON ExternalPaymentSchedule {..} =
   _omitNulls
      [ "interval" .= externalPaymentScheduleInterval
      , "interval_execution_day" .= externalPaymentScheduleIntervalExecutionDay
      , "start_date" .= externalPaymentScheduleStartDate
      , "end_date" .= externalPaymentScheduleEndDate
      ]


-- | Construct a value of type 'ExternalPaymentSchedule' (by applying it's required fields, if any)
mkExternalPaymentSchedule
  :: Text -- ^ 'externalPaymentScheduleInterval': The frequency interval of the payment. Valid values are `\"WEEKLY\"` or `\"MONTHLY\"`.
  -> Double -- ^ 'externalPaymentScheduleIntervalExecutionDay': The day of the interval on which to schedule the payment.  If the payment interval is weekly, `interval_execution_day` should be an integer from 1 (Monday) to 7 (Sunday).  If the payment interval is monthly, `interval_execution_day` should be an integer indicating which day of the month to make the payment on. Integers from 1 to 28 can be used to make a payment on that day of the month. Negative integers from -1 to -5 can be used to make a payment relative to the end of the month. To make a payment on the last day of the month, use -1; to make the payment on the second-to-last day, use -2, and so on.
  -> Date -- ^ 'externalPaymentScheduleStartDate': A date in ISO 8601 format (YYYY-MM-DD). Standing order payments will begin on the first `interval_execution_day` on or after the `start_date`.  If the first `interval_execution_day` on or after the start date is also the same day that `/payment_initiation/payment/create` was called, the bank *may* make the first payment on that day, but it is not guaranteed to do so.
  -> ExternalPaymentSchedule
mkExternalPaymentSchedule externalPaymentScheduleInterval externalPaymentScheduleIntervalExecutionDay externalPaymentScheduleStartDate =
  ExternalPaymentSchedule
  { externalPaymentScheduleInterval
  , externalPaymentScheduleIntervalExecutionDay
  , externalPaymentScheduleStartDate
  , externalPaymentScheduleEndDate = Nothing
  }

-- ** ExternalPaymentScheduleGet
-- | ExternalPaymentScheduleGet
-- ExternalPaymentScheduleGet
-- 
-- The schedule that the payment will be executed on. If a schedule is provided, the payment is automatically set up as a standing order. If no schedule is specified, the payment will be executed only once.
data ExternalPaymentScheduleGet = ExternalPaymentScheduleGet
  { externalPaymentScheduleGetAdjustedStartDate :: !(Maybe Date) -- ^ "adjusted_start_date" - The start date sent to the bank after adjusting for holidays or weekends.  Will be provided in ISO 8601 format (YYYY-MM-DD). If the start date did not require adjustment, this field will be &#x60;null&#x60;.
  , externalPaymentScheduleGetInterval :: !(Text) -- ^ /Required/ "interval" - The frequency interval of the payment. Valid values are &#x60;\&quot;WEEKLY\&quot;&#x60; or &#x60;\&quot;MONTHLY\&quot;&#x60;.
  , externalPaymentScheduleGetIntervalExecutionDay :: !(Double) -- ^ /Required/ "interval_execution_day" - The day of the interval on which to schedule the payment.  If the payment interval is weekly, &#x60;interval_execution_day&#x60; should be an integer from 1 (Monday) to 7 (Sunday).  If the payment interval is monthly, &#x60;interval_execution_day&#x60; should be an integer indicating which day of the month to make the payment on. Integers from 1 to 28 can be used to make a payment on that day of the month. Negative integers from -1 to -5 can be used to make a payment relative to the end of the month. To make a payment on the last day of the month, use -1; to make the payment on the second-to-last day, use -2, and so on.
  , externalPaymentScheduleGetStartDate :: !(Date) -- ^ /Required/ "start_date" - A date in ISO 8601 format (YYYY-MM-DD). Standing order payments will begin on the first &#x60;interval_execution_day&#x60; on or after the &#x60;start_date&#x60;.  If the first &#x60;interval_execution_day&#x60; on or after the start date is also the same day that &#x60;/payment_initiation/payment/create&#x60; was called, the bank *may* make the first payment on that day, but it is not guaranteed to do so.
  , externalPaymentScheduleGetEndDate :: !(Maybe Date) -- ^ "end_date" - A date in ISO 8601 format (YYYY-MM-DD). Standing order payments will end on the last &#x60;interval_execution_day&#x60; on or before the &#x60;end_date&#x60;.  If the only &#x60;interval_execution_day&#x60; between the start date and the end date (inclusive) is also the same day that &#x60;/payment_initiation/payment/create&#x60; was called, the bank *may* make a payment on that day, but it is not guaranteed to do so.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExternalPaymentScheduleGet
instance A.FromJSON ExternalPaymentScheduleGet where
  parseJSON = A.withObject "ExternalPaymentScheduleGet" $ \o ->
    ExternalPaymentScheduleGet
      <$> (o .:? "adjusted_start_date")
      <*> (o .:  "interval")
      <*> (o .:  "interval_execution_day")
      <*> (o .:  "start_date")
      <*> (o .:? "end_date")

-- | ToJSON ExternalPaymentScheduleGet
instance A.ToJSON ExternalPaymentScheduleGet where
  toJSON ExternalPaymentScheduleGet {..} =
   _omitNulls
      [ "adjusted_start_date" .= externalPaymentScheduleGetAdjustedStartDate
      , "interval" .= externalPaymentScheduleGetInterval
      , "interval_execution_day" .= externalPaymentScheduleGetIntervalExecutionDay
      , "start_date" .= externalPaymentScheduleGetStartDate
      , "end_date" .= externalPaymentScheduleGetEndDate
      ]


-- | Construct a value of type 'ExternalPaymentScheduleGet' (by applying it's required fields, if any)
mkExternalPaymentScheduleGet
  :: Text -- ^ 'externalPaymentScheduleGetInterval': The frequency interval of the payment. Valid values are `\"WEEKLY\"` or `\"MONTHLY\"`.
  -> Double -- ^ 'externalPaymentScheduleGetIntervalExecutionDay': The day of the interval on which to schedule the payment.  If the payment interval is weekly, `interval_execution_day` should be an integer from 1 (Monday) to 7 (Sunday).  If the payment interval is monthly, `interval_execution_day` should be an integer indicating which day of the month to make the payment on. Integers from 1 to 28 can be used to make a payment on that day of the month. Negative integers from -1 to -5 can be used to make a payment relative to the end of the month. To make a payment on the last day of the month, use -1; to make the payment on the second-to-last day, use -2, and so on.
  -> Date -- ^ 'externalPaymentScheduleGetStartDate': A date in ISO 8601 format (YYYY-MM-DD). Standing order payments will begin on the first `interval_execution_day` on or after the `start_date`.  If the first `interval_execution_day` on or after the start date is also the same day that `/payment_initiation/payment/create` was called, the bank *may* make the first payment on that day, but it is not guaranteed to do so.
  -> ExternalPaymentScheduleGet
mkExternalPaymentScheduleGet externalPaymentScheduleGetInterval externalPaymentScheduleGetIntervalExecutionDay externalPaymentScheduleGetStartDate =
  ExternalPaymentScheduleGet
  { externalPaymentScheduleGetAdjustedStartDate = Nothing
  , externalPaymentScheduleGetInterval
  , externalPaymentScheduleGetIntervalExecutionDay
  , externalPaymentScheduleGetStartDate
  , externalPaymentScheduleGetEndDate = Nothing
  }

-- ** HealthIncident
-- | HealthIncident
-- HealthIncident
-- 
data HealthIncident = HealthIncident
  { healthIncidentStartDate :: !(Maybe Text) -- ^ "start_date" - The start date of the incident, in ISO 8601 format, e.g. &#x60;\&quot;2020-10-30T15:26:48Z\&quot;&#x60;.
  , healthIncidentEndDate :: !(Maybe Text) -- ^ "end_date" - The end date of the incident, in ISO 8601 format, e.g. &#x60;\&quot;2020-10-30T15:26:48Z\&quot;&#x60;.
  , healthIncidentTitle :: !(Maybe Text) -- ^ "title" - The title of the incident
  , healthIncidentIncidentUpdates :: !(Maybe [IncidentUpdate]) -- ^ "incident_updates" - Updates on the health incident.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON HealthIncident
instance A.FromJSON HealthIncident where
  parseJSON = A.withObject "HealthIncident" $ \o ->
    HealthIncident
      <$> (o .:? "start_date")
      <*> (o .:? "end_date")
      <*> (o .:? "title")
      <*> (o .:? "incident_updates")

-- | ToJSON HealthIncident
instance A.ToJSON HealthIncident where
  toJSON HealthIncident {..} =
   _omitNulls
      [ "start_date" .= healthIncidentStartDate
      , "end_date" .= healthIncidentEndDate
      , "title" .= healthIncidentTitle
      , "incident_updates" .= healthIncidentIncidentUpdates
      ]


-- | Construct a value of type 'HealthIncident' (by applying it's required fields, if any)
mkHealthIncident
  :: HealthIncident
mkHealthIncident =
  HealthIncident
  { healthIncidentStartDate = Nothing
  , healthIncidentEndDate = Nothing
  , healthIncidentTitle = Nothing
  , healthIncidentIncidentUpdates = Nothing
  }

-- ** HistoricalBalance
-- | HistoricalBalance
-- HistoricalBalance
-- 
-- An object representing a balance held by an account in the past
data HistoricalBalance = HistoricalBalance
  { historicalBalanceDate :: !(Date) -- ^ /Required/ "date" - The date of the calculated historical balance, in an ISO 8601 format (YYYY-MM-DD)
  , historicalBalanceCurrent :: !(Double) -- ^ /Required/ "current" - The total amount of funds in the account, calculated from the &#x60;current&#x60; balance in the &#x60;balance&#x60; object by subtracting inflows and adding back outflows according to the posted date of each transaction.  If the account has any pending transactions, historical balance amounts on or after the date of the earliest pending transaction may differ if retrieved in subsequent Asset Reports as a result of those pending transactions posting.
  , historicalBalanceIsoCurrencyCode :: !(Maybe Text) -- ^ "iso_currency_code" - The ISO-4217 currency code of the balance. Always &#x60;null&#x60; if &#x60;unofficial_currency_code&#x60; is non-&#x60;null&#x60;.
  , historicalBalanceUnofficialCurrencyCode :: !(Maybe Text) -- ^ "unofficial_currency_code" - The unofficial currency code associated with the balance. Always &#x60;null&#x60; if &#x60;iso_currency_code&#x60; is non-&#x60;null&#x60;.  See the [currency code schema](/docs/api/accounts#currency-code-schema) for a full listing of supported &#x60;iso_currency_code&#x60;s.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON HistoricalBalance
instance A.FromJSON HistoricalBalance where
  parseJSON = A.withObject "HistoricalBalance" $ \o ->
    HistoricalBalance
      <$> (o .:  "date")
      <*> (o .:  "current")
      <*> (o .:? "iso_currency_code")
      <*> (o .:? "unofficial_currency_code")

-- | ToJSON HistoricalBalance
instance A.ToJSON HistoricalBalance where
  toJSON HistoricalBalance {..} =
   _omitNulls
      [ "date" .= historicalBalanceDate
      , "current" .= historicalBalanceCurrent
      , "iso_currency_code" .= historicalBalanceIsoCurrencyCode
      , "unofficial_currency_code" .= historicalBalanceUnofficialCurrencyCode
      ]


-- | Construct a value of type 'HistoricalBalance' (by applying it's required fields, if any)
mkHistoricalBalance
  :: Date -- ^ 'historicalBalanceDate': The date of the calculated historical balance, in an ISO 8601 format (YYYY-MM-DD)
  -> Double -- ^ 'historicalBalanceCurrent': The total amount of funds in the account, calculated from the `current` balance in the `balance` object by subtracting inflows and adding back outflows according to the posted date of each transaction.  If the account has any pending transactions, historical balance amounts on or after the date of the earliest pending transaction may differ if retrieved in subsequent Asset Reports as a result of those pending transactions posting.
  -> HistoricalBalance
mkHistoricalBalance historicalBalanceDate historicalBalanceCurrent =
  HistoricalBalance
  { historicalBalanceDate
  , historicalBalanceCurrent
  , historicalBalanceIsoCurrencyCode = Nothing
  , historicalBalanceUnofficialCurrencyCode = Nothing
  }

-- ** HistoricalUpdateWebhook
-- | HistoricalUpdateWebhook
-- HistoricalUpdateWebhook
-- 
-- Fired when an Item's historical transaction pull is completed and Plaid has prepared as much historical transaction data as possible for the Item. Once this webhook has been fired, transaction data beyond the most recent 30 days can be fetched for the Item.
data HistoricalUpdateWebhook = HistoricalUpdateWebhook
  { historicalUpdateWebhookWebhookType :: !(Text) -- ^ /Required/ "webhook_type" - &#x60;TRANSACTIONS&#x60;
  , historicalUpdateWebhookWebhookCode :: !(Text) -- ^ /Required/ "webhook_code" - &#x60;HISTORICAL_UPDATE&#x60;
  , historicalUpdateWebhookError :: !(Maybe Error) -- ^ "error"
  , historicalUpdateWebhookNewTransactions :: !(Double) -- ^ /Required/ "new_transactions" - The number of new, unfetched transactions available
  , historicalUpdateWebhookItemId :: !(ItemId) -- ^ /Required/ "item_id" - The &#x60;item_id&#x60; of the Item associated with this webhook, warning, or error
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON HistoricalUpdateWebhook
instance A.FromJSON HistoricalUpdateWebhook where
  parseJSON = A.withObject "HistoricalUpdateWebhook" $ \o ->
    HistoricalUpdateWebhook
      <$> (o .:  "webhook_type")
      <*> (o .:  "webhook_code")
      <*> (o .:? "error")
      <*> (o .:  "new_transactions")
      <*> (o .:  "item_id")

-- | ToJSON HistoricalUpdateWebhook
instance A.ToJSON HistoricalUpdateWebhook where
  toJSON HistoricalUpdateWebhook {..} =
   _omitNulls
      [ "webhook_type" .= historicalUpdateWebhookWebhookType
      , "webhook_code" .= historicalUpdateWebhookWebhookCode
      , "error" .= historicalUpdateWebhookError
      , "new_transactions" .= historicalUpdateWebhookNewTransactions
      , "item_id" .= historicalUpdateWebhookItemId
      ]


-- | Construct a value of type 'HistoricalUpdateWebhook' (by applying it's required fields, if any)
mkHistoricalUpdateWebhook
  :: Text -- ^ 'historicalUpdateWebhookWebhookType': `TRANSACTIONS`
  -> Text -- ^ 'historicalUpdateWebhookWebhookCode': `HISTORICAL_UPDATE`
  -> Double -- ^ 'historicalUpdateWebhookNewTransactions': The number of new, unfetched transactions available
  -> ItemId -- ^ 'historicalUpdateWebhookItemId': The `item_id` of the Item associated with this webhook, warning, or error
  -> HistoricalUpdateWebhook
mkHistoricalUpdateWebhook historicalUpdateWebhookWebhookType historicalUpdateWebhookWebhookCode historicalUpdateWebhookNewTransactions historicalUpdateWebhookItemId =
  HistoricalUpdateWebhook
  { historicalUpdateWebhookWebhookType
  , historicalUpdateWebhookWebhookCode
  , historicalUpdateWebhookError = Nothing
  , historicalUpdateWebhookNewTransactions
  , historicalUpdateWebhookItemId
  }

-- ** Holding
-- | Holding
-- Holding
-- 
-- A securities holding at an institution.
data Holding = Holding
  { holdingAccountId :: !(Text) -- ^ /Required/ "account_id" - The Plaid &#x60;account_id&#x60; associated with the holding.
  , holdingSecurityId :: !(Text) -- ^ /Required/ "security_id" - The Plaid &#x60;security_id&#x60; associated with the holding.
  , holdingInstitutionPrice :: !(Double) -- ^ /Required/ "institution_price" - The last price given by the institution for this security.
  , holdingInstitutionPriceAsOf :: !(Maybe Text) -- ^ "institution_price_as_of" - The date at which &#x60;institution_price&#x60; was current.
  , holdingInstitutionValue :: !(Double) -- ^ /Required/ "institution_value" - The value of the holding, as reported by the institution.
  , holdingCostBasis :: !(Maybe Double) -- ^ "cost_basis" - The cost basis of the holding.
  , holdingQuantity :: !(Double) -- ^ /Required/ "quantity" - The total quantity of the asset held, as reported by the financial institution.
  , holdingIsoCurrencyCode :: !(Maybe Text) -- ^ "iso_currency_code" - The ISO-4217 currency code of the holding. Always &#x60;null&#x60; if &#x60;unofficial_currency_code&#x60; is non-&#x60;null&#x60;.
  , holdingUnofficialCurrencyCode :: !(Maybe Text) -- ^ "unofficial_currency_code" - The unofficial currency code associated with the holding. Always &#x60;null&#x60; if &#x60;iso_currency_code&#x60; is non-&#x60;null&#x60;. Unofficial currency codes are used for currencies that do not have official ISO currency codes, such as cryptocurrencies and the currencies of certain countries.  See the [currency code schema](/docs/api/accounts#currency-code-schema) for a full listing of supported &#x60;iso_currency_code&#x60;s. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Holding
instance A.FromJSON Holding where
  parseJSON = A.withObject "Holding" $ \o ->
    Holding
      <$> (o .:  "account_id")
      <*> (o .:  "security_id")
      <*> (o .:  "institution_price")
      <*> (o .:? "institution_price_as_of")
      <*> (o .:  "institution_value")
      <*> (o .:? "cost_basis")
      <*> (o .:  "quantity")
      <*> (o .:? "iso_currency_code")
      <*> (o .:? "unofficial_currency_code")

-- | ToJSON Holding
instance A.ToJSON Holding where
  toJSON Holding {..} =
   _omitNulls
      [ "account_id" .= holdingAccountId
      , "security_id" .= holdingSecurityId
      , "institution_price" .= holdingInstitutionPrice
      , "institution_price_as_of" .= holdingInstitutionPriceAsOf
      , "institution_value" .= holdingInstitutionValue
      , "cost_basis" .= holdingCostBasis
      , "quantity" .= holdingQuantity
      , "iso_currency_code" .= holdingIsoCurrencyCode
      , "unofficial_currency_code" .= holdingUnofficialCurrencyCode
      ]


-- | Construct a value of type 'Holding' (by applying it's required fields, if any)
mkHolding
  :: Text -- ^ 'holdingAccountId': The Plaid `account_id` associated with the holding.
  -> Text -- ^ 'holdingSecurityId': The Plaid `security_id` associated with the holding.
  -> Double -- ^ 'holdingInstitutionPrice': The last price given by the institution for this security.
  -> Double -- ^ 'holdingInstitutionValue': The value of the holding, as reported by the institution.
  -> Double -- ^ 'holdingQuantity': The total quantity of the asset held, as reported by the financial institution.
  -> Holding
mkHolding holdingAccountId holdingSecurityId holdingInstitutionPrice holdingInstitutionValue holdingQuantity =
  Holding
  { holdingAccountId
  , holdingSecurityId
  , holdingInstitutionPrice
  , holdingInstitutionPriceAsOf = Nothing
  , holdingInstitutionValue
  , holdingCostBasis = Nothing
  , holdingQuantity
  , holdingIsoCurrencyCode = Nothing
  , holdingUnofficialCurrencyCode = Nothing
  }

-- ** HoldingsDefaultUpdateWebhook
-- | HoldingsDefaultUpdateWebhook
-- HoldingsDefaultUpdateWebhook
-- 
-- Fired when new or updated holdings have been detected on an investment account. The webhook typically fires once per day, after market close, in response to any newly added holdings or price changes to existing holdings.
data HoldingsDefaultUpdateWebhook = HoldingsDefaultUpdateWebhook
  { holdingsDefaultUpdateWebhookWebhookType :: !(Text) -- ^ /Required/ "webhook_type" - &#x60;HOLDINGS&#x60;
  , holdingsDefaultUpdateWebhookWebhookCode :: !(Text) -- ^ /Required/ "webhook_code" - &#x60;DEFAULT_UPDATE&#x60;
  , holdingsDefaultUpdateWebhookItemId :: !(ItemId) -- ^ /Required/ "item_id" - The &#x60;item_id&#x60; of the Item associated with this webhook, warning, or error
  , holdingsDefaultUpdateWebhookError :: !(Maybe Error) -- ^ "error"
  , holdingsDefaultUpdateWebhookNewHoldings :: !(Double) -- ^ /Required/ "new_holdings" - The number of new holdings reported since the last time this webhook was fired.
  , holdingsDefaultUpdateWebhookUpdatedHoldings :: !(Double) -- ^ /Required/ "updated_holdings" - The number of updated holdings reported since the last time this webhook was fired.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON HoldingsDefaultUpdateWebhook
instance A.FromJSON HoldingsDefaultUpdateWebhook where
  parseJSON = A.withObject "HoldingsDefaultUpdateWebhook" $ \o ->
    HoldingsDefaultUpdateWebhook
      <$> (o .:  "webhook_type")
      <*> (o .:  "webhook_code")
      <*> (o .:  "item_id")
      <*> (o .:? "error")
      <*> (o .:  "new_holdings")
      <*> (o .:  "updated_holdings")

-- | ToJSON HoldingsDefaultUpdateWebhook
instance A.ToJSON HoldingsDefaultUpdateWebhook where
  toJSON HoldingsDefaultUpdateWebhook {..} =
   _omitNulls
      [ "webhook_type" .= holdingsDefaultUpdateWebhookWebhookType
      , "webhook_code" .= holdingsDefaultUpdateWebhookWebhookCode
      , "item_id" .= holdingsDefaultUpdateWebhookItemId
      , "error" .= holdingsDefaultUpdateWebhookError
      , "new_holdings" .= holdingsDefaultUpdateWebhookNewHoldings
      , "updated_holdings" .= holdingsDefaultUpdateWebhookUpdatedHoldings
      ]


-- | Construct a value of type 'HoldingsDefaultUpdateWebhook' (by applying it's required fields, if any)
mkHoldingsDefaultUpdateWebhook
  :: Text -- ^ 'holdingsDefaultUpdateWebhookWebhookType': `HOLDINGS`
  -> Text -- ^ 'holdingsDefaultUpdateWebhookWebhookCode': `DEFAULT_UPDATE`
  -> ItemId -- ^ 'holdingsDefaultUpdateWebhookItemId': The `item_id` of the Item associated with this webhook, warning, or error
  -> Double -- ^ 'holdingsDefaultUpdateWebhookNewHoldings': The number of new holdings reported since the last time this webhook was fired.
  -> Double -- ^ 'holdingsDefaultUpdateWebhookUpdatedHoldings': The number of updated holdings reported since the last time this webhook was fired.
  -> HoldingsDefaultUpdateWebhook
mkHoldingsDefaultUpdateWebhook holdingsDefaultUpdateWebhookWebhookType holdingsDefaultUpdateWebhookWebhookCode holdingsDefaultUpdateWebhookItemId holdingsDefaultUpdateWebhookNewHoldings holdingsDefaultUpdateWebhookUpdatedHoldings =
  HoldingsDefaultUpdateWebhook
  { holdingsDefaultUpdateWebhookWebhookType
  , holdingsDefaultUpdateWebhookWebhookCode
  , holdingsDefaultUpdateWebhookItemId
  , holdingsDefaultUpdateWebhookError = Nothing
  , holdingsDefaultUpdateWebhookNewHoldings
  , holdingsDefaultUpdateWebhookUpdatedHoldings
  }

-- ** IdentityGetRequest
-- | IdentityGetRequest
-- IdentityGetRequest defines the request schema for `/identity/get`
data IdentityGetRequest = IdentityGetRequest
  { identityGetRequestClientId :: !(Maybe Text) -- ^ "client_id" - Your Plaid API &#x60;client_id&#x60;.
  , identityGetRequestSecret :: !(Maybe Text) -- ^ "secret" - Your Plaid API &#x60;secret&#x60;.
  , identityGetRequestAccessToken :: !(AccessToken) -- ^ /Required/ "access_token" - The access token associated with the Item data is being requested for.
  , identityGetRequestOptions :: !(Maybe IdentityGetRequestOptions) -- ^ "options"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON IdentityGetRequest
instance A.FromJSON IdentityGetRequest where
  parseJSON = A.withObject "IdentityGetRequest" $ \o ->
    IdentityGetRequest
      <$> (o .:? "client_id")
      <*> (o .:? "secret")
      <*> (o .:  "access_token")
      <*> (o .:? "options")

-- | ToJSON IdentityGetRequest
instance A.ToJSON IdentityGetRequest where
  toJSON IdentityGetRequest {..} =
   _omitNulls
      [ "client_id" .= identityGetRequestClientId
      , "secret" .= identityGetRequestSecret
      , "access_token" .= identityGetRequestAccessToken
      , "options" .= identityGetRequestOptions
      ]


-- | Construct a value of type 'IdentityGetRequest' (by applying it's required fields, if any)
mkIdentityGetRequest
  :: AccessToken -- ^ 'identityGetRequestAccessToken': The access token associated with the Item data is being requested for.
  -> IdentityGetRequest
mkIdentityGetRequest identityGetRequestAccessToken =
  IdentityGetRequest
  { identityGetRequestClientId = Nothing
  , identityGetRequestSecret = Nothing
  , identityGetRequestAccessToken
  , identityGetRequestOptions = Nothing
  }

-- ** IdentityGetRequestOptions
-- | IdentityGetRequestOptions
-- An optional object to filter `/identity/get` results.
data IdentityGetRequestOptions = IdentityGetRequestOptions
  { identityGetRequestOptionsAccountIds :: !(Maybe [Text]) -- ^ "account_ids" - A list of &#x60;account_ids&#x60; to retrieve for the Item. Note: An error will be returned if a provided &#x60;account_id&#x60; is not associated with the Item.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON IdentityGetRequestOptions
instance A.FromJSON IdentityGetRequestOptions where
  parseJSON = A.withObject "IdentityGetRequestOptions" $ \o ->
    IdentityGetRequestOptions
      <$> (o .:? "account_ids")

-- | ToJSON IdentityGetRequestOptions
instance A.ToJSON IdentityGetRequestOptions where
  toJSON IdentityGetRequestOptions {..} =
   _omitNulls
      [ "account_ids" .= identityGetRequestOptionsAccountIds
      ]


-- | Construct a value of type 'IdentityGetRequestOptions' (by applying it's required fields, if any)
mkIdentityGetRequestOptions
  :: IdentityGetRequestOptions
mkIdentityGetRequestOptions =
  IdentityGetRequestOptions
  { identityGetRequestOptionsAccountIds = Nothing
  }

-- ** IdentityGetResponse
-- | IdentityGetResponse
-- IdentityGetResponse defines the response schema for `/identity/get`
data IdentityGetResponse = IdentityGetResponse
  { identityGetResponseAccounts :: !([AccountIdentity]) -- ^ /Required/ "accounts" - The accounts for which Identity data has been requested
  , identityGetResponseItem :: !(Item) -- ^ /Required/ "item"
  , identityGetResponseRequestId :: !(Text) -- ^ /Required/ "request_id" - A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON IdentityGetResponse
instance A.FromJSON IdentityGetResponse where
  parseJSON = A.withObject "IdentityGetResponse" $ \o ->
    IdentityGetResponse
      <$> (o .:  "accounts")
      <*> (o .:  "item")
      <*> (o .:  "request_id")

-- | ToJSON IdentityGetResponse
instance A.ToJSON IdentityGetResponse where
  toJSON IdentityGetResponse {..} =
   _omitNulls
      [ "accounts" .= identityGetResponseAccounts
      , "item" .= identityGetResponseItem
      , "request_id" .= identityGetResponseRequestId
      ]


-- | Construct a value of type 'IdentityGetResponse' (by applying it's required fields, if any)
mkIdentityGetResponse
  :: [AccountIdentity] -- ^ 'identityGetResponseAccounts': The accounts for which Identity data has been requested
  -> Item -- ^ 'identityGetResponseItem' 
  -> Text -- ^ 'identityGetResponseRequestId': A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  -> IdentityGetResponse
mkIdentityGetResponse identityGetResponseAccounts identityGetResponseItem identityGetResponseRequestId =
  IdentityGetResponse
  { identityGetResponseAccounts
  , identityGetResponseItem
  , identityGetResponseRequestId
  }

-- ** IncidentUpdate
-- | IncidentUpdate
-- IncidentUpdate
-- 
data IncidentUpdate = IncidentUpdate
  { incidentUpdateDescription :: !(Maybe Text) -- ^ "description" - The content of the update.
  , incidentUpdateStatus :: !(Maybe E'Status3) -- ^ "status" - The status of the incident.
  , incidentUpdateUpdatedDate :: !(Maybe Text) -- ^ "updated_date" - The date when the update was published, in ISO 8601 format, e.g. &#x60;\&quot;2020-10-30T15:26:48Z\&quot;&#x60;.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON IncidentUpdate
instance A.FromJSON IncidentUpdate where
  parseJSON = A.withObject "IncidentUpdate" $ \o ->
    IncidentUpdate
      <$> (o .:? "description")
      <*> (o .:? "status")
      <*> (o .:? "updated_date")

-- | ToJSON IncidentUpdate
instance A.ToJSON IncidentUpdate where
  toJSON IncidentUpdate {..} =
   _omitNulls
      [ "description" .= incidentUpdateDescription
      , "status" .= incidentUpdateStatus
      , "updated_date" .= incidentUpdateUpdatedDate
      ]


-- | Construct a value of type 'IncidentUpdate' (by applying it's required fields, if any)
mkIncidentUpdate
  :: IncidentUpdate
mkIncidentUpdate =
  IncidentUpdate
  { incidentUpdateDescription = Nothing
  , incidentUpdateStatus = Nothing
  , incidentUpdateUpdatedDate = Nothing
  }

-- ** IncomeBreakdown
-- | IncomeBreakdown
-- IncomeBreakdown
-- 
data IncomeBreakdown = IncomeBreakdown
  { incomeBreakdownType :: !(Maybe Text) -- ^ "type" - The type of income. Possible values include &#x60;\&quot;regular\&quot;&#x60;, &#x60;\&quot;overtime\&quot;&#x60;, and &#x60;\&quot;bonus\&quot;&#x60;.
  , incomeBreakdownRate :: !(Maybe Double) -- ^ "rate" - The hourly rate at which the income is paid.
  , incomeBreakdownHours :: !(Maybe Double) -- ^ "hours" - The number of hours logged for this income for this pay period.
  , incomeBreakdownTotal :: !(Maybe Double) -- ^ "total" - The total pay for this pay period.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON IncomeBreakdown
instance A.FromJSON IncomeBreakdown where
  parseJSON = A.withObject "IncomeBreakdown" $ \o ->
    IncomeBreakdown
      <$> (o .:? "type")
      <*> (o .:? "rate")
      <*> (o .:? "hours")
      <*> (o .:? "total")

-- | ToJSON IncomeBreakdown
instance A.ToJSON IncomeBreakdown where
  toJSON IncomeBreakdown {..} =
   _omitNulls
      [ "type" .= incomeBreakdownType
      , "rate" .= incomeBreakdownRate
      , "hours" .= incomeBreakdownHours
      , "total" .= incomeBreakdownTotal
      ]


-- | Construct a value of type 'IncomeBreakdown' (by applying it's required fields, if any)
mkIncomeBreakdown
  :: IncomeBreakdown
mkIncomeBreakdown =
  IncomeBreakdown
  { incomeBreakdownType = Nothing
  , incomeBreakdownRate = Nothing
  , incomeBreakdownHours = Nothing
  , incomeBreakdownTotal = Nothing
  }

-- ** IncomeSummary
-- | IncomeSummary
-- IncomeSummary
-- 
-- The verified fields from a paystub verification. All fields are provided as reported on the paystub.
data IncomeSummary = IncomeSummary
  { incomeSummaryEmployerName :: !(Maybe EmployerIncomeSummaryFieldString) -- ^ "employer_name"
  , incomeSummaryEmployeeName :: !(Maybe EmployeeIncomeSummaryFieldString) -- ^ "employee_name"
  , incomeSummaryYtdGrossIncome :: !(Maybe YTDGrossIncomeSummaryFieldNumber) -- ^ "ytd_gross_income"
  , incomeSummaryYtdNetIncome :: !(Maybe YTDNetIncomeSummaryFieldNumber) -- ^ "ytd_net_income"
  , incomeSummaryPayFrequency :: !(Maybe PayFrequency) -- ^ "pay_frequency"
  , incomeSummaryProjectedWage :: !(Maybe ProjectedIncomeSummaryFieldNumber) -- ^ "projected_wage"
  , incomeSummaryVerifiedTransaction :: !(Maybe TransactionData) -- ^ "verified_transaction"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON IncomeSummary
instance A.FromJSON IncomeSummary where
  parseJSON = A.withObject "IncomeSummary" $ \o ->
    IncomeSummary
      <$> (o .:? "employer_name")
      <*> (o .:? "employee_name")
      <*> (o .:? "ytd_gross_income")
      <*> (o .:? "ytd_net_income")
      <*> (o .:? "pay_frequency")
      <*> (o .:? "projected_wage")
      <*> (o .:? "verified_transaction")

-- | ToJSON IncomeSummary
instance A.ToJSON IncomeSummary where
  toJSON IncomeSummary {..} =
   _omitNulls
      [ "employer_name" .= incomeSummaryEmployerName
      , "employee_name" .= incomeSummaryEmployeeName
      , "ytd_gross_income" .= incomeSummaryYtdGrossIncome
      , "ytd_net_income" .= incomeSummaryYtdNetIncome
      , "pay_frequency" .= incomeSummaryPayFrequency
      , "projected_wage" .= incomeSummaryProjectedWage
      , "verified_transaction" .= incomeSummaryVerifiedTransaction
      ]


-- | Construct a value of type 'IncomeSummary' (by applying it's required fields, if any)
mkIncomeSummary
  :: IncomeSummary
mkIncomeSummary =
  IncomeSummary
  { incomeSummaryEmployerName = Nothing
  , incomeSummaryEmployeeName = Nothing
  , incomeSummaryYtdGrossIncome = Nothing
  , incomeSummaryYtdNetIncome = Nothing
  , incomeSummaryPayFrequency = Nothing
  , incomeSummaryProjectedWage = Nothing
  , incomeSummaryVerifiedTransaction = Nothing
  }

-- ** IncomeSummaryFieldNumber
-- | IncomeSummaryFieldNumber
-- IncomeSummaryFieldNumber
-- 
data IncomeSummaryFieldNumber = IncomeSummaryFieldNumber
  { incomeSummaryFieldNumberValue :: !(Double) -- ^ /Required/ "value" - The value of the field.
  , incomeSummaryFieldNumberVerificationStatus :: !(VerificationStatus) -- ^ /Required/ "verification_status"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON IncomeSummaryFieldNumber
instance A.FromJSON IncomeSummaryFieldNumber where
  parseJSON = A.withObject "IncomeSummaryFieldNumber" $ \o ->
    IncomeSummaryFieldNumber
      <$> (o .:  "value")
      <*> (o .:  "verification_status")

-- | ToJSON IncomeSummaryFieldNumber
instance A.ToJSON IncomeSummaryFieldNumber where
  toJSON IncomeSummaryFieldNumber {..} =
   _omitNulls
      [ "value" .= incomeSummaryFieldNumberValue
      , "verification_status" .= incomeSummaryFieldNumberVerificationStatus
      ]


-- | Construct a value of type 'IncomeSummaryFieldNumber' (by applying it's required fields, if any)
mkIncomeSummaryFieldNumber
  :: Double -- ^ 'incomeSummaryFieldNumberValue': The value of the field.
  -> VerificationStatus -- ^ 'incomeSummaryFieldNumberVerificationStatus' 
  -> IncomeSummaryFieldNumber
mkIncomeSummaryFieldNumber incomeSummaryFieldNumberValue incomeSummaryFieldNumberVerificationStatus =
  IncomeSummaryFieldNumber
  { incomeSummaryFieldNumberValue
  , incomeSummaryFieldNumberVerificationStatus
  }

-- ** IncomeSummaryFieldString
-- | IncomeSummaryFieldString
-- IncomeSummaryFieldString
-- 
data IncomeSummaryFieldString = IncomeSummaryFieldString
  { incomeSummaryFieldStringValue :: !(Text) -- ^ /Required/ "value" - The value of the field.
  , incomeSummaryFieldStringVerificationStatus :: !(VerificationStatus) -- ^ /Required/ "verification_status"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON IncomeSummaryFieldString
instance A.FromJSON IncomeSummaryFieldString where
  parseJSON = A.withObject "IncomeSummaryFieldString" $ \o ->
    IncomeSummaryFieldString
      <$> (o .:  "value")
      <*> (o .:  "verification_status")

-- | ToJSON IncomeSummaryFieldString
instance A.ToJSON IncomeSummaryFieldString where
  toJSON IncomeSummaryFieldString {..} =
   _omitNulls
      [ "value" .= incomeSummaryFieldStringValue
      , "verification_status" .= incomeSummaryFieldStringVerificationStatus
      ]


-- | Construct a value of type 'IncomeSummaryFieldString' (by applying it's required fields, if any)
mkIncomeSummaryFieldString
  :: Text -- ^ 'incomeSummaryFieldStringValue': The value of the field.
  -> VerificationStatus -- ^ 'incomeSummaryFieldStringVerificationStatus' 
  -> IncomeSummaryFieldString
mkIncomeSummaryFieldString incomeSummaryFieldStringValue incomeSummaryFieldStringVerificationStatus =
  IncomeSummaryFieldString
  { incomeSummaryFieldStringValue
  , incomeSummaryFieldStringVerificationStatus
  }

-- ** IncomeVerificationCreateRequest
-- | IncomeVerificationCreateRequest
-- IncomeVerificationCreateRequest
-- 
-- IncomeVerificationCreateRequest defines the request schema for `/income/verification/create`
data IncomeVerificationCreateRequest = IncomeVerificationCreateRequest
  { incomeVerificationCreateRequestClientId :: !(Maybe Text) -- ^ "client_id" - Your Plaid API &#x60;client_id&#x60;.
  , incomeVerificationCreateRequestSecret :: !(Maybe Text) -- ^ "secret" - Your Plaid API &#x60;secret&#x60;.
  , incomeVerificationCreateRequestWebhook :: !(Text) -- ^ /Required/ "webhook" - The URL endpoint to which Plaid should send webhooks related to the progress of the income verification process.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON IncomeVerificationCreateRequest
instance A.FromJSON IncomeVerificationCreateRequest where
  parseJSON = A.withObject "IncomeVerificationCreateRequest" $ \o ->
    IncomeVerificationCreateRequest
      <$> (o .:? "client_id")
      <*> (o .:? "secret")
      <*> (o .:  "webhook")

-- | ToJSON IncomeVerificationCreateRequest
instance A.ToJSON IncomeVerificationCreateRequest where
  toJSON IncomeVerificationCreateRequest {..} =
   _omitNulls
      [ "client_id" .= incomeVerificationCreateRequestClientId
      , "secret" .= incomeVerificationCreateRequestSecret
      , "webhook" .= incomeVerificationCreateRequestWebhook
      ]


-- | Construct a value of type 'IncomeVerificationCreateRequest' (by applying it's required fields, if any)
mkIncomeVerificationCreateRequest
  :: Text -- ^ 'incomeVerificationCreateRequestWebhook': The URL endpoint to which Plaid should send webhooks related to the progress of the income verification process.
  -> IncomeVerificationCreateRequest
mkIncomeVerificationCreateRequest incomeVerificationCreateRequestWebhook =
  IncomeVerificationCreateRequest
  { incomeVerificationCreateRequestClientId = Nothing
  , incomeVerificationCreateRequestSecret = Nothing
  , incomeVerificationCreateRequestWebhook
  }

-- ** IncomeVerificationCreateResponse
-- | IncomeVerificationCreateResponse
-- IncomeVerificationCreateResponse
-- 
-- IncomeVerificationCreateResponse defines the response schema for `/income/verification/create`.
data IncomeVerificationCreateResponse = IncomeVerificationCreateResponse
  { incomeVerificationCreateResponseIncomeVerificationId :: !(Text) -- ^ /Required/ "income_verification_id" - ID of the verification. This ID is persisted throughout the lifetime of the verification.
  , incomeVerificationCreateResponseRequestId :: !(Text) -- ^ /Required/ "request_id" - A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON IncomeVerificationCreateResponse
instance A.FromJSON IncomeVerificationCreateResponse where
  parseJSON = A.withObject "IncomeVerificationCreateResponse" $ \o ->
    IncomeVerificationCreateResponse
      <$> (o .:  "income_verification_id")
      <*> (o .:  "request_id")

-- | ToJSON IncomeVerificationCreateResponse
instance A.ToJSON IncomeVerificationCreateResponse where
  toJSON IncomeVerificationCreateResponse {..} =
   _omitNulls
      [ "income_verification_id" .= incomeVerificationCreateResponseIncomeVerificationId
      , "request_id" .= incomeVerificationCreateResponseRequestId
      ]


-- | Construct a value of type 'IncomeVerificationCreateResponse' (by applying it's required fields, if any)
mkIncomeVerificationCreateResponse
  :: Text -- ^ 'incomeVerificationCreateResponseIncomeVerificationId': ID of the verification. This ID is persisted throughout the lifetime of the verification.
  -> Text -- ^ 'incomeVerificationCreateResponseRequestId': A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  -> IncomeVerificationCreateResponse
mkIncomeVerificationCreateResponse incomeVerificationCreateResponseIncomeVerificationId incomeVerificationCreateResponseRequestId =
  IncomeVerificationCreateResponse
  { incomeVerificationCreateResponseIncomeVerificationId
  , incomeVerificationCreateResponseRequestId
  }

-- ** IncomeVerificationDocumentsDownloadRequest
-- | IncomeVerificationDocumentsDownloadRequest
-- IncomeVerificationDocumentsDownloadRequest
-- 
-- IncomeVerificationDocumentsDownloadRequest defines the request schema for `/income/verification/documents/download`.
data IncomeVerificationDocumentsDownloadRequest = IncomeVerificationDocumentsDownloadRequest
  { incomeVerificationDocumentsDownloadRequestClientId :: !(Maybe Text) -- ^ "client_id" - Your Plaid API &#x60;client_id&#x60;.
  , incomeVerificationDocumentsDownloadRequestSecret :: !(Maybe Text) -- ^ "secret" - Your Plaid API &#x60;secret&#x60;.
  , incomeVerificationDocumentsDownloadRequestIncomeVerificationId :: !(Text) -- ^ /Required/ "income_verification_id" - The ID of the verification.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON IncomeVerificationDocumentsDownloadRequest
instance A.FromJSON IncomeVerificationDocumentsDownloadRequest where
  parseJSON = A.withObject "IncomeVerificationDocumentsDownloadRequest" $ \o ->
    IncomeVerificationDocumentsDownloadRequest
      <$> (o .:? "client_id")
      <*> (o .:? "secret")
      <*> (o .:  "income_verification_id")

-- | ToJSON IncomeVerificationDocumentsDownloadRequest
instance A.ToJSON IncomeVerificationDocumentsDownloadRequest where
  toJSON IncomeVerificationDocumentsDownloadRequest {..} =
   _omitNulls
      [ "client_id" .= incomeVerificationDocumentsDownloadRequestClientId
      , "secret" .= incomeVerificationDocumentsDownloadRequestSecret
      , "income_verification_id" .= incomeVerificationDocumentsDownloadRequestIncomeVerificationId
      ]


-- | Construct a value of type 'IncomeVerificationDocumentsDownloadRequest' (by applying it's required fields, if any)
mkIncomeVerificationDocumentsDownloadRequest
  :: Text -- ^ 'incomeVerificationDocumentsDownloadRequestIncomeVerificationId': The ID of the verification.
  -> IncomeVerificationDocumentsDownloadRequest
mkIncomeVerificationDocumentsDownloadRequest incomeVerificationDocumentsDownloadRequestIncomeVerificationId =
  IncomeVerificationDocumentsDownloadRequest
  { incomeVerificationDocumentsDownloadRequestClientId = Nothing
  , incomeVerificationDocumentsDownloadRequestSecret = Nothing
  , incomeVerificationDocumentsDownloadRequestIncomeVerificationId
  }

-- ** IncomeVerificationDocumentsDownloadResponse
-- | IncomeVerificationDocumentsDownloadResponse
-- IncomeVerificationDocumentsDownloadResponse
-- 
-- IncomeVerificationDocumentsDownloadResponse defines the response schema for `/income/verification/documents/download`.
data IncomeVerificationDocumentsDownloadResponse = IncomeVerificationDocumentsDownloadResponse
  { incomeVerificationDocumentsDownloadResponseId :: !(Text) -- ^ /Required/ "id"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON IncomeVerificationDocumentsDownloadResponse
instance A.FromJSON IncomeVerificationDocumentsDownloadResponse where
  parseJSON = A.withObject "IncomeVerificationDocumentsDownloadResponse" $ \o ->
    IncomeVerificationDocumentsDownloadResponse
      <$> (o .:  "id")

-- | ToJSON IncomeVerificationDocumentsDownloadResponse
instance A.ToJSON IncomeVerificationDocumentsDownloadResponse where
  toJSON IncomeVerificationDocumentsDownloadResponse {..} =
   _omitNulls
      [ "id" .= incomeVerificationDocumentsDownloadResponseId
      ]


-- | Construct a value of type 'IncomeVerificationDocumentsDownloadResponse' (by applying it's required fields, if any)
mkIncomeVerificationDocumentsDownloadResponse
  :: Text -- ^ 'incomeVerificationDocumentsDownloadResponseId' 
  -> IncomeVerificationDocumentsDownloadResponse
mkIncomeVerificationDocumentsDownloadResponse incomeVerificationDocumentsDownloadResponseId =
  IncomeVerificationDocumentsDownloadResponse
  { incomeVerificationDocumentsDownloadResponseId
  }

-- ** IncomeVerificationPaystubGetRequest
-- | IncomeVerificationPaystubGetRequest
-- IncomeVerificationPaystubGetRequest
-- 
-- IncomeVerificationPaystubGetRequest defines the request schema for `/income/verification/paystub/get`.
data IncomeVerificationPaystubGetRequest = IncomeVerificationPaystubGetRequest
  { incomeVerificationPaystubGetRequestClientId :: !(Maybe Text) -- ^ "client_id" - Your Plaid API &#x60;client_id&#x60;.
  , incomeVerificationPaystubGetRequestSecret :: !(Maybe Text) -- ^ "secret" - Your Plaid API &#x60;secret&#x60;.
  , incomeVerificationPaystubGetRequestIncomeVerificationId :: !(Text) -- ^ /Required/ "income_verification_id" - The ID of the verification for which to get paystub information.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON IncomeVerificationPaystubGetRequest
instance A.FromJSON IncomeVerificationPaystubGetRequest where
  parseJSON = A.withObject "IncomeVerificationPaystubGetRequest" $ \o ->
    IncomeVerificationPaystubGetRequest
      <$> (o .:? "client_id")
      <*> (o .:? "secret")
      <*> (o .:  "income_verification_id")

-- | ToJSON IncomeVerificationPaystubGetRequest
instance A.ToJSON IncomeVerificationPaystubGetRequest where
  toJSON IncomeVerificationPaystubGetRequest {..} =
   _omitNulls
      [ "client_id" .= incomeVerificationPaystubGetRequestClientId
      , "secret" .= incomeVerificationPaystubGetRequestSecret
      , "income_verification_id" .= incomeVerificationPaystubGetRequestIncomeVerificationId
      ]


-- | Construct a value of type 'IncomeVerificationPaystubGetRequest' (by applying it's required fields, if any)
mkIncomeVerificationPaystubGetRequest
  :: Text -- ^ 'incomeVerificationPaystubGetRequestIncomeVerificationId': The ID of the verification for which to get paystub information.
  -> IncomeVerificationPaystubGetRequest
mkIncomeVerificationPaystubGetRequest incomeVerificationPaystubGetRequestIncomeVerificationId =
  IncomeVerificationPaystubGetRequest
  { incomeVerificationPaystubGetRequestClientId = Nothing
  , incomeVerificationPaystubGetRequestSecret = Nothing
  , incomeVerificationPaystubGetRequestIncomeVerificationId
  }

-- ** IncomeVerificationPaystubGetResponse
-- | IncomeVerificationPaystubGetResponse
-- IncomeVerificationPaystubGetResponse
-- 
-- IncomeVerificationPaystubGetResponse defines the response schema for `/income/verification/paystub/get`.
data IncomeVerificationPaystubGetResponse = IncomeVerificationPaystubGetResponse
  { incomeVerificationPaystubGetResponsePaystub :: !(Maybe Paystub) -- ^ "paystub"
  , incomeVerificationPaystubGetResponseRequestId :: !(Maybe Text) -- ^ "request_id" - A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON IncomeVerificationPaystubGetResponse
instance A.FromJSON IncomeVerificationPaystubGetResponse where
  parseJSON = A.withObject "IncomeVerificationPaystubGetResponse" $ \o ->
    IncomeVerificationPaystubGetResponse
      <$> (o .:? "paystub")
      <*> (o .:? "request_id")

-- | ToJSON IncomeVerificationPaystubGetResponse
instance A.ToJSON IncomeVerificationPaystubGetResponse where
  toJSON IncomeVerificationPaystubGetResponse {..} =
   _omitNulls
      [ "paystub" .= incomeVerificationPaystubGetResponsePaystub
      , "request_id" .= incomeVerificationPaystubGetResponseRequestId
      ]


-- | Construct a value of type 'IncomeVerificationPaystubGetResponse' (by applying it's required fields, if any)
mkIncomeVerificationPaystubGetResponse
  :: IncomeVerificationPaystubGetResponse
mkIncomeVerificationPaystubGetResponse =
  IncomeVerificationPaystubGetResponse
  { incomeVerificationPaystubGetResponsePaystub = Nothing
  , incomeVerificationPaystubGetResponseRequestId = Nothing
  }

-- ** IncomeVerificationStatusWebhook
-- | IncomeVerificationStatusWebhook
-- IncomeVerificationStatusWebhook
-- 
-- Fired when the status of an income verification instance has changed. It will typically take several minutes for this webhook to fire after the end user has uploaded their documents, and may take up to 15 minutes.
data IncomeVerificationStatusWebhook = IncomeVerificationStatusWebhook
  { incomeVerificationStatusWebhookWebhookType :: !(Text) -- ^ /Required/ "webhook_type" - &#x60;\&quot;INCOME\&quot;&#x60;
  , incomeVerificationStatusWebhookWebhookCode :: !(Text) -- ^ /Required/ "webhook_code" - &#x60;income_verification&#x60;
  , incomeVerificationStatusWebhookIncomeVerificationId :: !(Text) -- ^ /Required/ "income_verification_id" - The &#x60;income_verification_id&#x60; of the verification instance whose status is being reported.
  , incomeVerificationStatusWebhookVerificationStatus :: !(Text) -- ^ /Required/ "verification_status" - &#x60;VERIFICATION_STATUS_PROCESSING_COMPLETE&#x60;: The income verification status processing has completed.  &#x60;VERIFICATION_STATUS_UPLOAD_ERROR&#x60;: An upload error occurred when the end user attempted to upload their verification documentation.  &#x60;VERIFICATION_STATUS_INVALID_TYPE&#x60;: The end user attempted to upload verification documentation in an unsupported file format.  &#x60;VERIFICATION_STATUS_DOCUMENT_REJECTED&#x60;: The documentation uploaded by the end user was recognized as a supported file format, but not recognized as a valid paystub.  &#x60;VERIFICATION_STATUS_PROCESSING_FAILED&#x60;: A failure occurred when attempting to process the verification documentation.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON IncomeVerificationStatusWebhook
instance A.FromJSON IncomeVerificationStatusWebhook where
  parseJSON = A.withObject "IncomeVerificationStatusWebhook" $ \o ->
    IncomeVerificationStatusWebhook
      <$> (o .:  "webhook_type")
      <*> (o .:  "webhook_code")
      <*> (o .:  "income_verification_id")
      <*> (o .:  "verification_status")

-- | ToJSON IncomeVerificationStatusWebhook
instance A.ToJSON IncomeVerificationStatusWebhook where
  toJSON IncomeVerificationStatusWebhook {..} =
   _omitNulls
      [ "webhook_type" .= incomeVerificationStatusWebhookWebhookType
      , "webhook_code" .= incomeVerificationStatusWebhookWebhookCode
      , "income_verification_id" .= incomeVerificationStatusWebhookIncomeVerificationId
      , "verification_status" .= incomeVerificationStatusWebhookVerificationStatus
      ]


-- | Construct a value of type 'IncomeVerificationStatusWebhook' (by applying it's required fields, if any)
mkIncomeVerificationStatusWebhook
  :: Text -- ^ 'incomeVerificationStatusWebhookWebhookType': `\"INCOME\"`
  -> Text -- ^ 'incomeVerificationStatusWebhookWebhookCode': `income_verification`
  -> Text -- ^ 'incomeVerificationStatusWebhookIncomeVerificationId': The `income_verification_id` of the verification instance whose status is being reported.
  -> Text -- ^ 'incomeVerificationStatusWebhookVerificationStatus': `VERIFICATION_STATUS_PROCESSING_COMPLETE`: The income verification status processing has completed.  `VERIFICATION_STATUS_UPLOAD_ERROR`: An upload error occurred when the end user attempted to upload their verification documentation.  `VERIFICATION_STATUS_INVALID_TYPE`: The end user attempted to upload verification documentation in an unsupported file format.  `VERIFICATION_STATUS_DOCUMENT_REJECTED`: The documentation uploaded by the end user was recognized as a supported file format, but not recognized as a valid paystub.  `VERIFICATION_STATUS_PROCESSING_FAILED`: A failure occurred when attempting to process the verification documentation.
  -> IncomeVerificationStatusWebhook
mkIncomeVerificationStatusWebhook incomeVerificationStatusWebhookWebhookType incomeVerificationStatusWebhookWebhookCode incomeVerificationStatusWebhookIncomeVerificationId incomeVerificationStatusWebhookVerificationStatus =
  IncomeVerificationStatusWebhook
  { incomeVerificationStatusWebhookWebhookType
  , incomeVerificationStatusWebhookWebhookCode
  , incomeVerificationStatusWebhookIncomeVerificationId
  , incomeVerificationStatusWebhookVerificationStatus
  }

-- ** IncomeVerificationSummaryGetRequest
-- | IncomeVerificationSummaryGetRequest
-- IncomeVerificationSummaryGetRequest
-- 
-- IncomeVerificationSummaryGetRequest defines the request schema for `/income/verification/summary/get`.
data IncomeVerificationSummaryGetRequest = IncomeVerificationSummaryGetRequest
  { incomeVerificationSummaryGetRequestClientId :: !(Maybe Text) -- ^ "client_id" - Your Plaid API &#x60;client_id&#x60;.
  , incomeVerificationSummaryGetRequestSecret :: !(Maybe Text) -- ^ "secret" - Your Plaid API &#x60;secret&#x60;.
  , incomeVerificationSummaryGetRequestIncomeVerificationId :: !(Text) -- ^ /Required/ "income_verification_id" - The ID of the verification.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON IncomeVerificationSummaryGetRequest
instance A.FromJSON IncomeVerificationSummaryGetRequest where
  parseJSON = A.withObject "IncomeVerificationSummaryGetRequest" $ \o ->
    IncomeVerificationSummaryGetRequest
      <$> (o .:? "client_id")
      <*> (o .:? "secret")
      <*> (o .:  "income_verification_id")

-- | ToJSON IncomeVerificationSummaryGetRequest
instance A.ToJSON IncomeVerificationSummaryGetRequest where
  toJSON IncomeVerificationSummaryGetRequest {..} =
   _omitNulls
      [ "client_id" .= incomeVerificationSummaryGetRequestClientId
      , "secret" .= incomeVerificationSummaryGetRequestSecret
      , "income_verification_id" .= incomeVerificationSummaryGetRequestIncomeVerificationId
      ]


-- | Construct a value of type 'IncomeVerificationSummaryGetRequest' (by applying it's required fields, if any)
mkIncomeVerificationSummaryGetRequest
  :: Text -- ^ 'incomeVerificationSummaryGetRequestIncomeVerificationId': The ID of the verification.
  -> IncomeVerificationSummaryGetRequest
mkIncomeVerificationSummaryGetRequest incomeVerificationSummaryGetRequestIncomeVerificationId =
  IncomeVerificationSummaryGetRequest
  { incomeVerificationSummaryGetRequestClientId = Nothing
  , incomeVerificationSummaryGetRequestSecret = Nothing
  , incomeVerificationSummaryGetRequestIncomeVerificationId
  }

-- ** IncomeVerificationSummaryGetResponse
-- | IncomeVerificationSummaryGetResponse
-- IncomeVerificationSummaryGetResponse
-- 
-- IncomeVerificationSummaryGetResponse defines the response schema for `/income/verification/summary/get`.
data IncomeVerificationSummaryGetResponse = IncomeVerificationSummaryGetResponse
  { incomeVerificationSummaryGetResponseIncomeSummaries :: !([IncomeSummary]) -- ^ /Required/ "income_summaries" - A list of income summaries.
  , incomeVerificationSummaryGetResponseRequestId :: !(Text) -- ^ /Required/ "request_id" - A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON IncomeVerificationSummaryGetResponse
instance A.FromJSON IncomeVerificationSummaryGetResponse where
  parseJSON = A.withObject "IncomeVerificationSummaryGetResponse" $ \o ->
    IncomeVerificationSummaryGetResponse
      <$> (o .:  "income_summaries")
      <*> (o .:  "request_id")

-- | ToJSON IncomeVerificationSummaryGetResponse
instance A.ToJSON IncomeVerificationSummaryGetResponse where
  toJSON IncomeVerificationSummaryGetResponse {..} =
   _omitNulls
      [ "income_summaries" .= incomeVerificationSummaryGetResponseIncomeSummaries
      , "request_id" .= incomeVerificationSummaryGetResponseRequestId
      ]


-- | Construct a value of type 'IncomeVerificationSummaryGetResponse' (by applying it's required fields, if any)
mkIncomeVerificationSummaryGetResponse
  :: [IncomeSummary] -- ^ 'incomeVerificationSummaryGetResponseIncomeSummaries': A list of income summaries.
  -> Text -- ^ 'incomeVerificationSummaryGetResponseRequestId': A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  -> IncomeVerificationSummaryGetResponse
mkIncomeVerificationSummaryGetResponse incomeVerificationSummaryGetResponseIncomeSummaries incomeVerificationSummaryGetResponseRequestId =
  IncomeVerificationSummaryGetResponse
  { incomeVerificationSummaryGetResponseIncomeSummaries
  , incomeVerificationSummaryGetResponseRequestId
  }

-- ** IncomeVerificationWebhookStatus
-- | IncomeVerificationWebhookStatus
-- IncomeVerificationWebhookStatus
-- 
data IncomeVerificationWebhookStatus = IncomeVerificationWebhookStatus
  { incomeVerificationWebhookStatusId :: !(Text) -- ^ /Required/ "id"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON IncomeVerificationWebhookStatus
instance A.FromJSON IncomeVerificationWebhookStatus where
  parseJSON = A.withObject "IncomeVerificationWebhookStatus" $ \o ->
    IncomeVerificationWebhookStatus
      <$> (o .:  "id")

-- | ToJSON IncomeVerificationWebhookStatus
instance A.ToJSON IncomeVerificationWebhookStatus where
  toJSON IncomeVerificationWebhookStatus {..} =
   _omitNulls
      [ "id" .= incomeVerificationWebhookStatusId
      ]


-- | Construct a value of type 'IncomeVerificationWebhookStatus' (by applying it's required fields, if any)
mkIncomeVerificationWebhookStatus
  :: Text -- ^ 'incomeVerificationWebhookStatusId' 
  -> IncomeVerificationWebhookStatus
mkIncomeVerificationWebhookStatus incomeVerificationWebhookStatusId =
  IncomeVerificationWebhookStatus
  { incomeVerificationWebhookStatusId
  }

-- ** InflowModel
-- | InflowModel
-- InflowModel
-- 
-- The `inflow_model` allows you to model a test account that receives regular income or make regular payments on a loan. Any transactions generated by the `inflow_model` will appear in addition to randomly generated test data or transactions specified by `override_accounts`.
data InflowModel = InflowModel
  { inflowModelType :: !(Text) -- ^ /Required/ "type" - Inflow model. One of the following:  &#x60;none&#x60;: No income &#x60;monthly-income&#x60;: Income occurs once per month &#x60;monthly-balance-payment&#x60;: Pays off the balance on a liability account at the given statement day of month &#x60;monthly-interest-only-payment&#x60;: Makes an interest-only payment on a liability account at the given statement day of month. Note that account types supported by Liabilities will accrue interest in the Sandbox. The types are account type &#x60;credit&#x60; with subtype &#x60;credit&#x60; or &#x60;paypal&#x60;, and account type &#x60;loan&#x60; with subtype &#x60;student&#x60; or &#x60;mortgage&#x60;.
  , inflowModelIncomeAmount :: !(Double) -- ^ /Required/ "income_amount" - Amount of income per month. This value is required if &#x60;type&#x60; is &#x60;monthly-income&#x60;.
  , inflowModelPaymentDayOfMonth :: !(Double) -- ^ /Required/ "payment_day_of_month" - Number between 1 and 28, or &#x60;last&#x60; meaning the last day of the month. The day of the month on which the income transaction will appear. The name of the income transaction. This field is required if &#x60;type&#x60; is &#x60;monthly-income&#x60;, &#x60;monthly-balance-payment&#x60; or &#x60;monthly-interest-only-payment&#x60;.
  , inflowModelTransactionName :: !(Text) -- ^ /Required/ "transaction_name" - The name of the income transaction. This field is required if &#x60;type&#x60; is &#x60;monthly-income&#x60;, &#x60;monthly-balance-payment&#x60; or &#x60;monthly-interest-only-payment&#x60;.
  , inflowModelStatementDayOfMonth :: !(Text) -- ^ /Required/ "statement_day_of_month" - Number between 1 and 28, or &#x60;last&#x60; meaning the last day of the month. The day of the month on which the balance is calculated for the next payment. The name of the income transaction. This field is required if &#x60;type&#x60; is &#x60;monthly-balance-payment&#x60; or &#x60;monthly-interest-only-payment&#x60;.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InflowModel
instance A.FromJSON InflowModel where
  parseJSON = A.withObject "InflowModel" $ \o ->
    InflowModel
      <$> (o .:  "type")
      <*> (o .:  "income_amount")
      <*> (o .:  "payment_day_of_month")
      <*> (o .:  "transaction_name")
      <*> (o .:  "statement_day_of_month")

-- | ToJSON InflowModel
instance A.ToJSON InflowModel where
  toJSON InflowModel {..} =
   _omitNulls
      [ "type" .= inflowModelType
      , "income_amount" .= inflowModelIncomeAmount
      , "payment_day_of_month" .= inflowModelPaymentDayOfMonth
      , "transaction_name" .= inflowModelTransactionName
      , "statement_day_of_month" .= inflowModelStatementDayOfMonth
      ]


-- | Construct a value of type 'InflowModel' (by applying it's required fields, if any)
mkInflowModel
  :: Text -- ^ 'inflowModelType': Inflow model. One of the following:  `none`: No income `monthly-income`: Income occurs once per month `monthly-balance-payment`: Pays off the balance on a liability account at the given statement day of month `monthly-interest-only-payment`: Makes an interest-only payment on a liability account at the given statement day of month. Note that account types supported by Liabilities will accrue interest in the Sandbox. The types are account type `credit` with subtype `credit` or `paypal`, and account type `loan` with subtype `student` or `mortgage`.
  -> Double -- ^ 'inflowModelIncomeAmount': Amount of income per month. This value is required if `type` is `monthly-income`.
  -> Double -- ^ 'inflowModelPaymentDayOfMonth': Number between 1 and 28, or `last` meaning the last day of the month. The day of the month on which the income transaction will appear. The name of the income transaction. This field is required if `type` is `monthly-income`, `monthly-balance-payment` or `monthly-interest-only-payment`.
  -> Text -- ^ 'inflowModelTransactionName': The name of the income transaction. This field is required if `type` is `monthly-income`, `monthly-balance-payment` or `monthly-interest-only-payment`.
  -> Text -- ^ 'inflowModelStatementDayOfMonth': Number between 1 and 28, or `last` meaning the last day of the month. The day of the month on which the balance is calculated for the next payment. The name of the income transaction. This field is required if `type` is `monthly-balance-payment` or `monthly-interest-only-payment`.
  -> InflowModel
mkInflowModel inflowModelType inflowModelIncomeAmount inflowModelPaymentDayOfMonth inflowModelTransactionName inflowModelStatementDayOfMonth =
  InflowModel
  { inflowModelType
  , inflowModelIncomeAmount
  , inflowModelPaymentDayOfMonth
  , inflowModelTransactionName
  , inflowModelStatementDayOfMonth
  }

-- ** InitialUpdateWebhook
-- | InitialUpdateWebhook
-- InitialUpdateWebhook
-- 
-- Fired when an Item's initial transaction pull is completed. Once this webhook has been fired, transaction data for the most recent 30 days can be fetched for the Item.
data InitialUpdateWebhook = InitialUpdateWebhook
  { initialUpdateWebhookWebhookType :: !(Text) -- ^ /Required/ "webhook_type" - &#x60;TRANSACTIONS&#x60;
  , initialUpdateWebhookWebhookCode :: !(Text) -- ^ /Required/ "webhook_code" - &#x60;INITIAL_UPDATE&#x60;
  , initialUpdateWebhookError :: !(Maybe Text) -- ^ "error" - The error code associated with the webhook.
  , initialUpdateWebhookNewTransactions :: !(Double) -- ^ /Required/ "new_transactions" - The number of new, unfetched transactions available.
  , initialUpdateWebhookItemId :: !(ItemId) -- ^ /Required/ "item_id" - The &#x60;item_id&#x60; of the Item associated with this webhook, warning, or error
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InitialUpdateWebhook
instance A.FromJSON InitialUpdateWebhook where
  parseJSON = A.withObject "InitialUpdateWebhook" $ \o ->
    InitialUpdateWebhook
      <$> (o .:  "webhook_type")
      <*> (o .:  "webhook_code")
      <*> (o .:? "error")
      <*> (o .:  "new_transactions")
      <*> (o .:  "item_id")

-- | ToJSON InitialUpdateWebhook
instance A.ToJSON InitialUpdateWebhook where
  toJSON InitialUpdateWebhook {..} =
   _omitNulls
      [ "webhook_type" .= initialUpdateWebhookWebhookType
      , "webhook_code" .= initialUpdateWebhookWebhookCode
      , "error" .= initialUpdateWebhookError
      , "new_transactions" .= initialUpdateWebhookNewTransactions
      , "item_id" .= initialUpdateWebhookItemId
      ]


-- | Construct a value of type 'InitialUpdateWebhook' (by applying it's required fields, if any)
mkInitialUpdateWebhook
  :: Text -- ^ 'initialUpdateWebhookWebhookType': `TRANSACTIONS`
  -> Text -- ^ 'initialUpdateWebhookWebhookCode': `INITIAL_UPDATE`
  -> Double -- ^ 'initialUpdateWebhookNewTransactions': The number of new, unfetched transactions available.
  -> ItemId -- ^ 'initialUpdateWebhookItemId': The `item_id` of the Item associated with this webhook, warning, or error
  -> InitialUpdateWebhook
mkInitialUpdateWebhook initialUpdateWebhookWebhookType initialUpdateWebhookWebhookCode initialUpdateWebhookNewTransactions initialUpdateWebhookItemId =
  InitialUpdateWebhook
  { initialUpdateWebhookWebhookType
  , initialUpdateWebhookWebhookCode
  , initialUpdateWebhookError = Nothing
  , initialUpdateWebhookNewTransactions
  , initialUpdateWebhookItemId
  }

-- ** Institution
-- | Institution
-- Institution
-- 
-- Details relating to a specific financial institution
data Institution = Institution
  { institutionInstitutionId :: !(Text) -- ^ /Required/ "institution_id" - Unique identifier for the institution
  , institutionName :: !(Text) -- ^ /Required/ "name" - The official name of the institution
  , institutionProducts :: !([Products]) -- ^ /Required/ "products" - A list of the Plaid products supported by the institution
  , institutionCountryCodes :: !([CountryCode]) -- ^ /Required/ "country_codes" - A list of the country codes supported by the institution.
  , institutionUrl :: !(Maybe Text) -- ^ "url" - The URL for the institution&#39;s website
  , institutionPrimaryColor :: !(Maybe Text) -- ^ "primary_color" - Hexadecimal representation of the primary color used by the institution
  , institutionLogo :: !(Maybe Text) -- ^ "logo" - Base64 encoded representation of the institution&#39;s logo
  , institutionRoutingNumbers :: !(Maybe [Text]) -- ^ "routing_numbers" - A partial list of routing numbers associated with the institution. This list is provided for the purpose of looking up institutions by routing number. It is not comprehensive and should never be used as a complete list of routing numbers for an institution.
  , institutionOauth :: !(Bool) -- ^ /Required/ "oauth" - Indicates that the institution has an OAuth login flow. This is primarily relevant to institutions with European country codes.
  , institutionStatus :: !(Maybe InstitutionStatus) -- ^ "status"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Institution
instance A.FromJSON Institution where
  parseJSON = A.withObject "Institution" $ \o ->
    Institution
      <$> (o .:  "institution_id")
      <*> (o .:  "name")
      <*> (o .:  "products")
      <*> (o .:  "country_codes")
      <*> (o .:? "url")
      <*> (o .:? "primary_color")
      <*> (o .:? "logo")
      <*> (o .:? "routing_numbers")
      <*> (o .:  "oauth")
      <*> (o .:? "status")

-- | ToJSON Institution
instance A.ToJSON Institution where
  toJSON Institution {..} =
   _omitNulls
      [ "institution_id" .= institutionInstitutionId
      , "name" .= institutionName
      , "products" .= institutionProducts
      , "country_codes" .= institutionCountryCodes
      , "url" .= institutionUrl
      , "primary_color" .= institutionPrimaryColor
      , "logo" .= institutionLogo
      , "routing_numbers" .= institutionRoutingNumbers
      , "oauth" .= institutionOauth
      , "status" .= institutionStatus
      ]


-- | Construct a value of type 'Institution' (by applying it's required fields, if any)
mkInstitution
  :: Text -- ^ 'institutionInstitutionId': Unique identifier for the institution
  -> Text -- ^ 'institutionName': The official name of the institution
  -> [Products] -- ^ 'institutionProducts': A list of the Plaid products supported by the institution
  -> [CountryCode] -- ^ 'institutionCountryCodes': A list of the country codes supported by the institution.
  -> Bool -- ^ 'institutionOauth': Indicates that the institution has an OAuth login flow. This is primarily relevant to institutions with European country codes.
  -> Institution
mkInstitution institutionInstitutionId institutionName institutionProducts institutionCountryCodes institutionOauth =
  Institution
  { institutionInstitutionId
  , institutionName
  , institutionProducts
  , institutionCountryCodes
  , institutionUrl = Nothing
  , institutionPrimaryColor = Nothing
  , institutionLogo = Nothing
  , institutionRoutingNumbers = Nothing
  , institutionOauth
  , institutionStatus = Nothing
  }

-- ** InstitutionStatus
-- | InstitutionStatus
-- InstitutionStatus
-- 
-- The status of an institution is determined by the health of its Item logins, Transactions updates, Investments updates, Auth requests, Balance requests, and Identity requests. A login attempt is conducted during the initial Item add in Link. If there is not enough traffic to accurately calculate an institution's status, Plaid will return null rather than potentially inaccurate data.  Institution status is accessible in the Dashboard and via the API using the `/institutions/get_by_id` endpoint with the `include_status` option set to true. Note that institution status is not available in the Sandbox environment. 
data InstitutionStatus = InstitutionStatus
  { institutionStatusItemLogins :: !(ProductStatus) -- ^ /Required/ "item_logins"
  , institutionStatusTransactionsUpdates :: !(ProductStatus) -- ^ /Required/ "transactions_updates"
  , institutionStatusAuth :: !(ProductStatus) -- ^ /Required/ "auth"
  , institutionStatusBalance :: !(ProductStatus) -- ^ /Required/ "balance"
  , institutionStatusIdentity :: !(ProductStatus) -- ^ /Required/ "identity"
  , institutionStatusInvestmentsUpdates :: !(ProductStatus) -- ^ /Required/ "investments_updates"
  , institutionStatusHealthIncidents :: !(Maybe [HealthIncident]) -- ^ "health_incidents" - Details of recent health incidents associated with the institution.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InstitutionStatus
instance A.FromJSON InstitutionStatus where
  parseJSON = A.withObject "InstitutionStatus" $ \o ->
    InstitutionStatus
      <$> (o .:  "item_logins")
      <*> (o .:  "transactions_updates")
      <*> (o .:  "auth")
      <*> (o .:  "balance")
      <*> (o .:  "identity")
      <*> (o .:  "investments_updates")
      <*> (o .:? "health_incidents")

-- | ToJSON InstitutionStatus
instance A.ToJSON InstitutionStatus where
  toJSON InstitutionStatus {..} =
   _omitNulls
      [ "item_logins" .= institutionStatusItemLogins
      , "transactions_updates" .= institutionStatusTransactionsUpdates
      , "auth" .= institutionStatusAuth
      , "balance" .= institutionStatusBalance
      , "identity" .= institutionStatusIdentity
      , "investments_updates" .= institutionStatusInvestmentsUpdates
      , "health_incidents" .= institutionStatusHealthIncidents
      ]


-- | Construct a value of type 'InstitutionStatus' (by applying it's required fields, if any)
mkInstitutionStatus
  :: ProductStatus -- ^ 'institutionStatusItemLogins' 
  -> ProductStatus -- ^ 'institutionStatusTransactionsUpdates' 
  -> ProductStatus -- ^ 'institutionStatusAuth' 
  -> ProductStatus -- ^ 'institutionStatusBalance' 
  -> ProductStatus -- ^ 'institutionStatusIdentity' 
  -> ProductStatus -- ^ 'institutionStatusInvestmentsUpdates' 
  -> InstitutionStatus
mkInstitutionStatus institutionStatusItemLogins institutionStatusTransactionsUpdates institutionStatusAuth institutionStatusBalance institutionStatusIdentity institutionStatusInvestmentsUpdates =
  InstitutionStatus
  { institutionStatusItemLogins
  , institutionStatusTransactionsUpdates
  , institutionStatusAuth
  , institutionStatusBalance
  , institutionStatusIdentity
  , institutionStatusInvestmentsUpdates
  , institutionStatusHealthIncidents = Nothing
  }

-- ** InstitutionsGetByIdRequest
-- | InstitutionsGetByIdRequest
-- InstitutionsGetByIdRequest defines the request schema for `/institutions/get_by_id`
data InstitutionsGetByIdRequest = InstitutionsGetByIdRequest
  { institutionsGetByIdRequestClientId :: !(Maybe Text) -- ^ "client_id" - Your Plaid API &#x60;client_id&#x60;.
  , institutionsGetByIdRequestSecret :: !(Maybe Text) -- ^ "secret" - Your Plaid API &#x60;secret&#x60;.
  , institutionsGetByIdRequestInstitutionId :: !(Text) -- ^ /Required/ "institution_id" - The ID of the institution to get details about
  , institutionsGetByIdRequestCountryCodes :: !([CountryCode]) -- ^ /Required/ "country_codes" - Specify an array of Plaid-supported country codes this institution supports, using the ISO-3166-1 alpha-2 country code standard. 
  , institutionsGetByIdRequestOptions :: !(Maybe InstitutionsGetByIdRequestOptions) -- ^ "options"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InstitutionsGetByIdRequest
instance A.FromJSON InstitutionsGetByIdRequest where
  parseJSON = A.withObject "InstitutionsGetByIdRequest" $ \o ->
    InstitutionsGetByIdRequest
      <$> (o .:? "client_id")
      <*> (o .:? "secret")
      <*> (o .:  "institution_id")
      <*> (o .:  "country_codes")
      <*> (o .:? "options")

-- | ToJSON InstitutionsGetByIdRequest
instance A.ToJSON InstitutionsGetByIdRequest where
  toJSON InstitutionsGetByIdRequest {..} =
   _omitNulls
      [ "client_id" .= institutionsGetByIdRequestClientId
      , "secret" .= institutionsGetByIdRequestSecret
      , "institution_id" .= institutionsGetByIdRequestInstitutionId
      , "country_codes" .= institutionsGetByIdRequestCountryCodes
      , "options" .= institutionsGetByIdRequestOptions
      ]


-- | Construct a value of type 'InstitutionsGetByIdRequest' (by applying it's required fields, if any)
mkInstitutionsGetByIdRequest
  :: Text -- ^ 'institutionsGetByIdRequestInstitutionId': The ID of the institution to get details about
  -> [CountryCode] -- ^ 'institutionsGetByIdRequestCountryCodes': Specify an array of Plaid-supported country codes this institution supports, using the ISO-3166-1 alpha-2 country code standard. 
  -> InstitutionsGetByIdRequest
mkInstitutionsGetByIdRequest institutionsGetByIdRequestInstitutionId institutionsGetByIdRequestCountryCodes =
  InstitutionsGetByIdRequest
  { institutionsGetByIdRequestClientId = Nothing
  , institutionsGetByIdRequestSecret = Nothing
  , institutionsGetByIdRequestInstitutionId
  , institutionsGetByIdRequestCountryCodes
  , institutionsGetByIdRequestOptions = Nothing
  }

-- ** InstitutionsGetByIdRequestOptions
-- | InstitutionsGetByIdRequestOptions
-- Specifies optional parameters for `/institutions/get_by_id`. If provided, must not be `null`.
data InstitutionsGetByIdRequestOptions = InstitutionsGetByIdRequestOptions
  { institutionsGetByIdRequestOptionsIncludeOptionalMetadata :: !(Maybe Bool) -- ^ "include_optional_metadata" - When &#x60;true&#x60;, return an institution&#39;s logo, brand color, and URL. When available, the bank&#39;s logo is returned as a base64 encoded 152x152 PNG, the brand color is in hexadecimal format. The default value is &#x60;false&#x60;.  Note that Plaid does not own any of the logos shared by the API and that by accessing or using these logos, you agree that you are doing so at your own risk and will, if necessary, obtain all required permissions from the appropriate rights holders and adhere to any applicable usage guidelines. Plaid disclaims all express or implied warranties with respect to the logos.
  , institutionsGetByIdRequestOptionsIncludeStatus :: !(Maybe Bool) -- ^ "include_status" - If &#x60;true&#x60;, the response will include status information about the institution. Default value is &#x60;false&#x60;.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InstitutionsGetByIdRequestOptions
instance A.FromJSON InstitutionsGetByIdRequestOptions where
  parseJSON = A.withObject "InstitutionsGetByIdRequestOptions" $ \o ->
    InstitutionsGetByIdRequestOptions
      <$> (o .:? "include_optional_metadata")
      <*> (o .:? "include_status")

-- | ToJSON InstitutionsGetByIdRequestOptions
instance A.ToJSON InstitutionsGetByIdRequestOptions where
  toJSON InstitutionsGetByIdRequestOptions {..} =
   _omitNulls
      [ "include_optional_metadata" .= institutionsGetByIdRequestOptionsIncludeOptionalMetadata
      , "include_status" .= institutionsGetByIdRequestOptionsIncludeStatus
      ]


-- | Construct a value of type 'InstitutionsGetByIdRequestOptions' (by applying it's required fields, if any)
mkInstitutionsGetByIdRequestOptions
  :: InstitutionsGetByIdRequestOptions
mkInstitutionsGetByIdRequestOptions =
  InstitutionsGetByIdRequestOptions
  { institutionsGetByIdRequestOptionsIncludeOptionalMetadata = Nothing
  , institutionsGetByIdRequestOptionsIncludeStatus = Nothing
  }

-- ** InstitutionsGetByIdResponse
-- | InstitutionsGetByIdResponse
-- InstitutionsGetByIdResponse defines the response schema for `/institutions/get_by_id`
data InstitutionsGetByIdResponse = InstitutionsGetByIdResponse
  { institutionsGetByIdResponseInstitution :: !(Institution) -- ^ /Required/ "institution"
  , institutionsGetByIdResponseRequestId :: !(Text) -- ^ /Required/ "request_id" - A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InstitutionsGetByIdResponse
instance A.FromJSON InstitutionsGetByIdResponse where
  parseJSON = A.withObject "InstitutionsGetByIdResponse" $ \o ->
    InstitutionsGetByIdResponse
      <$> (o .:  "institution")
      <*> (o .:  "request_id")

-- | ToJSON InstitutionsGetByIdResponse
instance A.ToJSON InstitutionsGetByIdResponse where
  toJSON InstitutionsGetByIdResponse {..} =
   _omitNulls
      [ "institution" .= institutionsGetByIdResponseInstitution
      , "request_id" .= institutionsGetByIdResponseRequestId
      ]


-- | Construct a value of type 'InstitutionsGetByIdResponse' (by applying it's required fields, if any)
mkInstitutionsGetByIdResponse
  :: Institution -- ^ 'institutionsGetByIdResponseInstitution' 
  -> Text -- ^ 'institutionsGetByIdResponseRequestId': A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  -> InstitutionsGetByIdResponse
mkInstitutionsGetByIdResponse institutionsGetByIdResponseInstitution institutionsGetByIdResponseRequestId =
  InstitutionsGetByIdResponse
  { institutionsGetByIdResponseInstitution
  , institutionsGetByIdResponseRequestId
  }

-- ** InstitutionsGetRequest
-- | InstitutionsGetRequest
-- InstitutionsGetRequest defines the request schema for `/institutions/get`
data InstitutionsGetRequest = InstitutionsGetRequest
  { institutionsGetRequestClientId :: !(Maybe Text) -- ^ "client_id" - Your Plaid API &#x60;client_id&#x60;.
  , institutionsGetRequestSecret :: !(Maybe Text) -- ^ "secret" - Your Plaid API &#x60;secret&#x60;.
  , institutionsGetRequestCount :: !(Int) -- ^ /Required/ "count" - The total number of Institutions to return.
  , institutionsGetRequestOffset :: !(Int) -- ^ /Required/ "offset" - The number of Institutions to skip.
  , institutionsGetRequestCountryCodes :: !([CountryCode]) -- ^ /Required/ "country_codes" - Specify an array of Plaid-supported country codes this institution supports, using the ISO-3166-1 alpha-2 country code standard. 
  , institutionsGetRequestOptions :: !(Maybe InstitutionsGetRequestOptions) -- ^ "options"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InstitutionsGetRequest
instance A.FromJSON InstitutionsGetRequest where
  parseJSON = A.withObject "InstitutionsGetRequest" $ \o ->
    InstitutionsGetRequest
      <$> (o .:? "client_id")
      <*> (o .:? "secret")
      <*> (o .:  "count")
      <*> (o .:  "offset")
      <*> (o .:  "country_codes")
      <*> (o .:? "options")

-- | ToJSON InstitutionsGetRequest
instance A.ToJSON InstitutionsGetRequest where
  toJSON InstitutionsGetRequest {..} =
   _omitNulls
      [ "client_id" .= institutionsGetRequestClientId
      , "secret" .= institutionsGetRequestSecret
      , "count" .= institutionsGetRequestCount
      , "offset" .= institutionsGetRequestOffset
      , "country_codes" .= institutionsGetRequestCountryCodes
      , "options" .= institutionsGetRequestOptions
      ]


-- | Construct a value of type 'InstitutionsGetRequest' (by applying it's required fields, if any)
mkInstitutionsGetRequest
  :: Int -- ^ 'institutionsGetRequestCount': The total number of Institutions to return.
  -> Int -- ^ 'institutionsGetRequestOffset': The number of Institutions to skip.
  -> [CountryCode] -- ^ 'institutionsGetRequestCountryCodes': Specify an array of Plaid-supported country codes this institution supports, using the ISO-3166-1 alpha-2 country code standard. 
  -> InstitutionsGetRequest
mkInstitutionsGetRequest institutionsGetRequestCount institutionsGetRequestOffset institutionsGetRequestCountryCodes =
  InstitutionsGetRequest
  { institutionsGetRequestClientId = Nothing
  , institutionsGetRequestSecret = Nothing
  , institutionsGetRequestCount
  , institutionsGetRequestOffset
  , institutionsGetRequestCountryCodes
  , institutionsGetRequestOptions = Nothing
  }

-- ** InstitutionsGetRequestOptions
-- | InstitutionsGetRequestOptions
-- An optional object to filter `/institutions/get` results.
data InstitutionsGetRequestOptions = InstitutionsGetRequestOptions
  { institutionsGetRequestOptionsProducts :: !(Maybe [Products]) -- ^ "products" - Filter the Institutions based on which products they support. 
  , institutionsGetRequestOptionsRoutingNumbers :: !(Maybe [Text]) -- ^ "routing_numbers" - Specify an array of routing numbers to filter institutions.
  , institutionsGetRequestOptionsOauth :: !(Maybe Bool) -- ^ "oauth" - Limit results to institutions with or without OAuth login flows. This is primarily relevant to institutions with European country codes.
  , institutionsGetRequestOptionsIncludeOptionalMetadata :: !(Maybe Bool) -- ^ "include_optional_metadata" - When &#x60;true&#x60;, return the institution&#39;s homepage URL, logo and primary brand color.  Note that Plaid does not own any of the logos shared by the API, and that by accessing or using these logos, you agree that you are doing so at your own risk and will, if necessary, obtain all required permissions from the appropriate rights holders and adhere to any applicable usage guidelines. Plaid disclaims all express or implied warranties with respect to the logos.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InstitutionsGetRequestOptions
instance A.FromJSON InstitutionsGetRequestOptions where
  parseJSON = A.withObject "InstitutionsGetRequestOptions" $ \o ->
    InstitutionsGetRequestOptions
      <$> (o .:? "products")
      <*> (o .:? "routing_numbers")
      <*> (o .:? "oauth")
      <*> (o .:? "include_optional_metadata")

-- | ToJSON InstitutionsGetRequestOptions
instance A.ToJSON InstitutionsGetRequestOptions where
  toJSON InstitutionsGetRequestOptions {..} =
   _omitNulls
      [ "products" .= institutionsGetRequestOptionsProducts
      , "routing_numbers" .= institutionsGetRequestOptionsRoutingNumbers
      , "oauth" .= institutionsGetRequestOptionsOauth
      , "include_optional_metadata" .= institutionsGetRequestOptionsIncludeOptionalMetadata
      ]


-- | Construct a value of type 'InstitutionsGetRequestOptions' (by applying it's required fields, if any)
mkInstitutionsGetRequestOptions
  :: InstitutionsGetRequestOptions
mkInstitutionsGetRequestOptions =
  InstitutionsGetRequestOptions
  { institutionsGetRequestOptionsProducts = Nothing
  , institutionsGetRequestOptionsRoutingNumbers = Nothing
  , institutionsGetRequestOptionsOauth = Nothing
  , institutionsGetRequestOptionsIncludeOptionalMetadata = Nothing
  }

-- ** InstitutionsGetResponse
-- | InstitutionsGetResponse
-- InstitutionsGetResponse defines the response schema for `/institutions/get`
data InstitutionsGetResponse = InstitutionsGetResponse
  { institutionsGetResponseInstitutions :: !([Institution]) -- ^ /Required/ "institutions" - A list of Plaid Institution
  , institutionsGetResponseTotal :: !(Int) -- ^ /Required/ "total" - The number of institutions returned
  , institutionsGetResponseRequestId :: !(Text) -- ^ /Required/ "request_id" - A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InstitutionsGetResponse
instance A.FromJSON InstitutionsGetResponse where
  parseJSON = A.withObject "InstitutionsGetResponse" $ \o ->
    InstitutionsGetResponse
      <$> (o .:  "institutions")
      <*> (o .:  "total")
      <*> (o .:  "request_id")

-- | ToJSON InstitutionsGetResponse
instance A.ToJSON InstitutionsGetResponse where
  toJSON InstitutionsGetResponse {..} =
   _omitNulls
      [ "institutions" .= institutionsGetResponseInstitutions
      , "total" .= institutionsGetResponseTotal
      , "request_id" .= institutionsGetResponseRequestId
      ]


-- | Construct a value of type 'InstitutionsGetResponse' (by applying it's required fields, if any)
mkInstitutionsGetResponse
  :: [Institution] -- ^ 'institutionsGetResponseInstitutions': A list of Plaid Institution
  -> Int -- ^ 'institutionsGetResponseTotal': The number of institutions returned
  -> Text -- ^ 'institutionsGetResponseRequestId': A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  -> InstitutionsGetResponse
mkInstitutionsGetResponse institutionsGetResponseInstitutions institutionsGetResponseTotal institutionsGetResponseRequestId =
  InstitutionsGetResponse
  { institutionsGetResponseInstitutions
  , institutionsGetResponseTotal
  , institutionsGetResponseRequestId
  }

-- ** InstitutionsSearchAccountFilter
-- | InstitutionsSearchAccountFilter
-- InstitutionsSearchAccountFilter
-- 
data InstitutionsSearchAccountFilter = InstitutionsSearchAccountFilter
  { institutionsSearchAccountFilterLoan :: !(Maybe [AccountSubtype]) -- ^ "loan"
  , institutionsSearchAccountFilterDepository :: !(Maybe [AccountSubtype]) -- ^ "depository"
  , institutionsSearchAccountFilterCredit :: !(Maybe [AccountSubtype]) -- ^ "credit"
  , institutionsSearchAccountFilterInvestment :: !(Maybe [AccountSubtype]) -- ^ "investment"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InstitutionsSearchAccountFilter
instance A.FromJSON InstitutionsSearchAccountFilter where
  parseJSON = A.withObject "InstitutionsSearchAccountFilter" $ \o ->
    InstitutionsSearchAccountFilter
      <$> (o .:? "loan")
      <*> (o .:? "depository")
      <*> (o .:? "credit")
      <*> (o .:? "investment")

-- | ToJSON InstitutionsSearchAccountFilter
instance A.ToJSON InstitutionsSearchAccountFilter where
  toJSON InstitutionsSearchAccountFilter {..} =
   _omitNulls
      [ "loan" .= institutionsSearchAccountFilterLoan
      , "depository" .= institutionsSearchAccountFilterDepository
      , "credit" .= institutionsSearchAccountFilterCredit
      , "investment" .= institutionsSearchAccountFilterInvestment
      ]


-- | Construct a value of type 'InstitutionsSearchAccountFilter' (by applying it's required fields, if any)
mkInstitutionsSearchAccountFilter
  :: InstitutionsSearchAccountFilter
mkInstitutionsSearchAccountFilter =
  InstitutionsSearchAccountFilter
  { institutionsSearchAccountFilterLoan = Nothing
  , institutionsSearchAccountFilterDepository = Nothing
  , institutionsSearchAccountFilterCredit = Nothing
  , institutionsSearchAccountFilterInvestment = Nothing
  }

-- ** InstitutionsSearchRequest
-- | InstitutionsSearchRequest
-- InstitutionsSearchRequest defines the request schema for `/institutions/search`
data InstitutionsSearchRequest = InstitutionsSearchRequest
  { institutionsSearchRequestClientId :: !(Maybe Text) -- ^ "client_id" - Your Plaid API &#x60;client_id&#x60;.
  , institutionsSearchRequestSecret :: !(Maybe Text) -- ^ "secret" - Your Plaid API &#x60;secret&#x60;.
  , institutionsSearchRequestQuery :: !(Text) -- ^ /Required/ "query" - The search query. Institutions with names matching the query are returned
  , institutionsSearchRequestProducts :: !([Products]) -- ^ /Required/ "products" - Filter the Institutions based on whether they support all products listed in products. Provide &#x60;null&#x60; to get institutions regardless of supported products
  , institutionsSearchRequestCountryCodes :: !([CountryCode]) -- ^ /Required/ "country_codes" - Specify an array of Plaid-supported country codes this institution supports, using the ISO-3166-1 alpha-2 country code standard. 
  , institutionsSearchRequestOptions :: !(Maybe InstitutionsSearchRequestOptions) -- ^ "options"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InstitutionsSearchRequest
instance A.FromJSON InstitutionsSearchRequest where
  parseJSON = A.withObject "InstitutionsSearchRequest" $ \o ->
    InstitutionsSearchRequest
      <$> (o .:? "client_id")
      <*> (o .:? "secret")
      <*> (o .:  "query")
      <*> (o .:  "products")
      <*> (o .:  "country_codes")
      <*> (o .:? "options")

-- | ToJSON InstitutionsSearchRequest
instance A.ToJSON InstitutionsSearchRequest where
  toJSON InstitutionsSearchRequest {..} =
   _omitNulls
      [ "client_id" .= institutionsSearchRequestClientId
      , "secret" .= institutionsSearchRequestSecret
      , "query" .= institutionsSearchRequestQuery
      , "products" .= institutionsSearchRequestProducts
      , "country_codes" .= institutionsSearchRequestCountryCodes
      , "options" .= institutionsSearchRequestOptions
      ]


-- | Construct a value of type 'InstitutionsSearchRequest' (by applying it's required fields, if any)
mkInstitutionsSearchRequest
  :: Text -- ^ 'institutionsSearchRequestQuery': The search query. Institutions with names matching the query are returned
  -> [Products] -- ^ 'institutionsSearchRequestProducts': Filter the Institutions based on whether they support all products listed in products. Provide `null` to get institutions regardless of supported products
  -> [CountryCode] -- ^ 'institutionsSearchRequestCountryCodes': Specify an array of Plaid-supported country codes this institution supports, using the ISO-3166-1 alpha-2 country code standard. 
  -> InstitutionsSearchRequest
mkInstitutionsSearchRequest institutionsSearchRequestQuery institutionsSearchRequestProducts institutionsSearchRequestCountryCodes =
  InstitutionsSearchRequest
  { institutionsSearchRequestClientId = Nothing
  , institutionsSearchRequestSecret = Nothing
  , institutionsSearchRequestQuery
  , institutionsSearchRequestProducts
  , institutionsSearchRequestCountryCodes
  , institutionsSearchRequestOptions = Nothing
  }

-- ** InstitutionsSearchRequestOptions
-- | InstitutionsSearchRequestOptions
-- An optional object to filter `/institutions/search` results.
data InstitutionsSearchRequestOptions = InstitutionsSearchRequestOptions
  { institutionsSearchRequestOptionsOauth :: !(Maybe Bool) -- ^ "oauth" - Limit results to institutions with or without OAuth login flows. This is primarily relevant to institutions with European country codes
  , institutionsSearchRequestOptionsIncludeOptionalMetadata :: !(Maybe Bool) -- ^ "include_optional_metadata" - When true, return the institution&#39;s homepage URL, logo and primary brand color. Learn more
  , institutionsSearchRequestOptionsAccountFilter :: !(Maybe InstitutionsSearchAccountFilter) -- ^ "account_filter"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InstitutionsSearchRequestOptions
instance A.FromJSON InstitutionsSearchRequestOptions where
  parseJSON = A.withObject "InstitutionsSearchRequestOptions" $ \o ->
    InstitutionsSearchRequestOptions
      <$> (o .:? "oauth")
      <*> (o .:? "include_optional_metadata")
      <*> (o .:? "account_filter")

-- | ToJSON InstitutionsSearchRequestOptions
instance A.ToJSON InstitutionsSearchRequestOptions where
  toJSON InstitutionsSearchRequestOptions {..} =
   _omitNulls
      [ "oauth" .= institutionsSearchRequestOptionsOauth
      , "include_optional_metadata" .= institutionsSearchRequestOptionsIncludeOptionalMetadata
      , "account_filter" .= institutionsSearchRequestOptionsAccountFilter
      ]


-- | Construct a value of type 'InstitutionsSearchRequestOptions' (by applying it's required fields, if any)
mkInstitutionsSearchRequestOptions
  :: InstitutionsSearchRequestOptions
mkInstitutionsSearchRequestOptions =
  InstitutionsSearchRequestOptions
  { institutionsSearchRequestOptionsOauth = Nothing
  , institutionsSearchRequestOptionsIncludeOptionalMetadata = Nothing
  , institutionsSearchRequestOptionsAccountFilter = Nothing
  }

-- ** InstitutionsSearchResponse
-- | InstitutionsSearchResponse
-- InstitutionsSearchResponse defines the response schema for `/institutions/search`
data InstitutionsSearchResponse = InstitutionsSearchResponse
  { institutionsSearchResponseInstitutions :: !([Institution]) -- ^ /Required/ "institutions" - An array of institutions matching the search criteria
  , institutionsSearchResponseRequestId :: !(Text) -- ^ /Required/ "request_id" - A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InstitutionsSearchResponse
instance A.FromJSON InstitutionsSearchResponse where
  parseJSON = A.withObject "InstitutionsSearchResponse" $ \o ->
    InstitutionsSearchResponse
      <$> (o .:  "institutions")
      <*> (o .:  "request_id")

-- | ToJSON InstitutionsSearchResponse
instance A.ToJSON InstitutionsSearchResponse where
  toJSON InstitutionsSearchResponse {..} =
   _omitNulls
      [ "institutions" .= institutionsSearchResponseInstitutions
      , "request_id" .= institutionsSearchResponseRequestId
      ]


-- | Construct a value of type 'InstitutionsSearchResponse' (by applying it's required fields, if any)
mkInstitutionsSearchResponse
  :: [Institution] -- ^ 'institutionsSearchResponseInstitutions': An array of institutions matching the search criteria
  -> Text -- ^ 'institutionsSearchResponseRequestId': A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  -> InstitutionsSearchResponse
mkInstitutionsSearchResponse institutionsSearchResponseInstitutions institutionsSearchResponseRequestId =
  InstitutionsSearchResponse
  { institutionsSearchResponseInstitutions
  , institutionsSearchResponseRequestId
  }

-- ** InvestmentFilter
-- | InvestmentFilter
-- InvestmentFilter
-- 
-- A filter to apply to `investment`-type accounts
data InvestmentFilter = InvestmentFilter
  { investmentFilterAccountSubtypes :: !([AccountSubtype]) -- ^ /Required/ "account_subtypes" - An array of account subtypes to display in Link. If not specified, all account subtypes will be shown. For a full list of valid types and subtypes, see the [Account schema](/docs/api/accounts#accounts-schema). 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InvestmentFilter
instance A.FromJSON InvestmentFilter where
  parseJSON = A.withObject "InvestmentFilter" $ \o ->
    InvestmentFilter
      <$> (o .:  "account_subtypes")

-- | ToJSON InvestmentFilter
instance A.ToJSON InvestmentFilter where
  toJSON InvestmentFilter {..} =
   _omitNulls
      [ "account_subtypes" .= investmentFilterAccountSubtypes
      ]


-- | Construct a value of type 'InvestmentFilter' (by applying it's required fields, if any)
mkInvestmentFilter
  :: [AccountSubtype] -- ^ 'investmentFilterAccountSubtypes': An array of account subtypes to display in Link. If not specified, all account subtypes will be shown. For a full list of valid types and subtypes, see the [Account schema](/docs/api/accounts#accounts-schema). 
  -> InvestmentFilter
mkInvestmentFilter investmentFilterAccountSubtypes =
  InvestmentFilter
  { investmentFilterAccountSubtypes
  }

-- ** InvestmentHoldingsGetRequestOptions
-- | InvestmentHoldingsGetRequestOptions
-- An optional object to filter `/investments/holdings/get` results. If provided, must not be `null`.
data InvestmentHoldingsGetRequestOptions = InvestmentHoldingsGetRequestOptions
  { investmentHoldingsGetRequestOptionsAccountIds :: !(Maybe [Text]) -- ^ "account_ids" - An array of &#x60;account_id&#x60;s to retrieve for the Item. An error will be returned if a provided &#x60;account_id&#x60; is not associated with the Item.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InvestmentHoldingsGetRequestOptions
instance A.FromJSON InvestmentHoldingsGetRequestOptions where
  parseJSON = A.withObject "InvestmentHoldingsGetRequestOptions" $ \o ->
    InvestmentHoldingsGetRequestOptions
      <$> (o .:? "account_ids")

-- | ToJSON InvestmentHoldingsGetRequestOptions
instance A.ToJSON InvestmentHoldingsGetRequestOptions where
  toJSON InvestmentHoldingsGetRequestOptions {..} =
   _omitNulls
      [ "account_ids" .= investmentHoldingsGetRequestOptionsAccountIds
      ]


-- | Construct a value of type 'InvestmentHoldingsGetRequestOptions' (by applying it's required fields, if any)
mkInvestmentHoldingsGetRequestOptions
  :: InvestmentHoldingsGetRequestOptions
mkInvestmentHoldingsGetRequestOptions =
  InvestmentHoldingsGetRequestOptions
  { investmentHoldingsGetRequestOptionsAccountIds = Nothing
  }

-- ** InvestmentTransaction
-- | InvestmentTransaction
-- InvestmentTransaction
-- 
-- A transaction within an investment account.
data InvestmentTransaction = InvestmentTransaction
  { investmentTransactionInvestmentTransactionId :: !(Text) -- ^ /Required/ "investment_transaction_id" - The ID of the Investment transaction, unique across all Plaid transactions. Like all Plaid identifiers, the &#x60;investment_transaction_id&#x60; is case sensitive.
  , investmentTransactionCancelTransactionId :: !(Maybe Text) -- ^ "cancel_transaction_id"
  , investmentTransactionAccountId :: !(Text) -- ^ /Required/ "account_id" - The &#x60;account_id&#x60; of the account against which this transaction posted.
  , investmentTransactionSecurityId :: !(Maybe Text) -- ^ "security_id" - The &#x60;security_id&#x60; to which this transaction is related.
  , investmentTransactionDate :: !(Text) -- ^ /Required/ "date" - The ISO-8601 posting date for the transaction, or transacted date for pending transactions.
  , investmentTransactionName :: !(Text) -- ^ /Required/ "name" - The institution’s description of the transaction.
  , investmentTransactionQuantity :: !(Double) -- ^ /Required/ "quantity" - The number of units of the security involved in this transactions
  , investmentTransactionAmount :: !(Double) -- ^ /Required/ "amount" - The complete value of the transaction. Positive values when cash is debited, e.g. purchases of stock; negative values when cash is credited, e.g. sales of stock. Treatment remains the same for cash-only movements unassociated with securities.
  , investmentTransactionPrice :: !(Double) -- ^ /Required/ "price" - The price of the security at which this transaction occurred.
  , investmentTransactionFees :: !(Maybe Double) -- ^ "fees" - The combined value of all fees applied to this transaction
  , investmentTransactionType :: !(E'Type5) -- ^ /Required/ "type" - Value is one of the following: &#x60;buy&#x60;: Buying an investment &#x60;sell&#x60;: Selling an investment &#x60;cancel&#x60;: A cancellation of a pending transaction  &#x60;cash&#x60;: Activity that modifies a cash position &#x60;fee&#x60;: A fee on the account &#x60;transfer&#x60;: Activity which modifies a position, but not through buy/sell activity e.g. options exercise, portfolio transfer
  , investmentTransactionSubtype :: !(E'Subtype) -- ^ /Required/ "subtype" - For descriptions of possible transaction subtypes, see [Investment transaction subtypes schema](/docs/api/accounts/#investment-transaction-subtypes-schema).
  , investmentTransactionIsoCurrencyCode :: !(Maybe Text) -- ^ "iso_currency_code" - The ISO-4217 currency code of the transaction. Always &#x60;null&#x60; if &#x60;unofficial_currency_code&#x60; is non-&#x60;null&#x60;.
  , investmentTransactionUnofficialCurrencyCode :: !(Maybe Text) -- ^ "unofficial_currency_code" - The unofficial currency code associated with the holding. Always &#x60;null&#x60; if &#x60;iso_currency_code&#x60; is non-&#x60;null&#x60;. Unofficial currency codes are used for currencies that do not have official ISO currency codes, such as cryptocurrencies and the currencies of certain countries.  See the [currency code schema](/docs/api/accounts#currency-code-schema) for a full listing of supported &#x60;iso_currency_code&#x60;s.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InvestmentTransaction
instance A.FromJSON InvestmentTransaction where
  parseJSON = A.withObject "InvestmentTransaction" $ \o ->
    InvestmentTransaction
      <$> (o .:  "investment_transaction_id")
      <*> (o .:? "cancel_transaction_id")
      <*> (o .:  "account_id")
      <*> (o .:? "security_id")
      <*> (o .:  "date")
      <*> (o .:  "name")
      <*> (o .:  "quantity")
      <*> (o .:  "amount")
      <*> (o .:  "price")
      <*> (o .:? "fees")
      <*> (o .:  "type")
      <*> (o .:  "subtype")
      <*> (o .:? "iso_currency_code")
      <*> (o .:? "unofficial_currency_code")

-- | ToJSON InvestmentTransaction
instance A.ToJSON InvestmentTransaction where
  toJSON InvestmentTransaction {..} =
   _omitNulls
      [ "investment_transaction_id" .= investmentTransactionInvestmentTransactionId
      , "cancel_transaction_id" .= investmentTransactionCancelTransactionId
      , "account_id" .= investmentTransactionAccountId
      , "security_id" .= investmentTransactionSecurityId
      , "date" .= investmentTransactionDate
      , "name" .= investmentTransactionName
      , "quantity" .= investmentTransactionQuantity
      , "amount" .= investmentTransactionAmount
      , "price" .= investmentTransactionPrice
      , "fees" .= investmentTransactionFees
      , "type" .= investmentTransactionType
      , "subtype" .= investmentTransactionSubtype
      , "iso_currency_code" .= investmentTransactionIsoCurrencyCode
      , "unofficial_currency_code" .= investmentTransactionUnofficialCurrencyCode
      ]


-- | Construct a value of type 'InvestmentTransaction' (by applying it's required fields, if any)
mkInvestmentTransaction
  :: Text -- ^ 'investmentTransactionInvestmentTransactionId': The ID of the Investment transaction, unique across all Plaid transactions. Like all Plaid identifiers, the `investment_transaction_id` is case sensitive.
  -> Text -- ^ 'investmentTransactionAccountId': The `account_id` of the account against which this transaction posted.
  -> Text -- ^ 'investmentTransactionDate': The ISO-8601 posting date for the transaction, or transacted date for pending transactions.
  -> Text -- ^ 'investmentTransactionName': The institution’s description of the transaction.
  -> Double -- ^ 'investmentTransactionQuantity': The number of units of the security involved in this transactions
  -> Double -- ^ 'investmentTransactionAmount': The complete value of the transaction. Positive values when cash is debited, e.g. purchases of stock; negative values when cash is credited, e.g. sales of stock. Treatment remains the same for cash-only movements unassociated with securities.
  -> Double -- ^ 'investmentTransactionPrice': The price of the security at which this transaction occurred.
  -> E'Type5 -- ^ 'investmentTransactionType': Value is one of the following: `buy`: Buying an investment `sell`: Selling an investment `cancel`: A cancellation of a pending transaction  `cash`: Activity that modifies a cash position `fee`: A fee on the account `transfer`: Activity which modifies a position, but not through buy/sell activity e.g. options exercise, portfolio transfer
  -> E'Subtype -- ^ 'investmentTransactionSubtype': For descriptions of possible transaction subtypes, see [Investment transaction subtypes schema](/docs/api/accounts/#investment-transaction-subtypes-schema).
  -> InvestmentTransaction
mkInvestmentTransaction investmentTransactionInvestmentTransactionId investmentTransactionAccountId investmentTransactionDate investmentTransactionName investmentTransactionQuantity investmentTransactionAmount investmentTransactionPrice investmentTransactionType investmentTransactionSubtype =
  InvestmentTransaction
  { investmentTransactionInvestmentTransactionId
  , investmentTransactionCancelTransactionId = Nothing
  , investmentTransactionAccountId
  , investmentTransactionSecurityId = Nothing
  , investmentTransactionDate
  , investmentTransactionName
  , investmentTransactionQuantity
  , investmentTransactionAmount
  , investmentTransactionPrice
  , investmentTransactionFees = Nothing
  , investmentTransactionType
  , investmentTransactionSubtype
  , investmentTransactionIsoCurrencyCode = Nothing
  , investmentTransactionUnofficialCurrencyCode = Nothing
  }

-- ** InvestmentsDefaultUpdateWebhook
-- | InvestmentsDefaultUpdateWebhook
-- TransactionsUpdateInvestmentsWebhook
-- 
-- Fired when new or canceled transactions have been detected on an investment account.
data InvestmentsDefaultUpdateWebhook = InvestmentsDefaultUpdateWebhook
  { investmentsDefaultUpdateWebhookWebhookType :: !(Text) -- ^ /Required/ "webhook_type" - &#x60;INVESTMENTS_TRANSACTIONS&#x60;
  , investmentsDefaultUpdateWebhookWebhookCode :: !(Text) -- ^ /Required/ "webhook_code" - &#x60;DEFAULT_UPDATE&#x60;
  , investmentsDefaultUpdateWebhookItemId :: !(ItemId) -- ^ /Required/ "item_id" - The &#x60;item_id&#x60; of the Item associated with this webhook, warning, or error
  , investmentsDefaultUpdateWebhookError :: !(Maybe Error) -- ^ "error"
  , investmentsDefaultUpdateWebhookNewInvestmentsTransactions :: !(Double) -- ^ /Required/ "new_investments_transactions" - The number of new transactions reported since the last time this webhook was fired.
  , investmentsDefaultUpdateWebhookCanceledInvestmentsTransactions :: !(Double) -- ^ /Required/ "canceled_investments_transactions" - The number of canceled transactions reported since the last time this webhook was fired.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InvestmentsDefaultUpdateWebhook
instance A.FromJSON InvestmentsDefaultUpdateWebhook where
  parseJSON = A.withObject "InvestmentsDefaultUpdateWebhook" $ \o ->
    InvestmentsDefaultUpdateWebhook
      <$> (o .:  "webhook_type")
      <*> (o .:  "webhook_code")
      <*> (o .:  "item_id")
      <*> (o .:? "error")
      <*> (o .:  "new_investments_transactions")
      <*> (o .:  "canceled_investments_transactions")

-- | ToJSON InvestmentsDefaultUpdateWebhook
instance A.ToJSON InvestmentsDefaultUpdateWebhook where
  toJSON InvestmentsDefaultUpdateWebhook {..} =
   _omitNulls
      [ "webhook_type" .= investmentsDefaultUpdateWebhookWebhookType
      , "webhook_code" .= investmentsDefaultUpdateWebhookWebhookCode
      , "item_id" .= investmentsDefaultUpdateWebhookItemId
      , "error" .= investmentsDefaultUpdateWebhookError
      , "new_investments_transactions" .= investmentsDefaultUpdateWebhookNewInvestmentsTransactions
      , "canceled_investments_transactions" .= investmentsDefaultUpdateWebhookCanceledInvestmentsTransactions
      ]


-- | Construct a value of type 'InvestmentsDefaultUpdateWebhook' (by applying it's required fields, if any)
mkInvestmentsDefaultUpdateWebhook
  :: Text -- ^ 'investmentsDefaultUpdateWebhookWebhookType': `INVESTMENTS_TRANSACTIONS`
  -> Text -- ^ 'investmentsDefaultUpdateWebhookWebhookCode': `DEFAULT_UPDATE`
  -> ItemId -- ^ 'investmentsDefaultUpdateWebhookItemId': The `item_id` of the Item associated with this webhook, warning, or error
  -> Double -- ^ 'investmentsDefaultUpdateWebhookNewInvestmentsTransactions': The number of new transactions reported since the last time this webhook was fired.
  -> Double -- ^ 'investmentsDefaultUpdateWebhookCanceledInvestmentsTransactions': The number of canceled transactions reported since the last time this webhook was fired.
  -> InvestmentsDefaultUpdateWebhook
mkInvestmentsDefaultUpdateWebhook investmentsDefaultUpdateWebhookWebhookType investmentsDefaultUpdateWebhookWebhookCode investmentsDefaultUpdateWebhookItemId investmentsDefaultUpdateWebhookNewInvestmentsTransactions investmentsDefaultUpdateWebhookCanceledInvestmentsTransactions =
  InvestmentsDefaultUpdateWebhook
  { investmentsDefaultUpdateWebhookWebhookType
  , investmentsDefaultUpdateWebhookWebhookCode
  , investmentsDefaultUpdateWebhookItemId
  , investmentsDefaultUpdateWebhookError = Nothing
  , investmentsDefaultUpdateWebhookNewInvestmentsTransactions
  , investmentsDefaultUpdateWebhookCanceledInvestmentsTransactions
  }

-- ** InvestmentsHoldingsGetRequest
-- | InvestmentsHoldingsGetRequest
-- InvestmentsHoldingsGetRequest defines the request schema for `/investments/holdings/get`
data InvestmentsHoldingsGetRequest = InvestmentsHoldingsGetRequest
  { investmentsHoldingsGetRequestClientId :: !(Maybe Text) -- ^ "client_id" - Your Plaid API &#x60;client_id&#x60;.
  , investmentsHoldingsGetRequestSecret :: !(Maybe Text) -- ^ "secret" - Your Plaid API &#x60;secret&#x60;.
  , investmentsHoldingsGetRequestAccessToken :: !(AccessToken) -- ^ /Required/ "access_token" - The access token associated with the Item data is being requested for.
  , investmentsHoldingsGetRequestOptions :: !(Maybe InvestmentHoldingsGetRequestOptions) -- ^ "options"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InvestmentsHoldingsGetRequest
instance A.FromJSON InvestmentsHoldingsGetRequest where
  parseJSON = A.withObject "InvestmentsHoldingsGetRequest" $ \o ->
    InvestmentsHoldingsGetRequest
      <$> (o .:? "client_id")
      <*> (o .:? "secret")
      <*> (o .:  "access_token")
      <*> (o .:? "options")

-- | ToJSON InvestmentsHoldingsGetRequest
instance A.ToJSON InvestmentsHoldingsGetRequest where
  toJSON InvestmentsHoldingsGetRequest {..} =
   _omitNulls
      [ "client_id" .= investmentsHoldingsGetRequestClientId
      , "secret" .= investmentsHoldingsGetRequestSecret
      , "access_token" .= investmentsHoldingsGetRequestAccessToken
      , "options" .= investmentsHoldingsGetRequestOptions
      ]


-- | Construct a value of type 'InvestmentsHoldingsGetRequest' (by applying it's required fields, if any)
mkInvestmentsHoldingsGetRequest
  :: AccessToken -- ^ 'investmentsHoldingsGetRequestAccessToken': The access token associated with the Item data is being requested for.
  -> InvestmentsHoldingsGetRequest
mkInvestmentsHoldingsGetRequest investmentsHoldingsGetRequestAccessToken =
  InvestmentsHoldingsGetRequest
  { investmentsHoldingsGetRequestClientId = Nothing
  , investmentsHoldingsGetRequestSecret = Nothing
  , investmentsHoldingsGetRequestAccessToken
  , investmentsHoldingsGetRequestOptions = Nothing
  }

-- ** InvestmentsHoldingsGetResponse
-- | InvestmentsHoldingsGetResponse
-- InvestmentsHoldingsGetResponse defines the response schema for `/investments/holdings/get`
data InvestmentsHoldingsGetResponse = InvestmentsHoldingsGetResponse
  { investmentsHoldingsGetResponseAccounts :: !([AccountBase]) -- ^ /Required/ "accounts" - The accounts associated with the Item
  , investmentsHoldingsGetResponseHoldings :: !([Holding]) -- ^ /Required/ "holdings" - The holdings belonging to investment accounts associated with the Item. Details of the securities in the holdings are provided in the &#x60;securities&#x60; field. 
  , investmentsHoldingsGetResponseSecurities :: !([Security]) -- ^ /Required/ "securities" - Objects describing the securities held in the accounts associated with the Item. 
  , investmentsHoldingsGetResponseItem :: !(Item) -- ^ /Required/ "item"
  , investmentsHoldingsGetResponseRequestId :: !(Text) -- ^ /Required/ "request_id" - A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InvestmentsHoldingsGetResponse
instance A.FromJSON InvestmentsHoldingsGetResponse where
  parseJSON = A.withObject "InvestmentsHoldingsGetResponse" $ \o ->
    InvestmentsHoldingsGetResponse
      <$> (o .:  "accounts")
      <*> (o .:  "holdings")
      <*> (o .:  "securities")
      <*> (o .:  "item")
      <*> (o .:  "request_id")

-- | ToJSON InvestmentsHoldingsGetResponse
instance A.ToJSON InvestmentsHoldingsGetResponse where
  toJSON InvestmentsHoldingsGetResponse {..} =
   _omitNulls
      [ "accounts" .= investmentsHoldingsGetResponseAccounts
      , "holdings" .= investmentsHoldingsGetResponseHoldings
      , "securities" .= investmentsHoldingsGetResponseSecurities
      , "item" .= investmentsHoldingsGetResponseItem
      , "request_id" .= investmentsHoldingsGetResponseRequestId
      ]


-- | Construct a value of type 'InvestmentsHoldingsGetResponse' (by applying it's required fields, if any)
mkInvestmentsHoldingsGetResponse
  :: [AccountBase] -- ^ 'investmentsHoldingsGetResponseAccounts': The accounts associated with the Item
  -> [Holding] -- ^ 'investmentsHoldingsGetResponseHoldings': The holdings belonging to investment accounts associated with the Item. Details of the securities in the holdings are provided in the `securities` field. 
  -> [Security] -- ^ 'investmentsHoldingsGetResponseSecurities': Objects describing the securities held in the accounts associated with the Item. 
  -> Item -- ^ 'investmentsHoldingsGetResponseItem' 
  -> Text -- ^ 'investmentsHoldingsGetResponseRequestId': A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  -> InvestmentsHoldingsGetResponse
mkInvestmentsHoldingsGetResponse investmentsHoldingsGetResponseAccounts investmentsHoldingsGetResponseHoldings investmentsHoldingsGetResponseSecurities investmentsHoldingsGetResponseItem investmentsHoldingsGetResponseRequestId =
  InvestmentsHoldingsGetResponse
  { investmentsHoldingsGetResponseAccounts
  , investmentsHoldingsGetResponseHoldings
  , investmentsHoldingsGetResponseSecurities
  , investmentsHoldingsGetResponseItem
  , investmentsHoldingsGetResponseRequestId
  }

-- ** InvestmentsTransactionsGetRequest
-- | InvestmentsTransactionsGetRequest
-- InvestmentsTransactionsGetRequest defines the request schema for `/investments/transactions/get`
data InvestmentsTransactionsGetRequest = InvestmentsTransactionsGetRequest
  { investmentsTransactionsGetRequestClientId :: !(Maybe Text) -- ^ "client_id" - Your Plaid API &#x60;client_id&#x60;.
  , investmentsTransactionsGetRequestSecret :: !(Maybe Text) -- ^ "secret" - Your Plaid API &#x60;secret&#x60;.
  , investmentsTransactionsGetRequestAccessToken :: !(AccessToken) -- ^ /Required/ "access_token" - The access token associated with the Item data is being requested for.
  , investmentsTransactionsGetRequestStartDate :: !(Date) -- ^ /Required/ "start_date" - The earliest date for which to fetch transaction history. Dates should be formatted as YYYY-MM-DD.
  , investmentsTransactionsGetRequestEndDate :: !(Date) -- ^ /Required/ "end_date" - The most recent date for which to fetch transaction history. Dates should be formatted as YYYY-MM-DD.
  , investmentsTransactionsGetRequestOptions :: !(Maybe InvestmentsTransactionsGetRequestOptions) -- ^ "options"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InvestmentsTransactionsGetRequest
instance A.FromJSON InvestmentsTransactionsGetRequest where
  parseJSON = A.withObject "InvestmentsTransactionsGetRequest" $ \o ->
    InvestmentsTransactionsGetRequest
      <$> (o .:? "client_id")
      <*> (o .:? "secret")
      <*> (o .:  "access_token")
      <*> (o .:  "start_date")
      <*> (o .:  "end_date")
      <*> (o .:? "options")

-- | ToJSON InvestmentsTransactionsGetRequest
instance A.ToJSON InvestmentsTransactionsGetRequest where
  toJSON InvestmentsTransactionsGetRequest {..} =
   _omitNulls
      [ "client_id" .= investmentsTransactionsGetRequestClientId
      , "secret" .= investmentsTransactionsGetRequestSecret
      , "access_token" .= investmentsTransactionsGetRequestAccessToken
      , "start_date" .= investmentsTransactionsGetRequestStartDate
      , "end_date" .= investmentsTransactionsGetRequestEndDate
      , "options" .= investmentsTransactionsGetRequestOptions
      ]


-- | Construct a value of type 'InvestmentsTransactionsGetRequest' (by applying it's required fields, if any)
mkInvestmentsTransactionsGetRequest
  :: AccessToken -- ^ 'investmentsTransactionsGetRequestAccessToken': The access token associated with the Item data is being requested for.
  -> Date -- ^ 'investmentsTransactionsGetRequestStartDate': The earliest date for which to fetch transaction history. Dates should be formatted as YYYY-MM-DD.
  -> Date -- ^ 'investmentsTransactionsGetRequestEndDate': The most recent date for which to fetch transaction history. Dates should be formatted as YYYY-MM-DD.
  -> InvestmentsTransactionsGetRequest
mkInvestmentsTransactionsGetRequest investmentsTransactionsGetRequestAccessToken investmentsTransactionsGetRequestStartDate investmentsTransactionsGetRequestEndDate =
  InvestmentsTransactionsGetRequest
  { investmentsTransactionsGetRequestClientId = Nothing
  , investmentsTransactionsGetRequestSecret = Nothing
  , investmentsTransactionsGetRequestAccessToken
  , investmentsTransactionsGetRequestStartDate
  , investmentsTransactionsGetRequestEndDate
  , investmentsTransactionsGetRequestOptions = Nothing
  }

-- ** InvestmentsTransactionsGetRequestOptions
-- | InvestmentsTransactionsGetRequestOptions
-- An optional object to filter `/investments/transactions/get` results. If provided, must be non-`null`.
data InvestmentsTransactionsGetRequestOptions = InvestmentsTransactionsGetRequestOptions
  { investmentsTransactionsGetRequestOptionsAccountIds :: !(Maybe [Text]) -- ^ "account_ids" - An array of &#x60;account_ids&#x60; to retrieve for the Item.
  , investmentsTransactionsGetRequestOptionsCount :: !(Maybe Int) -- ^ "count" - The number of transactions to fetch. 
  , investmentsTransactionsGetRequestOptionsOffset :: !(Maybe Int) -- ^ "offset" - The number of transactions to skip when fetching transaction history
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InvestmentsTransactionsGetRequestOptions
instance A.FromJSON InvestmentsTransactionsGetRequestOptions where
  parseJSON = A.withObject "InvestmentsTransactionsGetRequestOptions" $ \o ->
    InvestmentsTransactionsGetRequestOptions
      <$> (o .:? "account_ids")
      <*> (o .:? "count")
      <*> (o .:? "offset")

-- | ToJSON InvestmentsTransactionsGetRequestOptions
instance A.ToJSON InvestmentsTransactionsGetRequestOptions where
  toJSON InvestmentsTransactionsGetRequestOptions {..} =
   _omitNulls
      [ "account_ids" .= investmentsTransactionsGetRequestOptionsAccountIds
      , "count" .= investmentsTransactionsGetRequestOptionsCount
      , "offset" .= investmentsTransactionsGetRequestOptionsOffset
      ]


-- | Construct a value of type 'InvestmentsTransactionsGetRequestOptions' (by applying it's required fields, if any)
mkInvestmentsTransactionsGetRequestOptions
  :: InvestmentsTransactionsGetRequestOptions
mkInvestmentsTransactionsGetRequestOptions =
  InvestmentsTransactionsGetRequestOptions
  { investmentsTransactionsGetRequestOptionsAccountIds = Nothing
  , investmentsTransactionsGetRequestOptionsCount = Nothing
  , investmentsTransactionsGetRequestOptionsOffset = Nothing
  }

-- ** InvestmentsTransactionsGetResponse
-- | InvestmentsTransactionsGetResponse
-- InvestmentsTransactionsGetResponse defines the response schema for `/investments/transactions/get`
data InvestmentsTransactionsGetResponse = InvestmentsTransactionsGetResponse
  { investmentsTransactionsGetResponseItem :: !(Item) -- ^ /Required/ "item"
  , investmentsTransactionsGetResponseAccounts :: !([AccountBase]) -- ^ /Required/ "accounts" - The accounts for which transaction history is being fetched.
  , investmentsTransactionsGetResponseSecurities :: !([Security]) -- ^ /Required/ "securities" - All securities for which there is a corresponding transaction being fetched.
  , investmentsTransactionsGetResponseInvestmentTransactions :: !([InvestmentTransaction]) -- ^ /Required/ "investment_transactions" - The transactions being fetched
  , investmentsTransactionsGetResponseTotalInvestmentTransactions :: !(Int) -- ^ /Required/ "total_investment_transactions" - The total number of transactions available within the date range specified. If &#x60;total_investment_transactions&#x60; is larger than the size of the &#x60;transactions&#x60; array, more transactions are available and can be fetched via manipulating the &#x60;offset&#x60; parameter.&#39;
  , investmentsTransactionsGetResponseRequestId :: !(Text) -- ^ /Required/ "request_id" - A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InvestmentsTransactionsGetResponse
instance A.FromJSON InvestmentsTransactionsGetResponse where
  parseJSON = A.withObject "InvestmentsTransactionsGetResponse" $ \o ->
    InvestmentsTransactionsGetResponse
      <$> (o .:  "item")
      <*> (o .:  "accounts")
      <*> (o .:  "securities")
      <*> (o .:  "investment_transactions")
      <*> (o .:  "total_investment_transactions")
      <*> (o .:  "request_id")

-- | ToJSON InvestmentsTransactionsGetResponse
instance A.ToJSON InvestmentsTransactionsGetResponse where
  toJSON InvestmentsTransactionsGetResponse {..} =
   _omitNulls
      [ "item" .= investmentsTransactionsGetResponseItem
      , "accounts" .= investmentsTransactionsGetResponseAccounts
      , "securities" .= investmentsTransactionsGetResponseSecurities
      , "investment_transactions" .= investmentsTransactionsGetResponseInvestmentTransactions
      , "total_investment_transactions" .= investmentsTransactionsGetResponseTotalInvestmentTransactions
      , "request_id" .= investmentsTransactionsGetResponseRequestId
      ]


-- | Construct a value of type 'InvestmentsTransactionsGetResponse' (by applying it's required fields, if any)
mkInvestmentsTransactionsGetResponse
  :: Item -- ^ 'investmentsTransactionsGetResponseItem' 
  -> [AccountBase] -- ^ 'investmentsTransactionsGetResponseAccounts': The accounts for which transaction history is being fetched.
  -> [Security] -- ^ 'investmentsTransactionsGetResponseSecurities': All securities for which there is a corresponding transaction being fetched.
  -> [InvestmentTransaction] -- ^ 'investmentsTransactionsGetResponseInvestmentTransactions': The transactions being fetched
  -> Int -- ^ 'investmentsTransactionsGetResponseTotalInvestmentTransactions': The total number of transactions available within the date range specified. If `total_investment_transactions` is larger than the size of the `transactions` array, more transactions are available and can be fetched via manipulating the `offset` parameter.'
  -> Text -- ^ 'investmentsTransactionsGetResponseRequestId': A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  -> InvestmentsTransactionsGetResponse
mkInvestmentsTransactionsGetResponse investmentsTransactionsGetResponseItem investmentsTransactionsGetResponseAccounts investmentsTransactionsGetResponseSecurities investmentsTransactionsGetResponseInvestmentTransactions investmentsTransactionsGetResponseTotalInvestmentTransactions investmentsTransactionsGetResponseRequestId =
  InvestmentsTransactionsGetResponse
  { investmentsTransactionsGetResponseItem
  , investmentsTransactionsGetResponseAccounts
  , investmentsTransactionsGetResponseSecurities
  , investmentsTransactionsGetResponseInvestmentTransactions
  , investmentsTransactionsGetResponseTotalInvestmentTransactions
  , investmentsTransactionsGetResponseRequestId
  }

-- ** Item
-- | Item
-- Metadata about the Item.
data Item = Item
  { itemItemId :: !(ItemId) -- ^ /Required/ "item_id" - The Plaid Item ID. The &#x60;item_id&#x60; is always unique; linking the same account at the same institution twice will result in two Items with different &#x60;item_id&#x60; values. Like all Plaid identifiers, the &#x60;item_id&#x60; is case-sensitive.
  , itemInstitutionId :: !(Maybe Text) -- ^ "institution_id" - The Plaid Institution ID associated with the Item. Field is &#x60;null&#x60; for Items created via Same Day Micro-deposits.
  , itemWebhook :: !(Maybe Text) -- ^ "webhook" - The URL registered to receive webhooks for the Item.
  , itemError :: !(Maybe Error) -- ^ "error"
  , itemAvailableProducts :: !([Products]) -- ^ /Required/ "available_products" - A list of products available for the Item that have not yet been accessed.
  , itemBilledProducts :: !([Products]) -- ^ /Required/ "billed_products" - A list of products that have been billed for the Item. Note - &#x60;billed_products&#x60; is populated in all environments but only requests in Production are billed. 
  , itemConsentedProducts :: !(Maybe [Products]) -- ^ "consented_products" - A list of products that have gone through consent collection for the Item. Only present for those enabled in the [Data Transparency](https://plaid.com/docs/link/data-transparency-messaging-migration-guide) beta. If you are not enrolled in Data Transparency, this field is not used.
  , itemConsentExpirationTime :: !(Maybe TI.UTCTime) -- ^ "consent_expiration_time" - The RFC 3339 timestamp after which the consent provided by the end user will expire. Upon consent expiration, the item will enter the &#x60;ITEM_LOGIN_REQUIRED&#x60; error state. To circumvent the &#x60;ITEM_LOGIN_REQUIRED&#x60; error and maintain continuous consent, the end user can reauthenticate via Link’s update mode in advance of the consent expiration time.  Note - This is only relevant for European institutions subject to PSD2 regulations mandating a 90-day consent window. For all other institutions, this field will be null.
  , itemUpdateType :: !(E'UpdateType) -- ^ /Required/ "update_type" - Indicates whether an Item requires user interaction to be updated, which can be the case for Items with some forms of two-factor authentication.  &#x60;background&#x60; - Item can be updated in the background  &#x60;requires_user_authentication&#x60; - Item requires user interaction to be updated
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Item
instance A.FromJSON Item where
  parseJSON = A.withObject "Item" $ \o ->
    Item
      <$> (o .:  "item_id")
      <*> (o .:? "institution_id")
      <*> (o .:? "webhook")
      <*> (o .:? "error")
      <*> (o .:  "available_products")
      <*> (o .:  "billed_products")
      <*> (o .:? "consented_products")
      <*> (fmap unDateTime <$> (o .:? "consent_expiration_time"))
      <*> (o .:  "update_type")

-- | ToJSON Item
instance A.ToJSON Item where
  toJSON Item {..} =
   _omitNulls
      [ "item_id" .= itemItemId
      , "institution_id" .= itemInstitutionId
      , "webhook" .= itemWebhook
      , "error" .= itemError
      , "available_products" .= itemAvailableProducts
      , "billed_products" .= itemBilledProducts
      , "consented_products" .= itemConsentedProducts
      , "consent_expiration_time" .= itemConsentExpirationTime
      , "update_type" .= itemUpdateType
      ]


-- | Construct a value of type 'Item' (by applying it's required fields, if any)
mkItem
  :: ItemId -- ^ 'itemItemId': The Plaid Item ID. The `item_id` is always unique; linking the same account at the same institution twice will result in two Items with different `item_id` values. Like all Plaid identifiers, the `item_id` is case-sensitive.
  -> [Products] -- ^ 'itemAvailableProducts': A list of products available for the Item that have not yet been accessed.
  -> [Products] -- ^ 'itemBilledProducts': A list of products that have been billed for the Item. Note - `billed_products` is populated in all environments but only requests in Production are billed. 
  -> E'UpdateType -- ^ 'itemUpdateType': Indicates whether an Item requires user interaction to be updated, which can be the case for Items with some forms of two-factor authentication.  `background` - Item can be updated in the background  `requires_user_authentication` - Item requires user interaction to be updated
  -> Item
mkItem itemItemId itemAvailableProducts itemBilledProducts itemUpdateType =
  Item
  { itemItemId
  , itemInstitutionId = Nothing
  , itemWebhook = Nothing
  , itemError = Nothing
  , itemAvailableProducts
  , itemBilledProducts
  , itemConsentedProducts = Nothing
  , itemConsentExpirationTime = Nothing
  , itemUpdateType
  }

-- ** ItemAccessTokenInvalidateRequest
-- | ItemAccessTokenInvalidateRequest
-- ItemAccessTokenInvalidateRequest defines the request schema for `/item/access_token/invalidate`
data ItemAccessTokenInvalidateRequest = ItemAccessTokenInvalidateRequest
  { itemAccessTokenInvalidateRequestClientId :: !(Maybe Text) -- ^ "client_id" - Your Plaid API &#x60;client_id&#x60;.
  , itemAccessTokenInvalidateRequestSecret :: !(Maybe Text) -- ^ "secret" - Your Plaid API &#x60;secret&#x60;.
  , itemAccessTokenInvalidateRequestAccessToken :: !(AccessToken) -- ^ /Required/ "access_token" - The access token associated with the Item data is being requested for.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ItemAccessTokenInvalidateRequest
instance A.FromJSON ItemAccessTokenInvalidateRequest where
  parseJSON = A.withObject "ItemAccessTokenInvalidateRequest" $ \o ->
    ItemAccessTokenInvalidateRequest
      <$> (o .:? "client_id")
      <*> (o .:? "secret")
      <*> (o .:  "access_token")

-- | ToJSON ItemAccessTokenInvalidateRequest
instance A.ToJSON ItemAccessTokenInvalidateRequest where
  toJSON ItemAccessTokenInvalidateRequest {..} =
   _omitNulls
      [ "client_id" .= itemAccessTokenInvalidateRequestClientId
      , "secret" .= itemAccessTokenInvalidateRequestSecret
      , "access_token" .= itemAccessTokenInvalidateRequestAccessToken
      ]


-- | Construct a value of type 'ItemAccessTokenInvalidateRequest' (by applying it's required fields, if any)
mkItemAccessTokenInvalidateRequest
  :: AccessToken -- ^ 'itemAccessTokenInvalidateRequestAccessToken': The access token associated with the Item data is being requested for.
  -> ItemAccessTokenInvalidateRequest
mkItemAccessTokenInvalidateRequest itemAccessTokenInvalidateRequestAccessToken =
  ItemAccessTokenInvalidateRequest
  { itemAccessTokenInvalidateRequestClientId = Nothing
  , itemAccessTokenInvalidateRequestSecret = Nothing
  , itemAccessTokenInvalidateRequestAccessToken
  }

-- ** ItemAccessTokenInvalidateResponse
-- | ItemAccessTokenInvalidateResponse
-- ItemAccessTokenInvalidateResponse defines the response schema for `/item/access_token/invalidate`
data ItemAccessTokenInvalidateResponse = ItemAccessTokenInvalidateResponse
  { itemAccessTokenInvalidateResponseNewAccessToken :: !(AccessToken) -- ^ /Required/ "new_access_token" - The access token associated with the Item data is being requested for.
  , itemAccessTokenInvalidateResponseRequestId :: !(Text) -- ^ /Required/ "request_id" - A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ItemAccessTokenInvalidateResponse
instance A.FromJSON ItemAccessTokenInvalidateResponse where
  parseJSON = A.withObject "ItemAccessTokenInvalidateResponse" $ \o ->
    ItemAccessTokenInvalidateResponse
      <$> (o .:  "new_access_token")
      <*> (o .:  "request_id")

-- | ToJSON ItemAccessTokenInvalidateResponse
instance A.ToJSON ItemAccessTokenInvalidateResponse where
  toJSON ItemAccessTokenInvalidateResponse {..} =
   _omitNulls
      [ "new_access_token" .= itemAccessTokenInvalidateResponseNewAccessToken
      , "request_id" .= itemAccessTokenInvalidateResponseRequestId
      ]


-- | Construct a value of type 'ItemAccessTokenInvalidateResponse' (by applying it's required fields, if any)
mkItemAccessTokenInvalidateResponse
  :: AccessToken -- ^ 'itemAccessTokenInvalidateResponseNewAccessToken': The access token associated with the Item data is being requested for.
  -> Text -- ^ 'itemAccessTokenInvalidateResponseRequestId': A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  -> ItemAccessTokenInvalidateResponse
mkItemAccessTokenInvalidateResponse itemAccessTokenInvalidateResponseNewAccessToken itemAccessTokenInvalidateResponseRequestId =
  ItemAccessTokenInvalidateResponse
  { itemAccessTokenInvalidateResponseNewAccessToken
  , itemAccessTokenInvalidateResponseRequestId
  }

-- ** ItemErrorWebhook
-- | ItemErrorWebhook
-- ItemErrorWebhook
-- 
-- Fired when an error is encountered with an Item. The error can be resolved by having the user go through Link’s update mode.
data ItemErrorWebhook = ItemErrorWebhook
  { itemErrorWebhookWebhookType :: !(Text) -- ^ /Required/ "webhook_type" - &#x60;ITEM&#x60;
  , itemErrorWebhookWebhookCode :: !(Text) -- ^ /Required/ "webhook_code" - &#x60;ERROR&#x60;
  , itemErrorWebhookItemId :: !(ItemId) -- ^ /Required/ "item_id" - The &#x60;item_id&#x60; of the Item associated with this webhook, warning, or error
  , itemErrorWebhookError :: !(Error) -- ^ /Required/ "error"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ItemErrorWebhook
instance A.FromJSON ItemErrorWebhook where
  parseJSON = A.withObject "ItemErrorWebhook" $ \o ->
    ItemErrorWebhook
      <$> (o .:  "webhook_type")
      <*> (o .:  "webhook_code")
      <*> (o .:  "item_id")
      <*> (o .:  "error")

-- | ToJSON ItemErrorWebhook
instance A.ToJSON ItemErrorWebhook where
  toJSON ItemErrorWebhook {..} =
   _omitNulls
      [ "webhook_type" .= itemErrorWebhookWebhookType
      , "webhook_code" .= itemErrorWebhookWebhookCode
      , "item_id" .= itemErrorWebhookItemId
      , "error" .= itemErrorWebhookError
      ]


-- | Construct a value of type 'ItemErrorWebhook' (by applying it's required fields, if any)
mkItemErrorWebhook
  :: Text -- ^ 'itemErrorWebhookWebhookType': `ITEM`
  -> Text -- ^ 'itemErrorWebhookWebhookCode': `ERROR`
  -> ItemId -- ^ 'itemErrorWebhookItemId': The `item_id` of the Item associated with this webhook, warning, or error
  -> Error -- ^ 'itemErrorWebhookError' 
  -> ItemErrorWebhook
mkItemErrorWebhook itemErrorWebhookWebhookType itemErrorWebhookWebhookCode itemErrorWebhookItemId itemErrorWebhookError =
  ItemErrorWebhook
  { itemErrorWebhookWebhookType
  , itemErrorWebhookWebhookCode
  , itemErrorWebhookItemId
  , itemErrorWebhookError
  }

-- ** ItemGetRequest
-- | ItemGetRequest
-- ItemGetRequest defines the request schema for `/item/get`
data ItemGetRequest = ItemGetRequest
  { itemGetRequestClientId :: !(Maybe Text) -- ^ "client_id" - Your Plaid API &#x60;client_id&#x60;.
  , itemGetRequestSecret :: !(Maybe Text) -- ^ "secret" - Your Plaid API &#x60;secret&#x60;.
  , itemGetRequestAccessToken :: !(AccessToken) -- ^ /Required/ "access_token" - The access token associated with the Item data is being requested for.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ItemGetRequest
instance A.FromJSON ItemGetRequest where
  parseJSON = A.withObject "ItemGetRequest" $ \o ->
    ItemGetRequest
      <$> (o .:? "client_id")
      <*> (o .:? "secret")
      <*> (o .:  "access_token")

-- | ToJSON ItemGetRequest
instance A.ToJSON ItemGetRequest where
  toJSON ItemGetRequest {..} =
   _omitNulls
      [ "client_id" .= itemGetRequestClientId
      , "secret" .= itemGetRequestSecret
      , "access_token" .= itemGetRequestAccessToken
      ]


-- | Construct a value of type 'ItemGetRequest' (by applying it's required fields, if any)
mkItemGetRequest
  :: AccessToken -- ^ 'itemGetRequestAccessToken': The access token associated with the Item data is being requested for.
  -> ItemGetRequest
mkItemGetRequest itemGetRequestAccessToken =
  ItemGetRequest
  { itemGetRequestClientId = Nothing
  , itemGetRequestSecret = Nothing
  , itemGetRequestAccessToken
  }

-- ** ItemGetResponse
-- | ItemGetResponse
-- ItemGetResponse defines the response schema for `/item/get` and `/item/webhook/update`
data ItemGetResponse = ItemGetResponse
  { itemGetResponseItem :: !(Item) -- ^ /Required/ "item"
  , itemGetResponseStatus :: !(Maybe NullableItemStatus) -- ^ "status"
  , itemGetResponseRequestId :: !(Text) -- ^ /Required/ "request_id" - A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  , itemGetResponseAccessToken :: !(Maybe NullableAccessToken) -- ^ "access_token"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ItemGetResponse
instance A.FromJSON ItemGetResponse where
  parseJSON = A.withObject "ItemGetResponse" $ \o ->
    ItemGetResponse
      <$> (o .:  "item")
      <*> (o .:? "status")
      <*> (o .:  "request_id")
      <*> (o .:? "access_token")

-- | ToJSON ItemGetResponse
instance A.ToJSON ItemGetResponse where
  toJSON ItemGetResponse {..} =
   _omitNulls
      [ "item" .= itemGetResponseItem
      , "status" .= itemGetResponseStatus
      , "request_id" .= itemGetResponseRequestId
      , "access_token" .= itemGetResponseAccessToken
      ]


-- | Construct a value of type 'ItemGetResponse' (by applying it's required fields, if any)
mkItemGetResponse
  :: Item -- ^ 'itemGetResponseItem' 
  -> Text -- ^ 'itemGetResponseRequestId': A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  -> ItemGetResponse
mkItemGetResponse itemGetResponseItem itemGetResponseRequestId =
  ItemGetResponse
  { itemGetResponseItem
  , itemGetResponseStatus = Nothing
  , itemGetResponseRequestId
  , itemGetResponseAccessToken = Nothing
  }

-- ** ItemImportRequest
-- | ItemImportRequest
-- ItemImportRequest defines the request schema for `/item/import`
data ItemImportRequest = ItemImportRequest
  { itemImportRequestClientId :: !(Maybe Text) -- ^ "client_id" - Your Plaid API &#x60;client_id&#x60;.
  , itemImportRequestSecret :: !(Maybe Text) -- ^ "secret" - Your Plaid API &#x60;secret&#x60;.
  , itemImportRequestProducts :: !([Products]) -- ^ /Required/ "products" - Array of product strings
  , itemImportRequestUserAuth :: !(ItemImportRequestUserAuth) -- ^ /Required/ "user_auth"
  , itemImportRequestOptions :: !(Maybe ItemImportRequestOptions) -- ^ "options"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ItemImportRequest
instance A.FromJSON ItemImportRequest where
  parseJSON = A.withObject "ItemImportRequest" $ \o ->
    ItemImportRequest
      <$> (o .:? "client_id")
      <*> (o .:? "secret")
      <*> (o .:  "products")
      <*> (o .:  "user_auth")
      <*> (o .:? "options")

-- | ToJSON ItemImportRequest
instance A.ToJSON ItemImportRequest where
  toJSON ItemImportRequest {..} =
   _omitNulls
      [ "client_id" .= itemImportRequestClientId
      , "secret" .= itemImportRequestSecret
      , "products" .= itemImportRequestProducts
      , "user_auth" .= itemImportRequestUserAuth
      , "options" .= itemImportRequestOptions
      ]


-- | Construct a value of type 'ItemImportRequest' (by applying it's required fields, if any)
mkItemImportRequest
  :: [Products] -- ^ 'itemImportRequestProducts': Array of product strings
  -> ItemImportRequestUserAuth -- ^ 'itemImportRequestUserAuth' 
  -> ItemImportRequest
mkItemImportRequest itemImportRequestProducts itemImportRequestUserAuth =
  ItemImportRequest
  { itemImportRequestClientId = Nothing
  , itemImportRequestSecret = Nothing
  , itemImportRequestProducts
  , itemImportRequestUserAuth
  , itemImportRequestOptions = Nothing
  }

-- ** ItemImportRequestOptions
-- | ItemImportRequestOptions
-- An optional object to configure `/item/import` request.
data ItemImportRequestOptions = ItemImportRequestOptions
  { itemImportRequestOptionsWebhook :: !(Maybe Text) -- ^ "webhook" - Specifies a webhook URL to associate with an Item. Plaid fires a webhook if credentials fail. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ItemImportRequestOptions
instance A.FromJSON ItemImportRequestOptions where
  parseJSON = A.withObject "ItemImportRequestOptions" $ \o ->
    ItemImportRequestOptions
      <$> (o .:? "webhook")

-- | ToJSON ItemImportRequestOptions
instance A.ToJSON ItemImportRequestOptions where
  toJSON ItemImportRequestOptions {..} =
   _omitNulls
      [ "webhook" .= itemImportRequestOptionsWebhook
      ]


-- | Construct a value of type 'ItemImportRequestOptions' (by applying it's required fields, if any)
mkItemImportRequestOptions
  :: ItemImportRequestOptions
mkItemImportRequestOptions =
  ItemImportRequestOptions
  { itemImportRequestOptionsWebhook = Nothing
  }

-- ** ItemImportRequestUserAuth
-- | ItemImportRequestUserAuth
-- Object of user ID and auth token pair, permitting Plaid to aggregate a user’s accounts
data ItemImportRequestUserAuth = ItemImportRequestUserAuth
  { itemImportRequestUserAuthUserId :: !(Text) -- ^ /Required/ "user_id" - Opaque user identifier
  , itemImportRequestUserAuthAuthToken :: !(Text) -- ^ /Required/ "auth_token" - Authorization token Plaid will use to aggregate this user’s accounts
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ItemImportRequestUserAuth
instance A.FromJSON ItemImportRequestUserAuth where
  parseJSON = A.withObject "ItemImportRequestUserAuth" $ \o ->
    ItemImportRequestUserAuth
      <$> (o .:  "user_id")
      <*> (o .:  "auth_token")

-- | ToJSON ItemImportRequestUserAuth
instance A.ToJSON ItemImportRequestUserAuth where
  toJSON ItemImportRequestUserAuth {..} =
   _omitNulls
      [ "user_id" .= itemImportRequestUserAuthUserId
      , "auth_token" .= itemImportRequestUserAuthAuthToken
      ]


-- | Construct a value of type 'ItemImportRequestUserAuth' (by applying it's required fields, if any)
mkItemImportRequestUserAuth
  :: Text -- ^ 'itemImportRequestUserAuthUserId': Opaque user identifier
  -> Text -- ^ 'itemImportRequestUserAuthAuthToken': Authorization token Plaid will use to aggregate this user’s accounts
  -> ItemImportRequestUserAuth
mkItemImportRequestUserAuth itemImportRequestUserAuthUserId itemImportRequestUserAuthAuthToken =
  ItemImportRequestUserAuth
  { itemImportRequestUserAuthUserId
  , itemImportRequestUserAuthAuthToken
  }

-- ** ItemImportResponse
-- | ItemImportResponse
-- ItemImportResponse defines the response schema for `/item/import`
data ItemImportResponse = ItemImportResponse
  { itemImportResponseAccessToken :: !(AccessToken) -- ^ /Required/ "access_token" - The access token associated with the Item data is being requested for.
  , itemImportResponseRequestId :: !(Text) -- ^ /Required/ "request_id" - A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ItemImportResponse
instance A.FromJSON ItemImportResponse where
  parseJSON = A.withObject "ItemImportResponse" $ \o ->
    ItemImportResponse
      <$> (o .:  "access_token")
      <*> (o .:  "request_id")

-- | ToJSON ItemImportResponse
instance A.ToJSON ItemImportResponse where
  toJSON ItemImportResponse {..} =
   _omitNulls
      [ "access_token" .= itemImportResponseAccessToken
      , "request_id" .= itemImportResponseRequestId
      ]


-- | Construct a value of type 'ItemImportResponse' (by applying it's required fields, if any)
mkItemImportResponse
  :: AccessToken -- ^ 'itemImportResponseAccessToken': The access token associated with the Item data is being requested for.
  -> Text -- ^ 'itemImportResponseRequestId': A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  -> ItemImportResponse
mkItemImportResponse itemImportResponseAccessToken itemImportResponseRequestId =
  ItemImportResponse
  { itemImportResponseAccessToken
  , itemImportResponseRequestId
  }

-- ** ItemProductReadyWebhook
-- | ItemProductReadyWebhook
-- ItemProductReadyWebhook
-- 
-- Fired once Plaid calculates income from an Item.
data ItemProductReadyWebhook = ItemProductReadyWebhook
  { itemProductReadyWebhookWebhookType :: !(Text) -- ^ /Required/ "webhook_type" - &#x60;INCOME&#x60;
  , itemProductReadyWebhookWebhookCode :: !(Text) -- ^ /Required/ "webhook_code" - &#x60;PRODUCT_READY&#x60;
  , itemProductReadyWebhookItemId :: !(ItemId) -- ^ /Required/ "item_id" - The &#x60;item_id&#x60; of the Item associated with this webhook, warning, or error
  , itemProductReadyWebhookError :: !(Maybe Error) -- ^ "error"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ItemProductReadyWebhook
instance A.FromJSON ItemProductReadyWebhook where
  parseJSON = A.withObject "ItemProductReadyWebhook" $ \o ->
    ItemProductReadyWebhook
      <$> (o .:  "webhook_type")
      <*> (o .:  "webhook_code")
      <*> (o .:  "item_id")
      <*> (o .:? "error")

-- | ToJSON ItemProductReadyWebhook
instance A.ToJSON ItemProductReadyWebhook where
  toJSON ItemProductReadyWebhook {..} =
   _omitNulls
      [ "webhook_type" .= itemProductReadyWebhookWebhookType
      , "webhook_code" .= itemProductReadyWebhookWebhookCode
      , "item_id" .= itemProductReadyWebhookItemId
      , "error" .= itemProductReadyWebhookError
      ]


-- | Construct a value of type 'ItemProductReadyWebhook' (by applying it's required fields, if any)
mkItemProductReadyWebhook
  :: Text -- ^ 'itemProductReadyWebhookWebhookType': `INCOME`
  -> Text -- ^ 'itemProductReadyWebhookWebhookCode': `PRODUCT_READY`
  -> ItemId -- ^ 'itemProductReadyWebhookItemId': The `item_id` of the Item associated with this webhook, warning, or error
  -> ItemProductReadyWebhook
mkItemProductReadyWebhook itemProductReadyWebhookWebhookType itemProductReadyWebhookWebhookCode itemProductReadyWebhookItemId =
  ItemProductReadyWebhook
  { itemProductReadyWebhookWebhookType
  , itemProductReadyWebhookWebhookCode
  , itemProductReadyWebhookItemId
  , itemProductReadyWebhookError = Nothing
  }

-- ** ItemPublicTokenCreateRequest
-- | ItemPublicTokenCreateRequest
-- ItemPublicTokenCreateRequest defines the request schema for `/item/public_token/create`
data ItemPublicTokenCreateRequest = ItemPublicTokenCreateRequest
  { itemPublicTokenCreateRequestClientId :: !(Maybe Text) -- ^ "client_id" - Your Plaid API &#x60;client_id&#x60;.
  , itemPublicTokenCreateRequestSecret :: !(Maybe Text) -- ^ "secret" - Your Plaid API &#x60;secret&#x60;.
  , itemPublicTokenCreateRequestAccessToken :: !(AccessToken) -- ^ /Required/ "access_token" - The access token associated with the Item data is being requested for.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ItemPublicTokenCreateRequest
instance A.FromJSON ItemPublicTokenCreateRequest where
  parseJSON = A.withObject "ItemPublicTokenCreateRequest" $ \o ->
    ItemPublicTokenCreateRequest
      <$> (o .:? "client_id")
      <*> (o .:? "secret")
      <*> (o .:  "access_token")

-- | ToJSON ItemPublicTokenCreateRequest
instance A.ToJSON ItemPublicTokenCreateRequest where
  toJSON ItemPublicTokenCreateRequest {..} =
   _omitNulls
      [ "client_id" .= itemPublicTokenCreateRequestClientId
      , "secret" .= itemPublicTokenCreateRequestSecret
      , "access_token" .= itemPublicTokenCreateRequestAccessToken
      ]


-- | Construct a value of type 'ItemPublicTokenCreateRequest' (by applying it's required fields, if any)
mkItemPublicTokenCreateRequest
  :: AccessToken -- ^ 'itemPublicTokenCreateRequestAccessToken': The access token associated with the Item data is being requested for.
  -> ItemPublicTokenCreateRequest
mkItemPublicTokenCreateRequest itemPublicTokenCreateRequestAccessToken =
  ItemPublicTokenCreateRequest
  { itemPublicTokenCreateRequestClientId = Nothing
  , itemPublicTokenCreateRequestSecret = Nothing
  , itemPublicTokenCreateRequestAccessToken
  }

-- ** ItemPublicTokenCreateResponse
-- | ItemPublicTokenCreateResponse
-- ItemPublicTokenCreateResponse defines the response schema for `/item/public_token/create`
data ItemPublicTokenCreateResponse = ItemPublicTokenCreateResponse
  { itemPublicTokenCreateResponsePublicToken :: !(Text) -- ^ /Required/ "public_token" - A &#x60;public_token&#x60; for the particular Item corresponding to the specified &#x60;access_token&#x60;
  , itemPublicTokenCreateResponseExpiration :: !(Maybe DateTime) -- ^ "expiration"
  , itemPublicTokenCreateResponseRequestId :: !(Text) -- ^ /Required/ "request_id" - A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ItemPublicTokenCreateResponse
instance A.FromJSON ItemPublicTokenCreateResponse where
  parseJSON = A.withObject "ItemPublicTokenCreateResponse" $ \o ->
    ItemPublicTokenCreateResponse
      <$> (o .:  "public_token")
      <*> (o .:? "expiration")
      <*> (o .:  "request_id")

-- | ToJSON ItemPublicTokenCreateResponse
instance A.ToJSON ItemPublicTokenCreateResponse where
  toJSON ItemPublicTokenCreateResponse {..} =
   _omitNulls
      [ "public_token" .= itemPublicTokenCreateResponsePublicToken
      , "expiration" .= itemPublicTokenCreateResponseExpiration
      , "request_id" .= itemPublicTokenCreateResponseRequestId
      ]


-- | Construct a value of type 'ItemPublicTokenCreateResponse' (by applying it's required fields, if any)
mkItemPublicTokenCreateResponse
  :: Text -- ^ 'itemPublicTokenCreateResponsePublicToken': A `public_token` for the particular Item corresponding to the specified `access_token`
  -> Text -- ^ 'itemPublicTokenCreateResponseRequestId': A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  -> ItemPublicTokenCreateResponse
mkItemPublicTokenCreateResponse itemPublicTokenCreateResponsePublicToken itemPublicTokenCreateResponseRequestId =
  ItemPublicTokenCreateResponse
  { itemPublicTokenCreateResponsePublicToken
  , itemPublicTokenCreateResponseExpiration = Nothing
  , itemPublicTokenCreateResponseRequestId
  }

-- ** ItemPublicTokenExchangeRequest
-- | ItemPublicTokenExchangeRequest
-- ItemPublicTokenExchangeRequest defines the request schema for `/item/public_token/exchange`
data ItemPublicTokenExchangeRequest = ItemPublicTokenExchangeRequest
  { itemPublicTokenExchangeRequestClientId :: !(Maybe Text) -- ^ "client_id" - Your Plaid API &#x60;client_id&#x60;.
  , itemPublicTokenExchangeRequestSecret :: !(Maybe Text) -- ^ "secret" - Your Plaid API &#x60;secret&#x60;.
  , itemPublicTokenExchangeRequestPublicToken :: !(Text) -- ^ /Required/ "public_token" - Your &#x60;public_token&#x60;, obtained from the Link &#x60;onSuccess&#x60; callback or &#x60;/sandbox/item/public_token/create&#x60;.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ItemPublicTokenExchangeRequest
instance A.FromJSON ItemPublicTokenExchangeRequest where
  parseJSON = A.withObject "ItemPublicTokenExchangeRequest" $ \o ->
    ItemPublicTokenExchangeRequest
      <$> (o .:? "client_id")
      <*> (o .:? "secret")
      <*> (o .:  "public_token")

-- | ToJSON ItemPublicTokenExchangeRequest
instance A.ToJSON ItemPublicTokenExchangeRequest where
  toJSON ItemPublicTokenExchangeRequest {..} =
   _omitNulls
      [ "client_id" .= itemPublicTokenExchangeRequestClientId
      , "secret" .= itemPublicTokenExchangeRequestSecret
      , "public_token" .= itemPublicTokenExchangeRequestPublicToken
      ]


-- | Construct a value of type 'ItemPublicTokenExchangeRequest' (by applying it's required fields, if any)
mkItemPublicTokenExchangeRequest
  :: Text -- ^ 'itemPublicTokenExchangeRequestPublicToken': Your `public_token`, obtained from the Link `onSuccess` callback or `/sandbox/item/public_token/create`.
  -> ItemPublicTokenExchangeRequest
mkItemPublicTokenExchangeRequest itemPublicTokenExchangeRequestPublicToken =
  ItemPublicTokenExchangeRequest
  { itemPublicTokenExchangeRequestClientId = Nothing
  , itemPublicTokenExchangeRequestSecret = Nothing
  , itemPublicTokenExchangeRequestPublicToken
  }

-- ** ItemPublicTokenExchangeResponse
-- | ItemPublicTokenExchangeResponse
-- ItemPublicTokenExchangeResponse defines the response schema for `/item/public_token/exchange`
data ItemPublicTokenExchangeResponse = ItemPublicTokenExchangeResponse
  { itemPublicTokenExchangeResponseAccessToken :: !(AccessToken) -- ^ /Required/ "access_token" - The access token associated with the Item data is being requested for.
  , itemPublicTokenExchangeResponseItemId :: !(ItemId) -- ^ /Required/ "item_id" - The &#x60;item_id&#x60; value of the Item associated with the returned &#x60;access_token&#x60;
  , itemPublicTokenExchangeResponseRequestId :: !(Text) -- ^ /Required/ "request_id" - A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ItemPublicTokenExchangeResponse
instance A.FromJSON ItemPublicTokenExchangeResponse where
  parseJSON = A.withObject "ItemPublicTokenExchangeResponse" $ \o ->
    ItemPublicTokenExchangeResponse
      <$> (o .:  "access_token")
      <*> (o .:  "item_id")
      <*> (o .:  "request_id")

-- | ToJSON ItemPublicTokenExchangeResponse
instance A.ToJSON ItemPublicTokenExchangeResponse where
  toJSON ItemPublicTokenExchangeResponse {..} =
   _omitNulls
      [ "access_token" .= itemPublicTokenExchangeResponseAccessToken
      , "item_id" .= itemPublicTokenExchangeResponseItemId
      , "request_id" .= itemPublicTokenExchangeResponseRequestId
      ]


-- | Construct a value of type 'ItemPublicTokenExchangeResponse' (by applying it's required fields, if any)
mkItemPublicTokenExchangeResponse
  :: AccessToken -- ^ 'itemPublicTokenExchangeResponseAccessToken': The access token associated with the Item data is being requested for.
  -> ItemId -- ^ 'itemPublicTokenExchangeResponseItemId': The `item_id` value of the Item associated with the returned `access_token`
  -> Text -- ^ 'itemPublicTokenExchangeResponseRequestId': A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  -> ItemPublicTokenExchangeResponse
mkItemPublicTokenExchangeResponse itemPublicTokenExchangeResponseAccessToken itemPublicTokenExchangeResponseItemId itemPublicTokenExchangeResponseRequestId =
  ItemPublicTokenExchangeResponse
  { itemPublicTokenExchangeResponseAccessToken
  , itemPublicTokenExchangeResponseItemId
  , itemPublicTokenExchangeResponseRequestId
  }

-- ** ItemRemoveRequest
-- | ItemRemoveRequest
-- ItemRemoveRequest defines the request schema for `/item/remove`
data ItemRemoveRequest = ItemRemoveRequest
  { itemRemoveRequestClientId :: !(Maybe Text) -- ^ "client_id" - Your Plaid API &#x60;client_id&#x60;.
  , itemRemoveRequestSecret :: !(Maybe Text) -- ^ "secret" - Your Plaid API &#x60;secret&#x60;.
  , itemRemoveRequestAccessToken :: !(AccessToken) -- ^ /Required/ "access_token" - The access token associated with the Item data is being requested for.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ItemRemoveRequest
instance A.FromJSON ItemRemoveRequest where
  parseJSON = A.withObject "ItemRemoveRequest" $ \o ->
    ItemRemoveRequest
      <$> (o .:? "client_id")
      <*> (o .:? "secret")
      <*> (o .:  "access_token")

-- | ToJSON ItemRemoveRequest
instance A.ToJSON ItemRemoveRequest where
  toJSON ItemRemoveRequest {..} =
   _omitNulls
      [ "client_id" .= itemRemoveRequestClientId
      , "secret" .= itemRemoveRequestSecret
      , "access_token" .= itemRemoveRequestAccessToken
      ]


-- | Construct a value of type 'ItemRemoveRequest' (by applying it's required fields, if any)
mkItemRemoveRequest
  :: AccessToken -- ^ 'itemRemoveRequestAccessToken': The access token associated with the Item data is being requested for.
  -> ItemRemoveRequest
mkItemRemoveRequest itemRemoveRequestAccessToken =
  ItemRemoveRequest
  { itemRemoveRequestClientId = Nothing
  , itemRemoveRequestSecret = Nothing
  , itemRemoveRequestAccessToken
  }

-- ** ItemRemoveResponse
-- | ItemRemoveResponse
-- ItemRemoveResponse defines the response schema for `/item/remove`
data ItemRemoveResponse = ItemRemoveResponse
  { itemRemoveResponseRequestId :: !(Text) -- ^ /Required/ "request_id" - A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ItemRemoveResponse
instance A.FromJSON ItemRemoveResponse where
  parseJSON = A.withObject "ItemRemoveResponse" $ \o ->
    ItemRemoveResponse
      <$> (o .:  "request_id")

-- | ToJSON ItemRemoveResponse
instance A.ToJSON ItemRemoveResponse where
  toJSON ItemRemoveResponse {..} =
   _omitNulls
      [ "request_id" .= itemRemoveResponseRequestId
      ]


-- | Construct a value of type 'ItemRemoveResponse' (by applying it's required fields, if any)
mkItemRemoveResponse
  :: Text -- ^ 'itemRemoveResponseRequestId': A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  -> ItemRemoveResponse
mkItemRemoveResponse itemRemoveResponseRequestId =
  ItemRemoveResponse
  { itemRemoveResponseRequestId
  }

-- ** ItemStatus
-- | ItemStatus
-- ItemStatus
-- 
-- An object with information about the status of the Item.
data ItemStatus = ItemStatus
  { itemStatusInvestments :: !(Maybe (Map.Map String A.Value)) -- ^ "investments" - Information about the last successful and failed investments update for the Item.
  , itemStatusTransactions :: !(Maybe (Map.Map String A.Value)) -- ^ "transactions" - Information about the last successful and failed transactions update for the Item.
  , itemStatusLastWebhook :: !(Maybe (Map.Map String A.Value)) -- ^ "last_webhook" - Information about the last webhook fired for the Item.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ItemStatus
instance A.FromJSON ItemStatus where
  parseJSON = A.withObject "ItemStatus" $ \o ->
    ItemStatus
      <$> (o .:? "investments")
      <*> (o .:? "transactions")
      <*> (o .:? "last_webhook")

-- | ToJSON ItemStatus
instance A.ToJSON ItemStatus where
  toJSON ItemStatus {..} =
   _omitNulls
      [ "investments" .= itemStatusInvestments
      , "transactions" .= itemStatusTransactions
      , "last_webhook" .= itemStatusLastWebhook
      ]


-- | Construct a value of type 'ItemStatus' (by applying it's required fields, if any)
mkItemStatus
  :: ItemStatus
mkItemStatus =
  ItemStatus
  { itemStatusInvestments = Nothing
  , itemStatusTransactions = Nothing
  , itemStatusLastWebhook = Nothing
  }

-- ** ItemWebhookUpdateRequest
-- | ItemWebhookUpdateRequest
-- ItemWebhookUpdateRequest defines the request schema for `/item/webhook/update`
data ItemWebhookUpdateRequest = ItemWebhookUpdateRequest
  { itemWebhookUpdateRequestClientId :: !(Maybe Text) -- ^ "client_id" - Your Plaid API &#x60;client_id&#x60;.
  , itemWebhookUpdateRequestSecret :: !(Maybe Text) -- ^ "secret" - Your Plaid API &#x60;secret&#x60;.
  , itemWebhookUpdateRequestAccessToken :: !(AccessToken) -- ^ /Required/ "access_token" - The access token associated with the Item data is being requested for.
  , itemWebhookUpdateRequestWebhook :: !(Text) -- ^ /Required/ "webhook" - The new webhook URL to associate with the Item.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ItemWebhookUpdateRequest
instance A.FromJSON ItemWebhookUpdateRequest where
  parseJSON = A.withObject "ItemWebhookUpdateRequest" $ \o ->
    ItemWebhookUpdateRequest
      <$> (o .:? "client_id")
      <*> (o .:? "secret")
      <*> (o .:  "access_token")
      <*> (o .:  "webhook")

-- | ToJSON ItemWebhookUpdateRequest
instance A.ToJSON ItemWebhookUpdateRequest where
  toJSON ItemWebhookUpdateRequest {..} =
   _omitNulls
      [ "client_id" .= itemWebhookUpdateRequestClientId
      , "secret" .= itemWebhookUpdateRequestSecret
      , "access_token" .= itemWebhookUpdateRequestAccessToken
      , "webhook" .= itemWebhookUpdateRequestWebhook
      ]


-- | Construct a value of type 'ItemWebhookUpdateRequest' (by applying it's required fields, if any)
mkItemWebhookUpdateRequest
  :: AccessToken -- ^ 'itemWebhookUpdateRequestAccessToken': The access token associated with the Item data is being requested for.
  -> Text -- ^ 'itemWebhookUpdateRequestWebhook': The new webhook URL to associate with the Item.
  -> ItemWebhookUpdateRequest
mkItemWebhookUpdateRequest itemWebhookUpdateRequestAccessToken itemWebhookUpdateRequestWebhook =
  ItemWebhookUpdateRequest
  { itemWebhookUpdateRequestClientId = Nothing
  , itemWebhookUpdateRequestSecret = Nothing
  , itemWebhookUpdateRequestAccessToken
  , itemWebhookUpdateRequestWebhook
  }

-- ** ItemWebhookUpdateResponse
-- | ItemWebhookUpdateResponse
-- ItemWebhookUpdateResponse defines the response schema for `/item/webhook/update`
data ItemWebhookUpdateResponse = ItemWebhookUpdateResponse
  { itemWebhookUpdateResponseItem :: !(Item) -- ^ /Required/ "item"
  , itemWebhookUpdateResponseRequestId :: !(Text) -- ^ /Required/ "request_id" - A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ItemWebhookUpdateResponse
instance A.FromJSON ItemWebhookUpdateResponse where
  parseJSON = A.withObject "ItemWebhookUpdateResponse" $ \o ->
    ItemWebhookUpdateResponse
      <$> (o .:  "item")
      <*> (o .:  "request_id")

-- | ToJSON ItemWebhookUpdateResponse
instance A.ToJSON ItemWebhookUpdateResponse where
  toJSON ItemWebhookUpdateResponse {..} =
   _omitNulls
      [ "item" .= itemWebhookUpdateResponseItem
      , "request_id" .= itemWebhookUpdateResponseRequestId
      ]


-- | Construct a value of type 'ItemWebhookUpdateResponse' (by applying it's required fields, if any)
mkItemWebhookUpdateResponse
  :: Item -- ^ 'itemWebhookUpdateResponseItem' 
  -> Text -- ^ 'itemWebhookUpdateResponseRequestId': A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  -> ItemWebhookUpdateResponse
mkItemWebhookUpdateResponse itemWebhookUpdateResponseItem itemWebhookUpdateResponseRequestId =
  ItemWebhookUpdateResponse
  { itemWebhookUpdateResponseItem
  , itemWebhookUpdateResponseRequestId
  }

-- ** JWKPublicKey
-- | JWKPublicKey
-- A JSON Web Key (JWK) that can be used in conjunction with [JWT libraries](https://jwt.io/#libraries-io) to verify Plaid webhooks
data JWKPublicKey = JWKPublicKey
  { jWKPublicKeyAlg :: !(Maybe Text) -- ^ "alg" - The alg member identifies the cryptographic algorithm family used with the key.
  , jWKPublicKeyCrv :: !(Maybe Text) -- ^ "crv" - The crv member identifies the cryptographic curve used with the key.
  , jWKPublicKeyKid :: !(Maybe Text) -- ^ "kid" - The kid (Key ID) member can be used to match a specific key. This can be used, for instance, to choose among a set of keys within the JWK during key rollover.
  , jWKPublicKeyKty :: !(Maybe Text) -- ^ "kty" - The kty (key type) parameter identifies the cryptographic algorithm family used with the key, such as RSA or EC.
  , jWKPublicKeyUse :: !(Maybe Text) -- ^ "use" - The use (public key use) parameter identifies the intended use of the public key.
  , jWKPublicKeyX :: !(Maybe Text) -- ^ "x" - The x member contains the x coordinate for the elliptic curve point.
  , jWKPublicKeyY :: !(Maybe Text) -- ^ "y" - The y member contains the y coordinate for the elliptic curve point.
  , jWKPublicKeyCreatedAt :: !(Maybe Int) -- ^ "created_at"
  , jWKPublicKeyExpiredAt :: !(Maybe Int) -- ^ "expired_at"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON JWKPublicKey
instance A.FromJSON JWKPublicKey where
  parseJSON = A.withObject "JWKPublicKey" $ \o ->
    JWKPublicKey
      <$> (o .:? "alg")
      <*> (o .:? "crv")
      <*> (o .:? "kid")
      <*> (o .:? "kty")
      <*> (o .:? "use")
      <*> (o .:? "x")
      <*> (o .:? "y")
      <*> (o .:? "created_at")
      <*> (o .:? "expired_at")

-- | ToJSON JWKPublicKey
instance A.ToJSON JWKPublicKey where
  toJSON JWKPublicKey {..} =
   _omitNulls
      [ "alg" .= jWKPublicKeyAlg
      , "crv" .= jWKPublicKeyCrv
      , "kid" .= jWKPublicKeyKid
      , "kty" .= jWKPublicKeyKty
      , "use" .= jWKPublicKeyUse
      , "x" .= jWKPublicKeyX
      , "y" .= jWKPublicKeyY
      , "created_at" .= jWKPublicKeyCreatedAt
      , "expired_at" .= jWKPublicKeyExpiredAt
      ]


-- | Construct a value of type 'JWKPublicKey' (by applying it's required fields, if any)
mkJWKPublicKey
  :: JWKPublicKey
mkJWKPublicKey =
  JWKPublicKey
  { jWKPublicKeyAlg = Nothing
  , jWKPublicKeyCrv = Nothing
  , jWKPublicKeyKid = Nothing
  , jWKPublicKeyKty = Nothing
  , jWKPublicKeyUse = Nothing
  , jWKPublicKeyX = Nothing
  , jWKPublicKeyY = Nothing
  , jWKPublicKeyCreatedAt = Nothing
  , jWKPublicKeyExpiredAt = Nothing
  }

-- ** JWTHeader
-- | JWTHeader
-- JWTHeader
-- 
-- A JWT Header, used for webhook validation
data JWTHeader = JWTHeader
  { jWTHeaderId :: !(Text) -- ^ /Required/ "id"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON JWTHeader
instance A.FromJSON JWTHeader where
  parseJSON = A.withObject "JWTHeader" $ \o ->
    JWTHeader
      <$> (o .:  "id")

-- | ToJSON JWTHeader
instance A.ToJSON JWTHeader where
  toJSON JWTHeader {..} =
   _omitNulls
      [ "id" .= jWTHeaderId
      ]


-- | Construct a value of type 'JWTHeader' (by applying it's required fields, if any)
mkJWTHeader
  :: Text -- ^ 'jWTHeaderId' 
  -> JWTHeader
mkJWTHeader jWTHeaderId =
  JWTHeader
  { jWTHeaderId
  }

-- ** LiabilitiesGetRequest
-- | LiabilitiesGetRequest
-- LiabilitiesGetRequest defines the request schema for `/liabilities/get`
data LiabilitiesGetRequest = LiabilitiesGetRequest
  { liabilitiesGetRequestClientId :: !(Maybe Text) -- ^ "client_id" - Your Plaid API &#x60;client_id&#x60;.
  , liabilitiesGetRequestSecret :: !(Maybe Text) -- ^ "secret" - Your Plaid API &#x60;secret&#x60;.
  , liabilitiesGetRequestAccessToken :: !(AccessToken) -- ^ /Required/ "access_token" - The access token associated with the Item data is being requested for.
  , liabilitiesGetRequestOptions :: !(Maybe LiabilitiesGetRequestOptions) -- ^ "options"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON LiabilitiesGetRequest
instance A.FromJSON LiabilitiesGetRequest where
  parseJSON = A.withObject "LiabilitiesGetRequest" $ \o ->
    LiabilitiesGetRequest
      <$> (o .:? "client_id")
      <*> (o .:? "secret")
      <*> (o .:  "access_token")
      <*> (o .:? "options")

-- | ToJSON LiabilitiesGetRequest
instance A.ToJSON LiabilitiesGetRequest where
  toJSON LiabilitiesGetRequest {..} =
   _omitNulls
      [ "client_id" .= liabilitiesGetRequestClientId
      , "secret" .= liabilitiesGetRequestSecret
      , "access_token" .= liabilitiesGetRequestAccessToken
      , "options" .= liabilitiesGetRequestOptions
      ]


-- | Construct a value of type 'LiabilitiesGetRequest' (by applying it's required fields, if any)
mkLiabilitiesGetRequest
  :: AccessToken -- ^ 'liabilitiesGetRequestAccessToken': The access token associated with the Item data is being requested for.
  -> LiabilitiesGetRequest
mkLiabilitiesGetRequest liabilitiesGetRequestAccessToken =
  LiabilitiesGetRequest
  { liabilitiesGetRequestClientId = Nothing
  , liabilitiesGetRequestSecret = Nothing
  , liabilitiesGetRequestAccessToken
  , liabilitiesGetRequestOptions = Nothing
  }

-- ** LiabilitiesGetRequestOptions
-- | LiabilitiesGetRequestOptions
-- An optional object to filter `/liabilities/get` results. If provided, `options` cannot be null.
data LiabilitiesGetRequestOptions = LiabilitiesGetRequestOptions
  { liabilitiesGetRequestOptionsAccountIds :: !(Maybe [Text]) -- ^ "account_ids" - A list of accounts to retrieve for the Item.  An error will be returned if a provided &#x60;account_id&#x60; is not associated with the Item
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON LiabilitiesGetRequestOptions
instance A.FromJSON LiabilitiesGetRequestOptions where
  parseJSON = A.withObject "LiabilitiesGetRequestOptions" $ \o ->
    LiabilitiesGetRequestOptions
      <$> (o .:? "account_ids")

-- | ToJSON LiabilitiesGetRequestOptions
instance A.ToJSON LiabilitiesGetRequestOptions where
  toJSON LiabilitiesGetRequestOptions {..} =
   _omitNulls
      [ "account_ids" .= liabilitiesGetRequestOptionsAccountIds
      ]


-- | Construct a value of type 'LiabilitiesGetRequestOptions' (by applying it's required fields, if any)
mkLiabilitiesGetRequestOptions
  :: LiabilitiesGetRequestOptions
mkLiabilitiesGetRequestOptions =
  LiabilitiesGetRequestOptions
  { liabilitiesGetRequestOptionsAccountIds = Nothing
  }

-- ** LiabilitiesGetResponse
-- | LiabilitiesGetResponse
-- LiabilitiesGetResponse defines the response schema for `/liabilities/get`
data LiabilitiesGetResponse = LiabilitiesGetResponse
  { liabilitiesGetResponseAccounts :: !([AccountBase]) -- ^ /Required/ "accounts" - An array of accounts associated with the Item
  , liabilitiesGetResponseItem :: !(Item) -- ^ /Required/ "item"
  , liabilitiesGetResponseLiabilities :: !(LiabilitiesObject) -- ^ /Required/ "liabilities"
  , liabilitiesGetResponseRequestId :: !(Text) -- ^ /Required/ "request_id" - A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON LiabilitiesGetResponse
instance A.FromJSON LiabilitiesGetResponse where
  parseJSON = A.withObject "LiabilitiesGetResponse" $ \o ->
    LiabilitiesGetResponse
      <$> (o .:  "accounts")
      <*> (o .:  "item")
      <*> (o .:  "liabilities")
      <*> (o .:  "request_id")

-- | ToJSON LiabilitiesGetResponse
instance A.ToJSON LiabilitiesGetResponse where
  toJSON LiabilitiesGetResponse {..} =
   _omitNulls
      [ "accounts" .= liabilitiesGetResponseAccounts
      , "item" .= liabilitiesGetResponseItem
      , "liabilities" .= liabilitiesGetResponseLiabilities
      , "request_id" .= liabilitiesGetResponseRequestId
      ]


-- | Construct a value of type 'LiabilitiesGetResponse' (by applying it's required fields, if any)
mkLiabilitiesGetResponse
  :: [AccountBase] -- ^ 'liabilitiesGetResponseAccounts': An array of accounts associated with the Item
  -> Item -- ^ 'liabilitiesGetResponseItem' 
  -> LiabilitiesObject -- ^ 'liabilitiesGetResponseLiabilities' 
  -> Text -- ^ 'liabilitiesGetResponseRequestId': A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  -> LiabilitiesGetResponse
mkLiabilitiesGetResponse liabilitiesGetResponseAccounts liabilitiesGetResponseItem liabilitiesGetResponseLiabilities liabilitiesGetResponseRequestId =
  LiabilitiesGetResponse
  { liabilitiesGetResponseAccounts
  , liabilitiesGetResponseItem
  , liabilitiesGetResponseLiabilities
  , liabilitiesGetResponseRequestId
  }

-- ** LiabilitiesObject
-- | LiabilitiesObject
-- LiabilitiesObject
-- 
-- An object containing liability accounts
data LiabilitiesObject = LiabilitiesObject
  { liabilitiesObjectCredit :: !(Maybe [CreditCardLiability]) -- ^ "credit" - The credit accounts returned. If no credit accounts are returned, &#x60;credit&#x60; will not be present in the schema.
  , liabilitiesObjectMortgage :: !(Maybe [MortgageLiability]) -- ^ "mortgage" - The mortgage accounts returned. If no mortgage accounts are returned, &#x60;mortgage&#x60; will not be present in the schema.
  , liabilitiesObjectStudent :: !(Maybe [StudentLoan]) -- ^ "student" - The student loan accounts returned. If no student loan accounts are returned, &#x60;student&#x60; will not be present in the schema.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON LiabilitiesObject
instance A.FromJSON LiabilitiesObject where
  parseJSON = A.withObject "LiabilitiesObject" $ \o ->
    LiabilitiesObject
      <$> (o .:? "credit")
      <*> (o .:? "mortgage")
      <*> (o .:? "student")

-- | ToJSON LiabilitiesObject
instance A.ToJSON LiabilitiesObject where
  toJSON LiabilitiesObject {..} =
   _omitNulls
      [ "credit" .= liabilitiesObjectCredit
      , "mortgage" .= liabilitiesObjectMortgage
      , "student" .= liabilitiesObjectStudent
      ]


-- | Construct a value of type 'LiabilitiesObject' (by applying it's required fields, if any)
mkLiabilitiesObject
  :: LiabilitiesObject
mkLiabilitiesObject =
  LiabilitiesObject
  { liabilitiesObjectCredit = Nothing
  , liabilitiesObjectMortgage = Nothing
  , liabilitiesObjectStudent = Nothing
  }

-- ** LiabilityOverride
-- | LiabilityOverride
-- Used to configure Sandbox test data for the Liabilities product
data LiabilityOverride = LiabilityOverride
  { liabilityOverrideType :: !(Text) -- ^ /Required/ "type" - The type of the liability object, either &#x60;credit&#x60; or &#x60;student&#x60;.
  , liabilityOverridePurchaseApr :: !(Double) -- ^ /Required/ "purchase_apr" - The purchase APR percentage value. For simplicity, this is the only interest rate used to calculate interest charges. Can only be set if &#x60;type&#x60; is &#x60;credit&#x60;.
  , liabilityOverrideCashApr :: !(Double) -- ^ /Required/ "cash_apr" - The cash APR percentage value. Can only be set if &#x60;type&#x60; is &#x60;credit&#x60;.
  , liabilityOverrideBalanceTransferApr :: !(Double) -- ^ /Required/ "balance_transfer_apr" - The balance transfer APR percentage value. Can only be set if &#x60;type&#x60; is &#x60;credit&#x60;. Can only be set if &#x60;type&#x60; is &#x60;credit&#x60;.
  , liabilityOverrideSpecialApr :: !(Double) -- ^ /Required/ "special_apr" - The special APR percentage value. Can only be set if &#x60;type&#x60; is &#x60;credit&#x60;.
  , liabilityOverrideLastPaymentAmount :: !(Double) -- ^ /Required/ "last_payment_amount" - Override the &#x60;last_payment_amount&#x60; field. Can only be set if &#x60;type&#x60; is &#x60;credit&#x60;.
  , liabilityOverrideLastStatementBalance :: !(Double) -- ^ /Required/ "last_statement_balance" - Override the &#x60;last_statement_balance&#x60; field. Can only be set if &#x60;type&#x60; is &#x60;credit&#x60;.
  , liabilityOverrideMinimumPaymentAmount :: !(Double) -- ^ /Required/ "minimum_payment_amount" - Override the &#x60;minimum_payment_amount&#x60; field. Can only be set if &#x60;type&#x60; is &#x60;credit&#x60;.
  , liabilityOverrideIsOverdue :: !(Bool) -- ^ /Required/ "is_overdue" - Override the &#x60;is_overdue&#x60; field
  , liabilityOverrideOriginationDate :: !(Text) -- ^ /Required/ "origination_date" - The date on which the loan was initially lent, in ISO 8601 (YYYY-MM-DD) format. Can only be set if &#x60;type&#x60; is &#x60;student&#x60;.
  , liabilityOverridePrincipal :: !(Double) -- ^ /Required/ "principal" - The original loan principal. Can only be set if &#x60;type&#x60; is &#x60;student&#x60;.
  , liabilityOverrideNominalApr :: !(Double) -- ^ /Required/ "nominal_apr" - The interest rate on the loan as a percentage. Can only be set if &#x60;type&#x60; is &#x60;student&#x60;.
  , liabilityOverrideInterestCapitalizationGracePeriodMonths :: !(Double) -- ^ /Required/ "interest_capitalization_grace_period_months" - If set, interest capitalization begins at the given number of months after loan origination. By default interest is never capitalized. Can only be set if &#x60;type&#x60; is &#x60;student&#x60;.
  , liabilityOverrideRepaymentModel :: !(StudentLoanRepaymentModel) -- ^ /Required/ "repayment_model"
  , liabilityOverrideExpectedPayoffDate :: !(Text) -- ^ /Required/ "expected_payoff_date" - Override the &#x60;expected_payoff_date&#x60; field. Can only be set if &#x60;type&#x60; is &#x60;student&#x60;.
  , liabilityOverrideGuarantor :: !(Text) -- ^ /Required/ "guarantor" - Override the &#x60;guarantor&#x60; field. Can only be set if &#x60;type&#x60; is &#x60;student&#x60;.
  , liabilityOverrideIsFederal :: !(Bool) -- ^ /Required/ "is_federal" - Override the &#x60;is_federal&#x60; field. Can only be set if &#x60;type&#x60; is &#x60;student&#x60;.
  , liabilityOverrideLoanName :: !(Text) -- ^ /Required/ "loan_name" - Override the &#x60;loan_name&#x60; field. Can only be set if &#x60;type&#x60; is &#x60;student&#x60;.
  , liabilityOverrideLoanStatus :: !(Text) -- ^ /Required/ "loan_status" - Override the &#x60;loan_status&#x60; field. Can only be set if &#x60;type&#x60; is &#x60;student&#x60;.
  , liabilityOverridePaymentReferenceNumber :: !(Text) -- ^ /Required/ "payment_reference_number" - Override the &#x60;payment_reference_number&#x60; field. Can only be set if &#x60;type&#x60; is &#x60;student&#x60;.
  , liabilityOverridePslfStatus :: !(Text) -- ^ /Required/ "pslf_status" - Override the &#x60;pslf_status&#x60; field. Can only be set if &#x60;type&#x60; is &#x60;student&#x60;.
  , liabilityOverrideRepaymentPlanDescription :: !(Text) -- ^ /Required/ "repayment_plan_description" - Override the &#x60;repayment_plan.description&#x60; field. Can only be set if &#x60;type&#x60; is &#x60;student&#x60;.
  , liabilityOverrideRepaymentPlanType :: !(Text) -- ^ /Required/ "repayment_plan_type" - Override the &#x60;repayment_plan.type&#x60; field. Can only be set if &#x60;type&#x60; is &#x60;student&#x60;. Possible values are: &#x60;\&quot;extended graduated\&quot;&#x60;, &#x60;\&quot;extended standard\&quot;&#x60;, &#x60;\&quot;graduated\&quot;&#x60;, &#x60;\&quot;income-contingent repayment\&quot;&#x60;, &#x60;\&quot;income-based repayment\&quot;&#x60;, &#x60;\&quot;interest only\&quot;&#x60;, &#x60;\&quot;other\&quot;&#x60;, &#x60;\&quot;pay as you earn\&quot;&#x60;, &#x60;\&quot;revised pay as you earn\&quot;&#x60;, or &#x60;\&quot;standard\&quot;&#x60;.
  , liabilityOverrideSequenceNumber :: !(Text) -- ^ /Required/ "sequence_number" - Override the &#x60;sequence_number&#x60; field. Can only be set if &#x60;type&#x60; is &#x60;student&#x60;.
  , liabilityOverrideServicerAddress :: !(Address) -- ^ /Required/ "servicer_address"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON LiabilityOverride
instance A.FromJSON LiabilityOverride where
  parseJSON = A.withObject "LiabilityOverride" $ \o ->
    LiabilityOverride
      <$> (o .:  "type")
      <*> (o .:  "purchase_apr")
      <*> (o .:  "cash_apr")
      <*> (o .:  "balance_transfer_apr")
      <*> (o .:  "special_apr")
      <*> (o .:  "last_payment_amount")
      <*> (o .:  "last_statement_balance")
      <*> (o .:  "minimum_payment_amount")
      <*> (o .:  "is_overdue")
      <*> (o .:  "origination_date")
      <*> (o .:  "principal")
      <*> (o .:  "nominal_apr")
      <*> (o .:  "interest_capitalization_grace_period_months")
      <*> (o .:  "repayment_model")
      <*> (o .:  "expected_payoff_date")
      <*> (o .:  "guarantor")
      <*> (o .:  "is_federal")
      <*> (o .:  "loan_name")
      <*> (o .:  "loan_status")
      <*> (o .:  "payment_reference_number")
      <*> (o .:  "pslf_status")
      <*> (o .:  "repayment_plan_description")
      <*> (o .:  "repayment_plan_type")
      <*> (o .:  "sequence_number")
      <*> (o .:  "servicer_address")

-- | ToJSON LiabilityOverride
instance A.ToJSON LiabilityOverride where
  toJSON LiabilityOverride {..} =
   _omitNulls
      [ "type" .= liabilityOverrideType
      , "purchase_apr" .= liabilityOverridePurchaseApr
      , "cash_apr" .= liabilityOverrideCashApr
      , "balance_transfer_apr" .= liabilityOverrideBalanceTransferApr
      , "special_apr" .= liabilityOverrideSpecialApr
      , "last_payment_amount" .= liabilityOverrideLastPaymentAmount
      , "last_statement_balance" .= liabilityOverrideLastStatementBalance
      , "minimum_payment_amount" .= liabilityOverrideMinimumPaymentAmount
      , "is_overdue" .= liabilityOverrideIsOverdue
      , "origination_date" .= liabilityOverrideOriginationDate
      , "principal" .= liabilityOverridePrincipal
      , "nominal_apr" .= liabilityOverrideNominalApr
      , "interest_capitalization_grace_period_months" .= liabilityOverrideInterestCapitalizationGracePeriodMonths
      , "repayment_model" .= liabilityOverrideRepaymentModel
      , "expected_payoff_date" .= liabilityOverrideExpectedPayoffDate
      , "guarantor" .= liabilityOverrideGuarantor
      , "is_federal" .= liabilityOverrideIsFederal
      , "loan_name" .= liabilityOverrideLoanName
      , "loan_status" .= liabilityOverrideLoanStatus
      , "payment_reference_number" .= liabilityOverridePaymentReferenceNumber
      , "pslf_status" .= liabilityOverridePslfStatus
      , "repayment_plan_description" .= liabilityOverrideRepaymentPlanDescription
      , "repayment_plan_type" .= liabilityOverrideRepaymentPlanType
      , "sequence_number" .= liabilityOverrideSequenceNumber
      , "servicer_address" .= liabilityOverrideServicerAddress
      ]


-- | Construct a value of type 'LiabilityOverride' (by applying it's required fields, if any)
mkLiabilityOverride
  :: Text -- ^ 'liabilityOverrideType': The type of the liability object, either `credit` or `student`.
  -> Double -- ^ 'liabilityOverridePurchaseApr': The purchase APR percentage value. For simplicity, this is the only interest rate used to calculate interest charges. Can only be set if `type` is `credit`.
  -> Double -- ^ 'liabilityOverrideCashApr': The cash APR percentage value. Can only be set if `type` is `credit`.
  -> Double -- ^ 'liabilityOverrideBalanceTransferApr': The balance transfer APR percentage value. Can only be set if `type` is `credit`. Can only be set if `type` is `credit`.
  -> Double -- ^ 'liabilityOverrideSpecialApr': The special APR percentage value. Can only be set if `type` is `credit`.
  -> Double -- ^ 'liabilityOverrideLastPaymentAmount': Override the `last_payment_amount` field. Can only be set if `type` is `credit`.
  -> Double -- ^ 'liabilityOverrideLastStatementBalance': Override the `last_statement_balance` field. Can only be set if `type` is `credit`.
  -> Double -- ^ 'liabilityOverrideMinimumPaymentAmount': Override the `minimum_payment_amount` field. Can only be set if `type` is `credit`.
  -> Bool -- ^ 'liabilityOverrideIsOverdue': Override the `is_overdue` field
  -> Text -- ^ 'liabilityOverrideOriginationDate': The date on which the loan was initially lent, in ISO 8601 (YYYY-MM-DD) format. Can only be set if `type` is `student`.
  -> Double -- ^ 'liabilityOverridePrincipal': The original loan principal. Can only be set if `type` is `student`.
  -> Double -- ^ 'liabilityOverrideNominalApr': The interest rate on the loan as a percentage. Can only be set if `type` is `student`.
  -> Double -- ^ 'liabilityOverrideInterestCapitalizationGracePeriodMonths': If set, interest capitalization begins at the given number of months after loan origination. By default interest is never capitalized. Can only be set if `type` is `student`.
  -> StudentLoanRepaymentModel -- ^ 'liabilityOverrideRepaymentModel' 
  -> Text -- ^ 'liabilityOverrideExpectedPayoffDate': Override the `expected_payoff_date` field. Can only be set if `type` is `student`.
  -> Text -- ^ 'liabilityOverrideGuarantor': Override the `guarantor` field. Can only be set if `type` is `student`.
  -> Bool -- ^ 'liabilityOverrideIsFederal': Override the `is_federal` field. Can only be set if `type` is `student`.
  -> Text -- ^ 'liabilityOverrideLoanName': Override the `loan_name` field. Can only be set if `type` is `student`.
  -> Text -- ^ 'liabilityOverrideLoanStatus': Override the `loan_status` field. Can only be set if `type` is `student`.
  -> Text -- ^ 'liabilityOverridePaymentReferenceNumber': Override the `payment_reference_number` field. Can only be set if `type` is `student`.
  -> Text -- ^ 'liabilityOverridePslfStatus': Override the `pslf_status` field. Can only be set if `type` is `student`.
  -> Text -- ^ 'liabilityOverrideRepaymentPlanDescription': Override the `repayment_plan.description` field. Can only be set if `type` is `student`.
  -> Text -- ^ 'liabilityOverrideRepaymentPlanType': Override the `repayment_plan.type` field. Can only be set if `type` is `student`. Possible values are: `\"extended graduated\"`, `\"extended standard\"`, `\"graduated\"`, `\"income-contingent repayment\"`, `\"income-based repayment\"`, `\"interest only\"`, `\"other\"`, `\"pay as you earn\"`, `\"revised pay as you earn\"`, or `\"standard\"`.
  -> Text -- ^ 'liabilityOverrideSequenceNumber': Override the `sequence_number` field. Can only be set if `type` is `student`.
  -> Address -- ^ 'liabilityOverrideServicerAddress' 
  -> LiabilityOverride
mkLiabilityOverride liabilityOverrideType liabilityOverridePurchaseApr liabilityOverrideCashApr liabilityOverrideBalanceTransferApr liabilityOverrideSpecialApr liabilityOverrideLastPaymentAmount liabilityOverrideLastStatementBalance liabilityOverrideMinimumPaymentAmount liabilityOverrideIsOverdue liabilityOverrideOriginationDate liabilityOverridePrincipal liabilityOverrideNominalApr liabilityOverrideInterestCapitalizationGracePeriodMonths liabilityOverrideRepaymentModel liabilityOverrideExpectedPayoffDate liabilityOverrideGuarantor liabilityOverrideIsFederal liabilityOverrideLoanName liabilityOverrideLoanStatus liabilityOverridePaymentReferenceNumber liabilityOverridePslfStatus liabilityOverrideRepaymentPlanDescription liabilityOverrideRepaymentPlanType liabilityOverrideSequenceNumber liabilityOverrideServicerAddress =
  LiabilityOverride
  { liabilityOverrideType
  , liabilityOverridePurchaseApr
  , liabilityOverrideCashApr
  , liabilityOverrideBalanceTransferApr
  , liabilityOverrideSpecialApr
  , liabilityOverrideLastPaymentAmount
  , liabilityOverrideLastStatementBalance
  , liabilityOverrideMinimumPaymentAmount
  , liabilityOverrideIsOverdue
  , liabilityOverrideOriginationDate
  , liabilityOverridePrincipal
  , liabilityOverrideNominalApr
  , liabilityOverrideInterestCapitalizationGracePeriodMonths
  , liabilityOverrideRepaymentModel
  , liabilityOverrideExpectedPayoffDate
  , liabilityOverrideGuarantor
  , liabilityOverrideIsFederal
  , liabilityOverrideLoanName
  , liabilityOverrideLoanStatus
  , liabilityOverridePaymentReferenceNumber
  , liabilityOverridePslfStatus
  , liabilityOverrideRepaymentPlanDescription
  , liabilityOverrideRepaymentPlanType
  , liabilityOverrideSequenceNumber
  , liabilityOverrideServicerAddress
  }

-- ** LinkTokenAccountFilters
-- | LinkTokenAccountFilters
-- By default, Link will only display account types that are compatible with all products supplied in the `products` parameter of `/link/token/create`. You can further limit the accounts shown in Link by using `account_filters` to specify the account subtypes to be shown in Link. Only the specified subtypes will be shown. This filtering applies to both the Account Select view (if enabled) and the Institution Select view. Institutions that do not support the selected subtypes will be omitted from Link. To indicate that all subtypes should be shown, use the value `\"all\"`. If the `account_filters` filter is used, any account type for which a filter is not specified will be entirely omitted from Link. For a full list of valid types and subtypes, see the [Account schema](/docs/api/accounts#accounts-schema).  For institutions using OAuth, the filter will not affect the list of institutions or accounts shown by the bank in the OAuth window. 
data LinkTokenAccountFilters = LinkTokenAccountFilters
  { linkTokenAccountFiltersDepository :: !(Maybe DepositoryFilter) -- ^ "depository"
  , linkTokenAccountFiltersCredit :: !(Maybe CreditFilter) -- ^ "credit"
  , linkTokenAccountFiltersLoan :: !(Maybe LoanFilter) -- ^ "loan"
  , linkTokenAccountFiltersInvestment :: !(Maybe InvestmentFilter) -- ^ "investment"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON LinkTokenAccountFilters
instance A.FromJSON LinkTokenAccountFilters where
  parseJSON = A.withObject "LinkTokenAccountFilters" $ \o ->
    LinkTokenAccountFilters
      <$> (o .:? "depository")
      <*> (o .:? "credit")
      <*> (o .:? "loan")
      <*> (o .:? "investment")

-- | ToJSON LinkTokenAccountFilters
instance A.ToJSON LinkTokenAccountFilters where
  toJSON LinkTokenAccountFilters {..} =
   _omitNulls
      [ "depository" .= linkTokenAccountFiltersDepository
      , "credit" .= linkTokenAccountFiltersCredit
      , "loan" .= linkTokenAccountFiltersLoan
      , "investment" .= linkTokenAccountFiltersInvestment
      ]


-- | Construct a value of type 'LinkTokenAccountFilters' (by applying it's required fields, if any)
mkLinkTokenAccountFilters
  :: LinkTokenAccountFilters
mkLinkTokenAccountFilters =
  LinkTokenAccountFilters
  { linkTokenAccountFiltersDepository = Nothing
  , linkTokenAccountFiltersCredit = Nothing
  , linkTokenAccountFiltersLoan = Nothing
  , linkTokenAccountFiltersInvestment = Nothing
  }

-- ** LinkTokenCreateRequest
-- | LinkTokenCreateRequest
-- LinkTokenCreateRequest defines the request schema for `/link/token/create`
data LinkTokenCreateRequest = LinkTokenCreateRequest
  { linkTokenCreateRequestClientId :: !(Maybe Text) -- ^ "client_id" - Your Plaid API &#x60;client_id&#x60;.
  , linkTokenCreateRequestSecret :: !(Maybe Text) -- ^ "secret" - Your Plaid API &#x60;secret&#x60;.
  , linkTokenCreateRequestClientName :: !(Text) -- ^ /Required/ "client_name" - The name of your application, as it should be displayed in Link.
  , linkTokenCreateRequestLanguage :: !(Text) -- ^ /Required/ "language" - The language that Link should be displayed in.  Supported languages are: - English (&#x60;&#39;en&#39;&#x60;) - French (&#x60;&#39;fr&#39;&#x60;) - Spanish (&#x60;&#39;es&#39;&#x60;) - Dutch (&#x60;&#39;nl&#39;&#x60;)  When using a Link customization, the language configured here must match the setting in the customization, or the customization will not be applied.
  , linkTokenCreateRequestCountryCodes :: !([CountryCode]) -- ^ /Required/ "country_codes" - Specify an array of Plaid-supported country codes using the ISO-3166-1 alpha-2 country code standard. Institutions from all listed countries will be shown.  Supported country codes are: &#x60;US&#x60;, &#x60;CA&#x60;, &#x60;ES&#x60;, &#x60;FR&#x60;, &#x60;GB&#x60;, &#x60;IE&#x60;, &#x60;NL&#x60;. Example value: &#x60;[&#39;US&#39;, &#39;CA&#39;]&#x60;.  If Link is launched with multiple country codes, only products that you are enabled for in all countries will be used by Link. Note that while all countries are enabled by default in Sandbox and Development, in Production only US and Canada are enabled by default. To gain access to European institutions in the Production environment, [file a product access Support ticket](https://dashboard.plaid.com/support/new/product-and-development/product-troubleshooting/request-product-access) via the Plaid dashboard. If you initialize with a European country code, your users will see the European consent panel during the Link flow.  If using a Link customization, make sure the country codes in the customization match those specified in &#x60;country_codes&#x60;. If both &#x60;country_codes&#x60; and a Link customization are used, the value in &#x60;country_codes&#x60; may override the value in the customization.  If using the Auth features Instant Match, Same-day Micro-deposits, or Automated Micro-deposits, &#x60;country_codes&#x60; must be set to &#x60;[&#39;US&#39;]&#x60;.
  , linkTokenCreateRequestUser :: !(LinkTokenCreateRequestUser) -- ^ /Required/ "user"
  , linkTokenCreateRequestProducts :: !(Maybe [Products]) -- ^ "products" - List of Plaid product(s) you wish to use. If launching Link in update mode, should be omitted; required otherwise. Valid products are:  &#x60;transactions&#x60;, &#x60;auth&#x60;, &#x60;identity&#x60;, &#x60;assets&#x60;, &#x60;investments&#x60;, &#x60;liabilities&#x60;, &#x60;payment_initiation&#x60;, &#x60;deposit_switch&#x60;  Example: &#x60;[&#39;auth&#39;, &#39;transactions&#39;]&#x60;  &#x60;balance&#x60; is *not* a valid value, the Balance product does not require explicit initalization and will automatically be initialized when any other product is initialized.  Only institutions that support *all* requested products will be shown in Link; to maximize the number of institutions listed, it is recommended to initialize Link with the minimal product set required for your use case. Additional products can be added after Link initialization by calling the relevant endpoints. For details and exceptions, see [Choosing when to initialize products](/docs/link/best-practices/#choosing-when-to-initialize-products).  In Production, you will be billed for each product that you specify when initializing Link. Note that a product cannot be removed from an Item once the Item has been initialized with that product. To stop billing on an Item for subscription-based products, such as Liabilities, Investments, and Transactions, remove the Item via &#x60;/item/remove&#x60;.
  , linkTokenCreateRequestRequiredIfSupportedProducts :: !(Maybe [RequiredIfSupportedProducts]) -- ^ "required_if_supported_products" - List of Plaid product(s) you wish to use only if the institution and account(s) selected by the user support the product. Institutions that do not support these products will still be shown in Link. The products will only be extracted and billed if the user selects an institution and account type that supports them. There should be no overlap between products and required_if_supported_products. The products array must have at least one product. For more details on using this feature, see Required if Supported Products. https://plaid.com/docs/link/initializing-products/#required-if-supported-products  Possible values: auth, identity, investments, liabilities, transactions, statements
  , linkTokenCreateRequestAdditionalConsentedProducts :: !(Maybe [AdditionalConsentedProducts]) -- ^ "additional_consented_products" - List of additional Plaid product(s) you wish to collect consent for to support your use case. These products will not be billed until you start using them by calling the relevant endpoints.
  , linkTokenCreateRequestWebhook :: !(Maybe Text) -- ^ "webhook" - The destination URL to which any webhooks should be sent.
  , linkTokenCreateRequestAccessToken :: !(Maybe AccessToken) -- ^ "access_token" - The &#x60;access_token&#x60; associated with the Item to update, used when updating or modifying an existing &#x60;access_token&#x60;. Used when launching Link in update mode, when completing the Same-day (manual) Micro-deposit flow, or (optionally) when initializing Link as part of the Payment Initiation (UK and Europe) flow.
  , linkTokenCreateRequestLinkCustomizationName :: !(Maybe Text) -- ^ "link_customization_name" - The name of the Link customization from the Plaid Dashboard to be applied to Link. If not specified, the &#x60;default&#x60; customization will be used. When using a Link customization, the language in the customization must match the language selected via the &#x60;language&#x60; parameter, and the countries in the customization should match the country codes selected via &#x60;country_codes&#x60;.
  , linkTokenCreateRequestRedirectUri :: !(Maybe Text) -- ^ "redirect_uri" - A URI indicating the destination where a user should be forwarded after completing the Link flow; used to support OAuth authentication flows when launching Link in the browser or via a webview. The &#x60;redirect_uri&#x60; should not contain any query parameters. If &#x60;android_package_name&#x60; is specified, this field should be left blank. Any redirect URI specified here must also be added under the \&quot;Allowed redirect URIs\&quot; configuration on the [developer dashboard](https://dashboard.plaid.com/team/api). In non-Sandbox (Production and Development) environments, the &#x60;redirect_uri&#x60; must begin with https.
  , linkTokenCreateRequestAndroidPackageName :: !(Maybe Text) -- ^ "android_package_name" - The name of your app&#39;s Android package. Required if using the &#x60;link_token&#x60; to initialize Link on Android. When creating a &#x60;link_token&#x60; for initializing Link on other platforms, this field must be left blank. Any package name specified here must also be added to the Allowed Android package names setting on the [developer dashboard](https://dashboard.plaid.com/team/api). 
  , linkTokenCreateRequestAccountFilters :: !(Maybe LinkTokenAccountFilters) -- ^ "account_filters"
  , linkTokenCreateRequestInstitutionId :: !(Maybe Text) -- ^ "institution_id" - Used for certain legacy use cases
  , linkTokenCreateRequestPaymentInitiation :: !(Maybe LinkTokenCreateRequestPaymentInitiation) -- ^ "payment_initiation"
  , linkTokenCreateRequestDepositSwitch :: !(Maybe LinkTokenCreateRequestDepositSwitch) -- ^ "deposit_switch"
  , linkTokenCreateRequestUpdate :: !(Maybe LinkTokenCreateRequestUpdateDict) -- ^ "update" [Using update mode to request new accounts](https://plaid.com/docs/link/update-mode/#using-update-mode-to-request-new-accounts)
  , linkTokenCreateRequestAuth :: !(Maybe LinkTokenCreateRequestAuthOptions) -- ^ "auth" – Specifies options for initializing Link for use with the Auth product. This field can be used to enable or disable extended Auth flows for the resulting Link session. Omitting any field will result in a default that can be configured by your account manager.
  , linkTokenCreateRequestTransactions :: !(Maybe LinkTokenCreateRequestTransactionsOptions)
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON LinkTokenCreateRequest
instance A.FromJSON LinkTokenCreateRequest where
  parseJSON = A.withObject "LinkTokenCreateRequest" $ \o ->
    LinkTokenCreateRequest
      <$> (o .:? "client_id")
      <*> (o .:? "secret")
      <*> (o .:  "client_name")
      <*> (o .:  "language")
      <*> (o .:  "country_codes")
      <*> (o .:  "user")
      <*> (o .:? "products")
      <*> (o .:? "required_if_supported_products")
      <*> (o .:? "additional_consented_products")
      <*> (o .:? "webhook")
      <*> (o .:? "access_token")
      <*> (o .:? "link_customization_name")
      <*> (o .:? "redirect_uri")
      <*> (o .:? "android_package_name")
      <*> (o .:? "account_filters")
      <*> (o .:? "institution_id")
      <*> (o .:? "payment_initiation")
      <*> (o .:? "deposit_switch")
      <*> (o .:? "update")
      <*> (o .:? "auth")
      <*> (o .:? "transactions")

-- | ToJSON LinkTokenCreateRequest
instance A.ToJSON LinkTokenCreateRequest where
  toJSON LinkTokenCreateRequest {..} =
   _omitNulls
      [ "client_id" .= linkTokenCreateRequestClientId
      , "secret" .= linkTokenCreateRequestSecret
      , "client_name" .= linkTokenCreateRequestClientName
      , "language" .= linkTokenCreateRequestLanguage
      , "country_codes" .= linkTokenCreateRequestCountryCodes
      , "user" .= linkTokenCreateRequestUser
      , "products" .= linkTokenCreateRequestProducts
      , "required_if_supported_products" .= linkTokenCreateRequestRequiredIfSupportedProducts
      , "additional_consented_products" .= linkTokenCreateRequestAdditionalConsentedProducts
      , "webhook" .= linkTokenCreateRequestWebhook
      , "access_token" .= linkTokenCreateRequestAccessToken
      , "link_customization_name" .= linkTokenCreateRequestLinkCustomizationName
      , "redirect_uri" .= linkTokenCreateRequestRedirectUri
      , "android_package_name" .= linkTokenCreateRequestAndroidPackageName
      , "account_filters" .= linkTokenCreateRequestAccountFilters
      , "institution_id" .= linkTokenCreateRequestInstitutionId
      , "payment_initiation" .= linkTokenCreateRequestPaymentInitiation
      , "deposit_switch" .= linkTokenCreateRequestDepositSwitch
      , "update" .= linkTokenCreateRequestUpdate
      , "auth" .= linkTokenCreateRequestAuth
      , "transactions" .= linkTokenCreateRequestTransactions
      ]


-- | Construct a value of type 'LinkTokenCreateRequest' (by applying it's required fields, if any)
mkLinkTokenCreateRequest
  :: Text -- ^ 'linkTokenCreateRequestClientName': The name of your application, as it should be displayed in Link.
  -> Text -- ^ 'linkTokenCreateRequestLanguage': The language that Link should be displayed in.  Supported languages are: - English (`'en'`) - French (`'fr'`) - Spanish (`'es'`) - Dutch (`'nl'`)  When using a Link customization, the language configured here must match the setting in the customization, or the customization will not be applied.
  -> [CountryCode] -- ^ 'linkTokenCreateRequestCountryCodes': Specify an array of Plaid-supported country codes using the ISO-3166-1 alpha-2 country code standard. Institutions from all listed countries will be shown.  Supported country codes are: `US`, `CA`, `ES`, `FR`, `GB`, `IE`, `NL`. Example value: `['US', 'CA']`.  If Link is launched with multiple country codes, only products that you are enabled for in all countries will be used by Link. Note that while all countries are enabled by default in Sandbox and Development, in Production only US and Canada are enabled by default. To gain access to European institutions in the Production environment, [file a product access Support ticket](https://dashboard.plaid.com/support/new/product-and-development/product-troubleshooting/request-product-access) via the Plaid dashboard. If you initialize with a European country code, your users will see the European consent panel during the Link flow.  If using a Link customization, make sure the country codes in the customization match those specified in `country_codes`. If both `country_codes` and a Link customization are used, the value in `country_codes` may override the value in the customization.  If using the Auth features Instant Match, Same-day Micro-deposits, or Automated Micro-deposits, `country_codes` must be set to `['US']`.
  -> LinkTokenCreateRequestUser -- ^ 'linkTokenCreateRequestUser' 
  -> LinkTokenCreateRequest
mkLinkTokenCreateRequest linkTokenCreateRequestClientName linkTokenCreateRequestLanguage linkTokenCreateRequestCountryCodes linkTokenCreateRequestUser =
  LinkTokenCreateRequest
  { linkTokenCreateRequestClientId = Nothing
  , linkTokenCreateRequestSecret = Nothing
  , linkTokenCreateRequestClientName
  , linkTokenCreateRequestLanguage
  , linkTokenCreateRequestCountryCodes
  , linkTokenCreateRequestUser
  , linkTokenCreateRequestProducts = Nothing
  , linkTokenCreateRequestRequiredIfSupportedProducts = Nothing
  , linkTokenCreateRequestAdditionalConsentedProducts = Nothing
  , linkTokenCreateRequestWebhook = Nothing
  , linkTokenCreateRequestAccessToken = Nothing
  , linkTokenCreateRequestLinkCustomizationName = Nothing
  , linkTokenCreateRequestRedirectUri = Nothing
  , linkTokenCreateRequestAndroidPackageName = Nothing
  , linkTokenCreateRequestAccountFilters = Nothing
  , linkTokenCreateRequestInstitutionId = Nothing
  , linkTokenCreateRequestPaymentInitiation = Nothing
  , linkTokenCreateRequestDepositSwitch = Nothing
  , linkTokenCreateRequestUpdate = Nothing
  , linkTokenCreateRequestAuth = Nothing
  , linkTokenCreateRequestTransactions = Nothing
  }

newtype LinkTokenCreateRequestTransactionsOptions = LinkTokenCreateRequestTransactionsOptions
  { daysRequested :: Maybe Int
  } deriving (P.Show, P.Eq, P.Typeable)
  
instance A.FromJSON LinkTokenCreateRequestTransactionsOptions where
  parseJSON = A.withObject "LinkTokenCreateRequestTransactionsOptions" $ \o ->
    LinkTokenCreateRequestTransactionsOptions
      <$> (o .:? "days_requested")
      
instance A.ToJSON LinkTokenCreateRequestTransactionsOptions where
  toJSON LinkTokenCreateRequestTransactionsOptions {..} =
   _omitNulls
      [ "days_requested" .= daysRequested ]

data LinkTokenCreateRequestAuthOptions = 
  LinkTokenCreateRequestAuthOptions
  { authTypeSelectEnabled :: Maybe Bool
  , automatedMicrodepositsEnabled :: Maybe Bool
  , instantMatchEnabled :: Maybe Bool
  , sameDayMicrodepositsEnabled :: Maybe Bool
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON LinkTokenCreateRequestAuthOptions
instance A.FromJSON LinkTokenCreateRequestAuthOptions where
  parseJSON = A.withObject "LinkTokenCreateRequestAuthOptions" $ \o ->
    LinkTokenCreateRequestAuthOptions
      <$> (o .:? "auth_type_select_enabled")
      <*> (o .:? "automated_microdeposits_enabled")
      <*> (o .:? "instant_match_enabled")
      <*> (o .:? "same_day_microdeposits_enabled")

-- | ToJSON LinkTokenCreateRequestAuthOptions
instance A.ToJSON LinkTokenCreateRequestAuthOptions where
  toJSON LinkTokenCreateRequestAuthOptions {..} =
   _omitNulls
      [ "auth_type_select_enabled" .= authTypeSelectEnabled
      , "automated_microdeposits_enabled" .= automatedMicrodepositsEnabled
      , "instant_match_enabled" .= instantMatchEnabled
      , "same_day_microdeposits_enabled" .= sameDayMicrodepositsEnabled
      ]

-- ** LinkTokenCreateRequestAccountSubtypes
-- | LinkTokenCreateRequestAccountSubtypes
-- By default, Link will only display account types that are compatible with all products supplied in the `products` parameter of `/link/token/create`. You can further limit the accounts shown in Link by using `account_filters` to specify the account subtypes to be shown in Link. Only the specified subtypes will be shown. This filtering applies to both the Account Select view (if enabled) and the Institution Select view. Institutions that do not support the selected subtypes will be omitted from Link. To indicate that all subtypes should be shown, use the value `\"all\"`. If the `account_filters` filter is used, any account type for which a filter is not specified will be entirely omitted from Link.  For a full list of valid types and subtypes, see the [Account schema](/docs/api/accounts#accounts-schema).  For institutions using OAuth, the filter will not affect the list of institutions or accounts shown by the bank in the OAuth window. 
data LinkTokenCreateRequestAccountSubtypes = LinkTokenCreateRequestAccountSubtypes
  { linkTokenCreateRequestAccountSubtypesDepository :: !(Maybe (Map.Map String A.Value)) -- ^ "depository" - A filter to apply to &#x60;depository&#x60;-type accounts
  , linkTokenCreateRequestAccountSubtypesCredit :: !(Maybe (Map.Map String A.Value)) -- ^ "credit" - A filter to apply to &#x60;credit&#x60;-type accounts
  , linkTokenCreateRequestAccountSubtypesLoan :: !(Maybe (Map.Map String A.Value)) -- ^ "loan" - A filter to apply to &#x60;loan&#x60;-type accounts
  , linkTokenCreateRequestAccountSubtypesInvestment :: !(Maybe (Map.Map String A.Value)) -- ^ "investment" - A filter to apply to &#x60;investment&#x60;-type accounts
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON LinkTokenCreateRequestAccountSubtypes
instance A.FromJSON LinkTokenCreateRequestAccountSubtypes where
  parseJSON = A.withObject "LinkTokenCreateRequestAccountSubtypes" $ \o ->
    LinkTokenCreateRequestAccountSubtypes
      <$> (o .:? "depository")
      <*> (o .:? "credit")
      <*> (o .:? "loan")
      <*> (o .:? "investment")

-- | ToJSON LinkTokenCreateRequestAccountSubtypes
instance A.ToJSON LinkTokenCreateRequestAccountSubtypes where
  toJSON LinkTokenCreateRequestAccountSubtypes {..} =
   _omitNulls
      [ "depository" .= linkTokenCreateRequestAccountSubtypesDepository
      , "credit" .= linkTokenCreateRequestAccountSubtypesCredit
      , "loan" .= linkTokenCreateRequestAccountSubtypesLoan
      , "investment" .= linkTokenCreateRequestAccountSubtypesInvestment
      ]


-- | Construct a value of type 'LinkTokenCreateRequestAccountSubtypes' (by applying it's required fields, if any)
mkLinkTokenCreateRequestAccountSubtypes
  :: LinkTokenCreateRequestAccountSubtypes
mkLinkTokenCreateRequestAccountSubtypes =
  LinkTokenCreateRequestAccountSubtypes
  { linkTokenCreateRequestAccountSubtypesDepository = Nothing
  , linkTokenCreateRequestAccountSubtypesCredit = Nothing
  , linkTokenCreateRequestAccountSubtypesLoan = Nothing
  , linkTokenCreateRequestAccountSubtypesInvestment = Nothing
  }


-- ** LinkTokenCreateRequestUpdateDict
-- | LinkTokenCreateRequestUpdateDict
data LinkTokenCreateRequestUpdateDict =
  LinkTokenCreateRequestUpdateDict
    { linkTokenCreateRequestUpdateDictAccountSelectionEnabled :: Bool,
      linkTokenCreateRequestUpdateDictReauthorizationEnabled :: Bool
  } deriving (P.Show, P.Eq, P.Typeable)


-- | FromJSON LinkTokenCreateRequestUpdateDict
instance A.FromJSON LinkTokenCreateRequestUpdateDict where
  parseJSON = A.withObject "LinkTokenCreateRequestUpdateDict" $ \o ->
    LinkTokenCreateRequestUpdateDict
      <$> (o .: "account_selection_enabled")
      <*> (o .: "reauthorization_enabled")

-- | ToJSON LinkTokenCreateRequestUpdateDict
instance A.ToJSON LinkTokenCreateRequestUpdateDict where
  toJSON LinkTokenCreateRequestUpdateDict {..} =
   _omitNulls
      [ "account_selection_enabled" .= linkTokenCreateRequestUpdateDictAccountSelectionEnabled,
        "reauthorization_enabled" .= linkTokenCreateRequestUpdateDictReauthorizationEnabled
      ]

-- | Construct a value of type 'LinkTokenCreateRequestAccountSubtypes' (by applying it's required fields, if any)
mkLinkTokenCreateRequestUpdateDict
  :: LinkTokenCreateRequestUpdateDict
mkLinkTokenCreateRequestUpdateDict =
  LinkTokenCreateRequestUpdateDict
  { linkTokenCreateRequestUpdateDictAccountSelectionEnabled = True,
    linkTokenCreateRequestUpdateDictReauthorizationEnabled = False
  }

-- ** LinkTokenCreateRequestDepositSwitch
-- | LinkTokenCreateRequestDepositSwitch
-- Specifies options for initializing Link for use with the Deposit Switch (beta) product. This field is required if `deposit_switch` is included in the `products` array.
data LinkTokenCreateRequestDepositSwitch = LinkTokenCreateRequestDepositSwitch
  { linkTokenCreateRequestDepositSwitchDepositSwitchId :: !(Text) -- ^ /Required/ "deposit_switch_id" - The &#x60;deposit_switch_id&#x60; provided by the &#x60;/deposit_switch/create&#x60; endpoint.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON LinkTokenCreateRequestDepositSwitch
instance A.FromJSON LinkTokenCreateRequestDepositSwitch where
  parseJSON = A.withObject "LinkTokenCreateRequestDepositSwitch" $ \o ->
    LinkTokenCreateRequestDepositSwitch
      <$> (o .:  "deposit_switch_id")

-- | ToJSON LinkTokenCreateRequestDepositSwitch
instance A.ToJSON LinkTokenCreateRequestDepositSwitch where
  toJSON LinkTokenCreateRequestDepositSwitch {..} =
   _omitNulls
      [ "deposit_switch_id" .= linkTokenCreateRequestDepositSwitchDepositSwitchId
      ]


-- | Construct a value of type 'LinkTokenCreateRequestDepositSwitch' (by applying it's required fields, if any)
mkLinkTokenCreateRequestDepositSwitch
  :: Text -- ^ 'linkTokenCreateRequestDepositSwitchDepositSwitchId': The `deposit_switch_id` provided by the `/deposit_switch/create` endpoint.
  -> LinkTokenCreateRequestDepositSwitch
mkLinkTokenCreateRequestDepositSwitch linkTokenCreateRequestDepositSwitchDepositSwitchId =
  LinkTokenCreateRequestDepositSwitch
  { linkTokenCreateRequestDepositSwitchDepositSwitchId
  }

-- ** LinkTokenCreateRequestIncomeVerification
-- | LinkTokenCreateRequestIncomeVerification
-- LinkTokenCreateRequestIncomeVerification
-- 
-- Specifies options for initializing Link for use with the Income Verification (beta) product. This field is required if `income_verification` is included in the `products` array.
data LinkTokenCreateRequestIncomeVerification = LinkTokenCreateRequestIncomeVerification
  { linkTokenCreateRequestIncomeVerificationIncomeVerificationId :: !(Text) -- ^ /Required/ "income_verification_id" - The &#x60;income_verification_id&#x60; of the verification instance, as provided by &#x60;/income/verification/create&#x60;.
  , linkTokenCreateRequestIncomeVerificationAssetReportId :: !(Maybe Text) -- ^ "asset_report_id" - The &#x60;asset_report_id&#x60; of an asset report associated with the user, as provided by &#x60;/asset_report/create&#x60;. Providing an &#x60;asset_report_id&#x60; is optional and can be used to verify the user through a streamlined flow. If provided, the bank linking flow will be skipped.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON LinkTokenCreateRequestIncomeVerification
instance A.FromJSON LinkTokenCreateRequestIncomeVerification where
  parseJSON = A.withObject "LinkTokenCreateRequestIncomeVerification" $ \o ->
    LinkTokenCreateRequestIncomeVerification
      <$> (o .:  "income_verification_id")
      <*> (o .:? "asset_report_id")

-- | ToJSON LinkTokenCreateRequestIncomeVerification
instance A.ToJSON LinkTokenCreateRequestIncomeVerification where
  toJSON LinkTokenCreateRequestIncomeVerification {..} =
   _omitNulls
      [ "income_verification_id" .= linkTokenCreateRequestIncomeVerificationIncomeVerificationId
      , "asset_report_id" .= linkTokenCreateRequestIncomeVerificationAssetReportId
      ]


-- | Construct a value of type 'LinkTokenCreateRequestIncomeVerification' (by applying it's required fields, if any)
mkLinkTokenCreateRequestIncomeVerification
  :: Text -- ^ 'linkTokenCreateRequestIncomeVerificationIncomeVerificationId': The `income_verification_id` of the verification instance, as provided by `/income/verification/create`.
  -> LinkTokenCreateRequestIncomeVerification
mkLinkTokenCreateRequestIncomeVerification linkTokenCreateRequestIncomeVerificationIncomeVerificationId =
  LinkTokenCreateRequestIncomeVerification
  { linkTokenCreateRequestIncomeVerificationIncomeVerificationId
  , linkTokenCreateRequestIncomeVerificationAssetReportId = Nothing
  }

-- ** LinkTokenCreateRequestPaymentInitiation
-- | LinkTokenCreateRequestPaymentInitiation
-- Specifies options for initializing Link for use with the Payment Initiation (Europe) product. This field is required if `payment_initiation` is included in the `products` array.
data LinkTokenCreateRequestPaymentInitiation = LinkTokenCreateRequestPaymentInitiation
  { linkTokenCreateRequestPaymentInitiationPaymentId :: !(Text) -- ^ /Required/ "payment_id" - The &#x60;payment_id&#x60; provided by the &#x60;/payment_initiation/payment/create&#x60; endpoint.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON LinkTokenCreateRequestPaymentInitiation
instance A.FromJSON LinkTokenCreateRequestPaymentInitiation where
  parseJSON = A.withObject "LinkTokenCreateRequestPaymentInitiation" $ \o ->
    LinkTokenCreateRequestPaymentInitiation
      <$> (o .:  "payment_id")

-- | ToJSON LinkTokenCreateRequestPaymentInitiation
instance A.ToJSON LinkTokenCreateRequestPaymentInitiation where
  toJSON LinkTokenCreateRequestPaymentInitiation {..} =
   _omitNulls
      [ "payment_id" .= linkTokenCreateRequestPaymentInitiationPaymentId
      ]


-- | Construct a value of type 'LinkTokenCreateRequestPaymentInitiation' (by applying it's required fields, if any)
mkLinkTokenCreateRequestPaymentInitiation
  :: Text -- ^ 'linkTokenCreateRequestPaymentInitiationPaymentId': The `payment_id` provided by the `/payment_initiation/payment/create` endpoint.
  -> LinkTokenCreateRequestPaymentInitiation
mkLinkTokenCreateRequestPaymentInitiation linkTokenCreateRequestPaymentInitiationPaymentId =
  LinkTokenCreateRequestPaymentInitiation
  { linkTokenCreateRequestPaymentInitiationPaymentId
  }

-- ** LinkTokenCreateRequestUser
-- | LinkTokenCreateRequestUser
-- An object specifying information about the end user who will be linking their account.
data LinkTokenCreateRequestUser = LinkTokenCreateRequestUser
  { linkTokenCreateRequestUserClientUserId :: !(Text) -- ^ /Required/ "client_user_id" - A unique ID representing the end user. Typically this will be a user ID number from your application. Personally identifiable information, such as an email address or phone number, should not be used in the &#x60;client_user_id&#x60;. It is currently used as a means of searching logs for the given user in the Plaid Dashboard.
  , linkTokenCreateRequestUserLegalName :: !(Maybe Text) -- ^ "legal_name" - The user&#39;s full legal name. This is an optional field used in the [returning user experience](/docs/link/returning-user) to associate Items to the user.
  , linkTokenCreateRequestUserPhoneNumber :: !(Maybe Text) -- ^ "phone_number" - The user&#39;s phone number in [E.164](https://en.wikipedia.org/wiki/E.164) format. This field is optional, but required to enable the [returning user experience](/docs/link/returning-user).
  , linkTokenCreateRequestUserPhoneNumberVerifiedTime :: !(Maybe Text) -- ^ "phone_number_verified_time" - The date and time the phone number was verified in ISO 8601 format (&#x60;YYYY-MM-DDThh:mm:ssZ&#x60;). This field is optional, but required to enable any [returning user experience](/docs/link/returning-user).   Only pass a verification time for a phone number that you have verified. If you have performed verification but don’t have the time, you may supply a signal value of the start of the UNIX epoch.   Example: &#x60;2020-01-01T00:00:00Z&#x60; 
  , linkTokenCreateRequestUserEmailAddress :: !(Maybe Text) -- ^ "email_address" - The user&#39;s email address. This field is optional, but required to enable the [pre-authenticated returning user flow](/docs/link/returning-user/#enabling-the-returning-user-experience).
  , linkTokenCreateRequestUserEmailAddressVerifiedTime :: !(Maybe Text) -- ^ "email_address_verified_time" - The date and time the email address was verified in ISO 8601 format (&#x60;YYYY-MM-DDThh:mm:ssZ&#x60;). This is an optional field used in the [returning user experience](/docs/link/returning-user).   Only pass a verification time for an email address that you have verified. If you have performed verification but don’t have the time, you may supply a signal value of the start of the UNIX epoch.   Example: &#x60;2020-01-01T00:00:00Z&#x60;
  , linkTokenCreateRequestUserSsn :: !(Maybe Text) -- ^ "ssn" - To be provided in the format \&quot;ddd-dd-dddd\&quot;. This field is optional and will support not-yet-implemented functionality for new products.
  , linkTokenCreateRequestUserDateOfBirth :: !(Maybe Text) -- ^ "date_of_birth" - To be provided in the format \&quot;yyyy-mm-dd\&quot;. This field is optional and will support not-yet-implemented functionality for new products.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON LinkTokenCreateRequestUser
instance A.FromJSON LinkTokenCreateRequestUser where
  parseJSON = A.withObject "LinkTokenCreateRequestUser" $ \o ->
    LinkTokenCreateRequestUser
      <$> (o .:  "client_user_id")
      <*> (o .:? "legal_name")
      <*> (o .:? "phone_number")
      <*> (o .:? "phone_number_verified_time")
      <*> (o .:? "email_address")
      <*> (o .:? "email_address_verified_time")
      <*> (o .:? "ssn")
      <*> (o .:? "date_of_birth")

-- | ToJSON LinkTokenCreateRequestUser
instance A.ToJSON LinkTokenCreateRequestUser where
  toJSON LinkTokenCreateRequestUser {..} =
   _omitNulls
      [ "client_user_id" .= linkTokenCreateRequestUserClientUserId
      , "legal_name" .= linkTokenCreateRequestUserLegalName
      , "phone_number" .= linkTokenCreateRequestUserPhoneNumber
      , "phone_number_verified_time" .= linkTokenCreateRequestUserPhoneNumberVerifiedTime
      , "email_address" .= linkTokenCreateRequestUserEmailAddress
      , "email_address_verified_time" .= linkTokenCreateRequestUserEmailAddressVerifiedTime
      , "ssn" .= linkTokenCreateRequestUserSsn
      , "date_of_birth" .= linkTokenCreateRequestUserDateOfBirth
      ]


-- | Construct a value of type 'LinkTokenCreateRequestUser' (by applying it's required fields, if any)
mkLinkTokenCreateRequestUser
  :: Text -- ^ 'linkTokenCreateRequestUserClientUserId': A unique ID representing the end user. Typically this will be a user ID number from your application. Personally identifiable information, such as an email address or phone number, should not be used in the `client_user_id`. It is currently used as a means of searching logs for the given user in the Plaid Dashboard.
  -> LinkTokenCreateRequestUser
mkLinkTokenCreateRequestUser linkTokenCreateRequestUserClientUserId =
  LinkTokenCreateRequestUser
  { linkTokenCreateRequestUserClientUserId
  , linkTokenCreateRequestUserLegalName = Nothing
  , linkTokenCreateRequestUserPhoneNumber = Nothing
  , linkTokenCreateRequestUserPhoneNumberVerifiedTime = Nothing
  , linkTokenCreateRequestUserEmailAddress = Nothing
  , linkTokenCreateRequestUserEmailAddressVerifiedTime = Nothing
  , linkTokenCreateRequestUserSsn = Nothing
  , linkTokenCreateRequestUserDateOfBirth = Nothing
  }

-- ** LinkTokenCreateResponse
-- | LinkTokenCreateResponse
-- LinkTokenCreateResponse defines the response schema for `/link/token/create`
data LinkTokenCreateResponse = LinkTokenCreateResponse
  { linkTokenCreateResponseLinkToken :: !(Text) -- ^ /Required/ "link_token" - A &#x60;link_token&#x60;, which can be supplied to Link in order to initialize it and receive a &#x60;public_token&#x60;, which can be exchanged for an &#x60;access_token&#x60;.
  , linkTokenCreateResponseExpiration :: !(DateTime) -- ^ /Required/ "expiration" - The expiration date for the &#x60;link_token&#x60;, in ISO 8601 format. A &#x60;link_token&#x60; created to generate a &#x60;public_token&#x60; that will be exchanged for a new &#x60;access_token&#x60; expires after 4 hours. A &#x60;link_token&#x60; created for an existing Item (such as when updating an existing &#x60;access_token&#x60; by launching Link in update mode) expires after 30 minutes.
  , linkTokenCreateResponseRequestId :: !(Text) -- ^ /Required/ "request_id" - A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON LinkTokenCreateResponse
instance A.FromJSON LinkTokenCreateResponse where
  parseJSON = A.withObject "LinkTokenCreateResponse" $ \o ->
    LinkTokenCreateResponse
      <$> (o .:  "link_token")
      <*> (o .:  "expiration")
      <*> (o .:  "request_id")

-- | ToJSON LinkTokenCreateResponse
instance A.ToJSON LinkTokenCreateResponse where
  toJSON LinkTokenCreateResponse {..} =
   _omitNulls
      [ "link_token" .= linkTokenCreateResponseLinkToken
      , "expiration" .= linkTokenCreateResponseExpiration
      , "request_id" .= linkTokenCreateResponseRequestId
      ]


-- | Construct a value of type 'LinkTokenCreateResponse' (by applying it's required fields, if any)
mkLinkTokenCreateResponse
  :: Text -- ^ 'linkTokenCreateResponseLinkToken': A `link_token`, which can be supplied to Link in order to initialize it and receive a `public_token`, which can be exchanged for an `access_token`.
  -> DateTime -- ^ 'linkTokenCreateResponseExpiration': The expiration date for the `link_token`, in ISO 8601 format. A `link_token` created to generate a `public_token` that will be exchanged for a new `access_token` expires after 4 hours. A `link_token` created for an existing Item (such as when updating an existing `access_token` by launching Link in update mode) expires after 30 minutes.
  -> Text -- ^ 'linkTokenCreateResponseRequestId': A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  -> LinkTokenCreateResponse
mkLinkTokenCreateResponse linkTokenCreateResponseLinkToken linkTokenCreateResponseExpiration linkTokenCreateResponseRequestId =
  LinkTokenCreateResponse
  { linkTokenCreateResponseLinkToken
  , linkTokenCreateResponseExpiration
  , linkTokenCreateResponseRequestId
  }

-- ** LinkTokenGetMetadataResponse
-- | LinkTokenGetMetadataResponse
-- An object specifying the arguments originally provided to the `/link/token/create` call.
data LinkTokenGetMetadataResponse = LinkTokenGetMetadataResponse
  { linkTokenGetMetadataResponseInitialProducts :: !(Maybe [Products]) -- ^ "initial_products" - The &#x60;products&#x60; specified in the &#x60;/link/token/create&#x60; call.
  , linkTokenGetMetadataResponseWebhook :: !(Maybe Text) -- ^ "webhook" - The &#x60;webhook&#x60; specified in the &#x60;/link/token/create&#x60; call.
  , linkTokenGetMetadataResponseCountryCodes :: !(Maybe [CountryCode]) -- ^ "country_codes" - The &#x60;country_codes&#x60; specified in the &#x60;/link/token/create&#x60; call.
  , linkTokenGetMetadataResponseLanguage :: !(Maybe Text) -- ^ "language" - The &#x60;language&#x60; specified in the &#x60;/link/token/create&#x60; call.
  , linkTokenGetMetadataResponseAccountFilters :: !(Maybe AccountFiltersResponse) -- ^ "account_filters"
  , linkTokenGetMetadataResponseRedirectUri :: !(Maybe Text) -- ^ "redirect_uri" - The &#x60;redirect_uri&#x60; specified in the &#x60;/link/token/create&#x60; call.
  , linkTokenGetMetadataResponseClientName :: !(Maybe Text) -- ^ "client_name" - The &#x60;client_name&#x60; specified in the &#x60;/link/token/create&#x60; call.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON LinkTokenGetMetadataResponse
instance A.FromJSON LinkTokenGetMetadataResponse where
  parseJSON = A.withObject "LinkTokenGetMetadataResponse" $ \o ->
    LinkTokenGetMetadataResponse
      <$> (o .:? "initial_products")
      <*> (o .:? "webhook")
      <*> (o .:? "country_codes")
      <*> (o .:? "language")
      <*> (o .:? "account_filters")
      <*> (o .:? "redirect_uri")
      <*> (o .:? "client_name")

-- | ToJSON LinkTokenGetMetadataResponse
instance A.ToJSON LinkTokenGetMetadataResponse where
  toJSON LinkTokenGetMetadataResponse {..} =
   _omitNulls
      [ "initial_products" .= linkTokenGetMetadataResponseInitialProducts
      , "webhook" .= linkTokenGetMetadataResponseWebhook
      , "country_codes" .= linkTokenGetMetadataResponseCountryCodes
      , "language" .= linkTokenGetMetadataResponseLanguage
      , "account_filters" .= linkTokenGetMetadataResponseAccountFilters
      , "redirect_uri" .= linkTokenGetMetadataResponseRedirectUri
      , "client_name" .= linkTokenGetMetadataResponseClientName
      ]


-- | Construct a value of type 'LinkTokenGetMetadataResponse' (by applying it's required fields, if any)
mkLinkTokenGetMetadataResponse
  :: LinkTokenGetMetadataResponse
mkLinkTokenGetMetadataResponse =
  LinkTokenGetMetadataResponse
  { linkTokenGetMetadataResponseInitialProducts = Nothing
  , linkTokenGetMetadataResponseWebhook = Nothing
  , linkTokenGetMetadataResponseCountryCodes = Nothing
  , linkTokenGetMetadataResponseLanguage = Nothing
  , linkTokenGetMetadataResponseAccountFilters = Nothing
  , linkTokenGetMetadataResponseRedirectUri = Nothing
  , linkTokenGetMetadataResponseClientName = Nothing
  }

-- ** LinkTokenGetRequest
-- | LinkTokenGetRequest
-- LinkTokenGetRequest defines the request schema for `/link/token/get`
data LinkTokenGetRequest = LinkTokenGetRequest
  { linkTokenGetRequestClientId :: !(Maybe Text) -- ^ "client_id" - Your Plaid API &#x60;client_id&#x60;.
  , linkTokenGetRequestSecret :: !(Maybe Text) -- ^ "secret" - Your Plaid API &#x60;secret&#x60;.
  , linkTokenGetRequestLinkToken :: !(Text) -- ^ /Required/ "link_token" - A &#x60;link_token&#x60; from a previous invocation of &#x60;/link/token/create&#x60;
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON LinkTokenGetRequest
instance A.FromJSON LinkTokenGetRequest where
  parseJSON = A.withObject "LinkTokenGetRequest" $ \o ->
    LinkTokenGetRequest
      <$> (o .:? "client_id")
      <*> (o .:? "secret")
      <*> (o .:  "link_token")

-- | ToJSON LinkTokenGetRequest
instance A.ToJSON LinkTokenGetRequest where
  toJSON LinkTokenGetRequest {..} =
   _omitNulls
      [ "client_id" .= linkTokenGetRequestClientId
      , "secret" .= linkTokenGetRequestSecret
      , "link_token" .= linkTokenGetRequestLinkToken
      ]


-- | Construct a value of type 'LinkTokenGetRequest' (by applying it's required fields, if any)
mkLinkTokenGetRequest
  :: Text -- ^ 'linkTokenGetRequestLinkToken': A `link_token` from a previous invocation of `/link/token/create`
  -> LinkTokenGetRequest
mkLinkTokenGetRequest linkTokenGetRequestLinkToken =
  LinkTokenGetRequest
  { linkTokenGetRequestClientId = Nothing
  , linkTokenGetRequestSecret = Nothing
  , linkTokenGetRequestLinkToken
  }

-- ** LinkTokenGetResponse
-- | LinkTokenGetResponse
-- LinkTokenGetResponse defines the response schema for `/link/token/get`
data LinkTokenGetResponse = LinkTokenGetResponse
  { linkTokenGetResponseLinkToken :: !(Maybe Text) -- ^ "link_token" - A &#x60;link_token&#x60;, which can be supplied to Link in order to initialize it and receive a &#x60;public_token&#x60;, which can be exchanged for an &#x60;access_token&#x60;.
  , linkTokenGetResponseCreatedAt :: !(Maybe DateTime) -- ^ "created_at" - The creation timestamp for the &#x60;link_token&#x60;, in ISO 8601 format.
  , linkTokenGetResponseExpiration :: !(Maybe DateTime) -- ^ "expiration" - The expiration timestamp for the &#x60;link_token&#x60;, in ISO 8601 format.
  , linkTokenGetResponseMetadata :: !(Maybe LinkTokenGetMetadataResponse) -- ^ "metadata"
  , linkTokenGetResponseRequestId :: !(Text) -- ^ /Required/ "request_id" - A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON LinkTokenGetResponse
instance A.FromJSON LinkTokenGetResponse where
  parseJSON = A.withObject "LinkTokenGetResponse" $ \o ->
    LinkTokenGetResponse
      <$> (o .:? "link_token")
      <*> (o .:? "created_at")
      <*> (o .:? "expiration")
      <*> (o .:? "metadata")
      <*> (o .:  "request_id")

-- | ToJSON LinkTokenGetResponse
instance A.ToJSON LinkTokenGetResponse where
  toJSON LinkTokenGetResponse {..} =
   _omitNulls
      [ "link_token" .= linkTokenGetResponseLinkToken
      , "created_at" .= linkTokenGetResponseCreatedAt
      , "expiration" .= linkTokenGetResponseExpiration
      , "metadata" .= linkTokenGetResponseMetadata
      , "request_id" .= linkTokenGetResponseRequestId
      ]


-- | Construct a value of type 'LinkTokenGetResponse' (by applying it's required fields, if any)
mkLinkTokenGetResponse
  :: Text -- ^ 'linkTokenGetResponseRequestId': A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  -> LinkTokenGetResponse
mkLinkTokenGetResponse linkTokenGetResponseRequestId =
  LinkTokenGetResponse
  { linkTokenGetResponseLinkToken = Nothing
  , linkTokenGetResponseCreatedAt = Nothing
  , linkTokenGetResponseExpiration = Nothing
  , linkTokenGetResponseMetadata = Nothing
  , linkTokenGetResponseRequestId
  }

-- ** LoanFilter
-- | LoanFilter
-- LoanFilter
-- 
-- A filter to apply to `loan`-type accounts
data LoanFilter = LoanFilter
  { loanFilterAccountSubtypes :: !([AccountSubtype]) -- ^ /Required/ "account_subtypes" - An array of account subtypes to display in Link. If not specified, all account subtypes will be shown. For a full list of valid types and subtypes, see the [Account schema](/docs/api/accounts#accounts-schema). 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON LoanFilter
instance A.FromJSON LoanFilter where
  parseJSON = A.withObject "LoanFilter" $ \o ->
    LoanFilter
      <$> (o .:  "account_subtypes")

-- | ToJSON LoanFilter
instance A.ToJSON LoanFilter where
  toJSON LoanFilter {..} =
   _omitNulls
      [ "account_subtypes" .= loanFilterAccountSubtypes
      ]


-- | Construct a value of type 'LoanFilter' (by applying it's required fields, if any)
mkLoanFilter
  :: [AccountSubtype] -- ^ 'loanFilterAccountSubtypes': An array of account subtypes to display in Link. If not specified, all account subtypes will be shown. For a full list of valid types and subtypes, see the [Account schema](/docs/api/accounts#accounts-schema). 
  -> LoanFilter
mkLoanFilter loanFilterAccountSubtypes =
  LoanFilter
  { loanFilterAccountSubtypes
  }

-- ** Location
-- | Location
-- Transaction Location
-- 
-- A representation of where a transaction took place
data Location = Location
  { locationAddress :: !(Maybe Text) -- ^ "address" - The street address where the transaction occurred.
  , locationCity :: !(Maybe Text) -- ^ "city" - The city where the transaction occurred.
  , locationRegion :: !(Maybe Text) -- ^ "region" - The region or state where the transaction occurred.
  , locationPostalCode :: !(Maybe Text) -- ^ "postal_code" - The postal code where the transaction occurred.
  , locationCountry :: !(Maybe Text) -- ^ "country" - The ISO 3166-1 alpha-2 country code where the transaction occurred.
  , locationLat :: !(Maybe Double) -- ^ "lat" - The latitude where the transaction occurred.
  , locationLon :: !(Maybe Double) -- ^ "lon" - The longitude where the transaction occurred.
  , locationStoreNumber :: !(Maybe Text) -- ^ "store_number" - The merchant defined store number where the transaction occurred.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Location
instance A.FromJSON Location where
  parseJSON = A.withObject "Location" $ \o ->
    Location
      <$> (o .:? "address")
      <*> (o .:? "city")
      <*> (o .:? "region")
      <*> (o .:? "postal_code")
      <*> (o .:? "country")
      <*> (o .:? "lat")
      <*> (o .:? "lon")
      <*> (o .:? "store_number")

-- | ToJSON Location
instance A.ToJSON Location where
  toJSON Location {..} =
   _omitNulls
      [ "address" .= locationAddress
      , "city" .= locationCity
      , "region" .= locationRegion
      , "postal_code" .= locationPostalCode
      , "country" .= locationCountry
      , "lat" .= locationLat
      , "lon" .= locationLon
      , "store_number" .= locationStoreNumber
      ]


-- | Construct a value of type 'Location' (by applying it's required fields, if any)
mkLocation
  :: Location
mkLocation =
  Location
  { locationAddress = Nothing
  , locationCity = Nothing
  , locationRegion = Nothing
  , locationPostalCode = Nothing
  , locationCountry = Nothing
  , locationLat = Nothing
  , locationLon = Nothing
  , locationStoreNumber = Nothing
  }

-- ** MFA
-- | MFA
-- MFA
-- 
-- Specifies the multi-factor authentication settings to use with this test account
data MFA = MFA
  { mFAType :: !(Text) -- ^ /Required/ "type" - Possible values are &#x60;device&#x60;, &#x60;selections&#x60;, or &#x60;questions&#x60;.  If value is &#x60;device&#x60;, the MFA answer is &#x60;1234&#x60;.  If value is &#x60;selections&#x60;, the MFA answer is always the first option.  If value is &#x60;questions&#x60;, the MFA answer is  &#x60;answer_&lt;i&gt;_&lt;j&gt;&#x60; for the j-th question in the i-th round, starting from 0. For example, the answer to the first question in the second round is &#x60;answer_1_0&#x60;.
  , mFAQuestionRounds :: !(Double) -- ^ /Required/ "question_rounds" - Number of rounds of questions. Required if value of &#x60;type&#x60; is &#x60;questions&#x60;. 
  , mFAQuestionsPerRound :: !(Double) -- ^ /Required/ "questions_per_round" - Number of questions per round. Required if value of &#x60;type&#x60; is &#x60;questions&#x60;. If value of type is &#x60;selections&#x60;, default value is 2.
  , mFASelectionRounds :: !(Double) -- ^ /Required/ "selection_rounds" - Number of rounds of selections, used if &#x60;type&#x60; is &#x60;selections&#x60;. Defaults to 1.
  , mFASelectionsPerQuestion :: !(Double) -- ^ /Required/ "selections_per_question" - Number of available answers per question, used if &#x60;type&#x60; is &#x60;selection&#x60;. Defaults to 2. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MFA
instance A.FromJSON MFA where
  parseJSON = A.withObject "MFA" $ \o ->
    MFA
      <$> (o .:  "type")
      <*> (o .:  "question_rounds")
      <*> (o .:  "questions_per_round")
      <*> (o .:  "selection_rounds")
      <*> (o .:  "selections_per_question")

-- | ToJSON MFA
instance A.ToJSON MFA where
  toJSON MFA {..} =
   _omitNulls
      [ "type" .= mFAType
      , "question_rounds" .= mFAQuestionRounds
      , "questions_per_round" .= mFAQuestionsPerRound
      , "selection_rounds" .= mFASelectionRounds
      , "selections_per_question" .= mFASelectionsPerQuestion
      ]


-- | Construct a value of type 'MFA' (by applying it's required fields, if any)
mkMFA
  :: Text -- ^ 'mFAType': Possible values are `device`, `selections`, or `questions`.  If value is `device`, the MFA answer is `1234`.  If value is `selections`, the MFA answer is always the first option.  If value is `questions`, the MFA answer is  `answer_<i>_<j>` for the j-th question in the i-th round, starting from 0. For example, the answer to the first question in the second round is `answer_1_0`.
  -> Double -- ^ 'mFAQuestionRounds': Number of rounds of questions. Required if value of `type` is `questions`. 
  -> Double -- ^ 'mFAQuestionsPerRound': Number of questions per round. Required if value of `type` is `questions`. If value of type is `selections`, default value is 2.
  -> Double -- ^ 'mFASelectionRounds': Number of rounds of selections, used if `type` is `selections`. Defaults to 1.
  -> Double -- ^ 'mFASelectionsPerQuestion': Number of available answers per question, used if `type` is `selection`. Defaults to 2. 
  -> MFA
mkMFA mFAType mFAQuestionRounds mFAQuestionsPerRound mFASelectionRounds mFASelectionsPerQuestion =
  MFA
  { mFAType
  , mFAQuestionRounds
  , mFAQuestionsPerRound
  , mFASelectionRounds
  , mFASelectionsPerQuestion
  }

-- ** Meta
-- | Meta
-- Meta
-- 
-- Allows specifying the metadata of the test account
data Meta = Meta
  { metaName :: !(Text) -- ^ /Required/ "name" - The account&#39;s name
  , metaOfficialName :: !(Text) -- ^ /Required/ "official_name" - The account&#39;s official name
  , metaLimit :: !(Double) -- ^ /Required/ "limit" - The account&#39;s limit
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Meta
instance A.FromJSON Meta where
  parseJSON = A.withObject "Meta" $ \o ->
    Meta
      <$> (o .:  "name")
      <*> (o .:  "official_name")
      <*> (o .:  "limit")

-- | ToJSON Meta
instance A.ToJSON Meta where
  toJSON Meta {..} =
   _omitNulls
      [ "name" .= metaName
      , "official_name" .= metaOfficialName
      , "limit" .= metaLimit
      ]


-- | Construct a value of type 'Meta' (by applying it's required fields, if any)
mkMeta
  :: Text -- ^ 'metaName': The account's name
  -> Text -- ^ 'metaOfficialName': The account's official name
  -> Double -- ^ 'metaLimit': The account's limit
  -> Meta
mkMeta metaName metaOfficialName metaLimit =
  Meta
  { metaName
  , metaOfficialName
  , metaLimit
  }

-- ** MortgageInterestRate
-- | MortgageInterestRate
-- MortgageInterestRate
-- 
-- Object containing metadata about the interest rate for the mortgage.
data MortgageInterestRate = MortgageInterestRate
  { mortgageInterestRatePercentage :: !(Maybe Double) -- ^ "percentage" - Percentage value (interest rate of current mortgage, not APR) of interest payable on a loan.
  , mortgageInterestRateType :: !(Maybe Text) -- ^ "type" - The type of interest charged (fixed or variable).
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MortgageInterestRate
instance A.FromJSON MortgageInterestRate where
  parseJSON = A.withObject "MortgageInterestRate" $ \o ->
    MortgageInterestRate
      <$> (o .:? "percentage")
      <*> (o .:? "type")

-- | ToJSON MortgageInterestRate
instance A.ToJSON MortgageInterestRate where
  toJSON MortgageInterestRate {..} =
   _omitNulls
      [ "percentage" .= mortgageInterestRatePercentage
      , "type" .= mortgageInterestRateType
      ]


-- | Construct a value of type 'MortgageInterestRate' (by applying it's required fields, if any)
mkMortgageInterestRate
  :: MortgageInterestRate
mkMortgageInterestRate =
  MortgageInterestRate
  { mortgageInterestRatePercentage = Nothing
  , mortgageInterestRateType = Nothing
  }

-- ** MortgageLiability
-- | MortgageLiability
-- MortgageLiability
-- 
-- Contains details about a mortgage account.
data MortgageLiability = MortgageLiability
  { mortgageLiabilityAccountId :: !(Maybe Text) -- ^ "account_id" - The ID of the account that this liability belongs to.
  , mortgageLiabilityAccountNumber :: !(Text) -- ^ /Required/ "account_number" - The account number of the loan.
  , mortgageLiabilityCurrentLateFee :: !(Maybe Double) -- ^ "current_late_fee" - The current outstanding amount charged for late payment.
  , mortgageLiabilityEscrowBalance :: !(Maybe Double) -- ^ "escrow_balance" - Total amount held in escrow to pay taxes and insurance on behalf of the borrower.
  , mortgageLiabilityHasPmi :: !(Maybe Bool) -- ^ "has_pmi" - Indicates whether the borrower has private mortgage insurance in effect.
  , mortgageLiabilityHasPrepaymentPenalty :: !(Maybe Bool) -- ^ "has_prepayment_penalty" - Indicates whether the borrower will pay a penalty for early payoff of mortgage.
  , mortgageLiabilityInterestRate :: !(Maybe MortgageInterestRate) -- ^ "interest_rate"
  , mortgageLiabilityLastPaymentAmount :: !(Maybe Double) -- ^ "last_payment_amount" - The amount of the last payment.
  , mortgageLiabilityLastPaymentDate :: !(Maybe Text) -- ^ "last_payment_date" - The date of the last payment. Dates are returned in an ISO 8601 format (YYYY-MM-DD).
  , mortgageLiabilityLoanTypeDescription :: !(Maybe Text) -- ^ "loan_type_description" - Description of the type of loan, for example &#x60;conventional&#x60;, &#x60;fixed&#x60;, or &#x60;variable&#x60;. This field is provided directly from the loan servicer and does not have an enumerated set of possible values.
  , mortgageLiabilityLoanTerm :: !(Maybe Text) -- ^ "loan_term" - Full duration of mortgage as at origination (e.g. &#x60;10 year&#x60;).
  , mortgageLiabilityMaturityDate :: !(Maybe Text) -- ^ "maturity_date" - Original date on which mortgage is due in full. Dates are returned in an ISO 8601 format (YYYY-MM-DD).
  , mortgageLiabilityNextMonthlyPayment :: !(Maybe Double) -- ^ "next_monthly_payment" - The amount of the next payment.
  , mortgageLiabilityNextPaymentDueDate :: !(Maybe Text) -- ^ "next_payment_due_date" - The due date for the next payment. Dates are returned in an ISO 8601 format (YYYY-MM-DD).
  , mortgageLiabilityOriginationDate :: !(Maybe Text) -- ^ "origination_date" - The date on which the loan was initially lent. Dates are returned in an ISO 8601 format (YYYY-MM-DD).
  , mortgageLiabilityOriginationPrincipalAmount :: !(Maybe Double) -- ^ "origination_principal_amount" - The original principal balance of the mortgage.
  , mortgageLiabilityPastDueAmount :: !(Maybe Double) -- ^ "past_due_amount" - Amount of loan (principal + interest) past due for payment.
  , mortgageLiabilityPropertyAddress :: !(Maybe MortgagePropertyAddress) -- ^ "property_address"
  , mortgageLiabilityYtdInterestPaid :: !(Maybe Double) -- ^ "ytd_interest_paid" - The year to date (YTD) interest paid.
  , mortgageLiabilityYtdPrincipalPaid :: !(Maybe Double) -- ^ "ytd_principal_paid" - The YTD principal paid.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MortgageLiability
instance A.FromJSON MortgageLiability where
  parseJSON = A.withObject "MortgageLiability" $ \o ->
    MortgageLiability
      <$> (o .:? "account_id")
      <*> (o .:  "account_number")
      <*> (o .:? "current_late_fee")
      <*> (o .:? "escrow_balance")
      <*> (o .:? "has_pmi")
      <*> (o .:? "has_prepayment_penalty")
      <*> (o .:? "interest_rate")
      <*> (o .:? "last_payment_amount")
      <*> (o .:? "last_payment_date")
      <*> (o .:? "loan_type_description")
      <*> (o .:? "loan_term")
      <*> (o .:? "maturity_date")
      <*> (o .:? "next_monthly_payment")
      <*> (o .:? "next_payment_due_date")
      <*> (o .:? "origination_date")
      <*> (o .:? "origination_principal_amount")
      <*> (o .:? "past_due_amount")
      <*> (o .:? "property_address")
      <*> (o .:? "ytd_interest_paid")
      <*> (o .:? "ytd_principal_paid")

-- | ToJSON MortgageLiability
instance A.ToJSON MortgageLiability where
  toJSON MortgageLiability {..} =
   _omitNulls
      [ "account_id" .= mortgageLiabilityAccountId
      , "account_number" .= mortgageLiabilityAccountNumber
      , "current_late_fee" .= mortgageLiabilityCurrentLateFee
      , "escrow_balance" .= mortgageLiabilityEscrowBalance
      , "has_pmi" .= mortgageLiabilityHasPmi
      , "has_prepayment_penalty" .= mortgageLiabilityHasPrepaymentPenalty
      , "interest_rate" .= mortgageLiabilityInterestRate
      , "last_payment_amount" .= mortgageLiabilityLastPaymentAmount
      , "last_payment_date" .= mortgageLiabilityLastPaymentDate
      , "loan_type_description" .= mortgageLiabilityLoanTypeDescription
      , "loan_term" .= mortgageLiabilityLoanTerm
      , "maturity_date" .= mortgageLiabilityMaturityDate
      , "next_monthly_payment" .= mortgageLiabilityNextMonthlyPayment
      , "next_payment_due_date" .= mortgageLiabilityNextPaymentDueDate
      , "origination_date" .= mortgageLiabilityOriginationDate
      , "origination_principal_amount" .= mortgageLiabilityOriginationPrincipalAmount
      , "past_due_amount" .= mortgageLiabilityPastDueAmount
      , "property_address" .= mortgageLiabilityPropertyAddress
      , "ytd_interest_paid" .= mortgageLiabilityYtdInterestPaid
      , "ytd_principal_paid" .= mortgageLiabilityYtdPrincipalPaid
      ]


-- | Construct a value of type 'MortgageLiability' (by applying it's required fields, if any)
mkMortgageLiability
  :: Text -- ^ 'mortgageLiabilityAccountNumber': The account number of the loan.
  -> MortgageLiability
mkMortgageLiability mortgageLiabilityAccountNumber =
  MortgageLiability
  { mortgageLiabilityAccountId = Nothing
  , mortgageLiabilityAccountNumber
  , mortgageLiabilityCurrentLateFee = Nothing
  , mortgageLiabilityEscrowBalance = Nothing
  , mortgageLiabilityHasPmi = Nothing
  , mortgageLiabilityHasPrepaymentPenalty = Nothing
  , mortgageLiabilityInterestRate = Nothing
  , mortgageLiabilityLastPaymentAmount = Nothing
  , mortgageLiabilityLastPaymentDate = Nothing
  , mortgageLiabilityLoanTypeDescription = Nothing
  , mortgageLiabilityLoanTerm = Nothing
  , mortgageLiabilityMaturityDate = Nothing
  , mortgageLiabilityNextMonthlyPayment = Nothing
  , mortgageLiabilityNextPaymentDueDate = Nothing
  , mortgageLiabilityOriginationDate = Nothing
  , mortgageLiabilityOriginationPrincipalAmount = Nothing
  , mortgageLiabilityPastDueAmount = Nothing
  , mortgageLiabilityPropertyAddress = Nothing
  , mortgageLiabilityYtdInterestPaid = Nothing
  , mortgageLiabilityYtdPrincipalPaid = Nothing
  }

-- ** MortgagePropertyAddress
-- | MortgagePropertyAddress
-- MortgagePropertyAddress
-- 
-- Object containing fields describing property address.
data MortgagePropertyAddress = MortgagePropertyAddress
  { mortgagePropertyAddressCity :: !(Maybe Text) -- ^ "city" - The city name.
  , mortgagePropertyAddressCountry :: !(Maybe Text) -- ^ "country" - The ISO 3166-1 alpha-2 country code.
  , mortgagePropertyAddressPostalCode :: !(Maybe Text) -- ^ "postal_code" - The five or nine digit postal code.
  , mortgagePropertyAddressRegion :: !(Maybe Text) -- ^ "region" - The region or state (example \&quot;NC\&quot;).
  , mortgagePropertyAddressStreet :: !(Maybe Text) -- ^ "street" - The full street address (example \&quot;564 Main Street, Apt 15\&quot;).
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MortgagePropertyAddress
instance A.FromJSON MortgagePropertyAddress where
  parseJSON = A.withObject "MortgagePropertyAddress" $ \o ->
    MortgagePropertyAddress
      <$> (o .:? "city")
      <*> (o .:? "country")
      <*> (o .:? "postal_code")
      <*> (o .:? "region")
      <*> (o .:? "street")

-- | ToJSON MortgagePropertyAddress
instance A.ToJSON MortgagePropertyAddress where
  toJSON MortgagePropertyAddress {..} =
   _omitNulls
      [ "city" .= mortgagePropertyAddressCity
      , "country" .= mortgagePropertyAddressCountry
      , "postal_code" .= mortgagePropertyAddressPostalCode
      , "region" .= mortgagePropertyAddressRegion
      , "street" .= mortgagePropertyAddressStreet
      ]


-- | Construct a value of type 'MortgagePropertyAddress' (by applying it's required fields, if any)
mkMortgagePropertyAddress
  :: MortgagePropertyAddress
mkMortgagePropertyAddress =
  MortgagePropertyAddress
  { mortgagePropertyAddressCity = Nothing
  , mortgagePropertyAddressCountry = Nothing
  , mortgagePropertyAddressPostalCode = Nothing
  , mortgagePropertyAddressRegion = Nothing
  , mortgagePropertyAddressStreet = Nothing
  }

-- ** NullableAccessToken
-- | NullableAccessToken
data NullableAccessToken = NullableAccessToken
  { 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NullableAccessToken
instance A.FromJSON NullableAccessToken where
  parseJSON = A.withObject "NullableAccessToken" $ \o ->
    pure NullableAccessToken
      

-- | ToJSON NullableAccessToken
instance A.ToJSON NullableAccessToken where
  toJSON NullableAccessToken  =
   _omitNulls
      [ 
      ]


-- | Construct a value of type 'NullableAccessToken' (by applying it's required fields, if any)
mkNullableAccessToken
  :: NullableAccessToken
mkNullableAccessToken =
  NullableAccessToken
  { 
  }

-- ** NullableAddress
-- | NullableAddress
data NullableAddress = NullableAddress
  { nullableAddressData :: !(AddressData) -- ^ /Required/ "data"
  , nullableAddressPrimary :: !(Maybe Bool) -- ^ "primary" - When &#x60;true&#x60;, identifies the address as the primary address on an account.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NullableAddress
instance A.FromJSON NullableAddress where
  parseJSON = A.withObject "NullableAddress" $ \o ->
    NullableAddress
      <$> (o .:  "data")
      <*> (o .:? "primary")

-- | ToJSON NullableAddress
instance A.ToJSON NullableAddress where
  toJSON NullableAddress {..} =
   _omitNulls
      [ "data" .= nullableAddressData
      , "primary" .= nullableAddressPrimary
      ]


-- | Construct a value of type 'NullableAddress' (by applying it's required fields, if any)
mkNullableAddress
  :: AddressData -- ^ 'nullableAddressData' 
  -> NullableAddress
mkNullableAddress nullableAddressData =
  NullableAddress
  { nullableAddressData
  , nullableAddressPrimary = Nothing
  }

-- ** NullableAddressData
-- | NullableAddressData
data NullableAddressData = NullableAddressData
  { nullableAddressDataCity :: !(Text) -- ^ /Required/ "city" - The full city name
  , nullableAddressDataRegion :: !(Maybe Text) -- ^ "region" - The region or state Example: &#x60;\&quot;NC\&quot;&#x60;
  , nullableAddressDataStreet :: !(Text) -- ^ /Required/ "street" - The full street address Example: &#x60;\&quot;564 Main Street, APT 15\&quot;&#x60;
  , nullableAddressDataPostalCode :: !(Maybe Text) -- ^ "postal_code" - The postal code
  , nullableAddressDataCountry :: !(Text) -- ^ /Required/ "country" - The ISO 3166-1 alpha-2 country code
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NullableAddressData
instance A.FromJSON NullableAddressData where
  parseJSON = A.withObject "NullableAddressData" $ \o ->
    NullableAddressData
      <$> (o .:  "city")
      <*> (o .:? "region")
      <*> (o .:  "street")
      <*> (o .:? "postal_code")
      <*> (o .:  "country")

-- | ToJSON NullableAddressData
instance A.ToJSON NullableAddressData where
  toJSON NullableAddressData {..} =
   _omitNulls
      [ "city" .= nullableAddressDataCity
      , "region" .= nullableAddressDataRegion
      , "street" .= nullableAddressDataStreet
      , "postal_code" .= nullableAddressDataPostalCode
      , "country" .= nullableAddressDataCountry
      ]


-- | Construct a value of type 'NullableAddressData' (by applying it's required fields, if any)
mkNullableAddressData
  :: Text -- ^ 'nullableAddressDataCity': The full city name
  -> Text -- ^ 'nullableAddressDataStreet': The full street address Example: `\"564 Main Street, APT 15\"`
  -> Text -- ^ 'nullableAddressDataCountry': The ISO 3166-1 alpha-2 country code
  -> NullableAddressData
mkNullableAddressData nullableAddressDataCity nullableAddressDataStreet nullableAddressDataCountry =
  NullableAddressData
  { nullableAddressDataCity
  , nullableAddressDataRegion = Nothing
  , nullableAddressDataStreet
  , nullableAddressDataPostalCode = Nothing
  , nullableAddressDataCountry
  }

-- ** NullableItemStatus
-- | NullableItemStatus
data NullableItemStatus = NullableItemStatus
  { nullableItemStatusInvestments :: !(Maybe (Map.Map String A.Value)) -- ^ "investments" - Information about the last successful and failed investments update for the Item.
  , nullableItemStatusTransactions :: !(Maybe (Map.Map String A.Value)) -- ^ "transactions" - Information about the last successful and failed transactions update for the Item.
  , nullableItemStatusLastWebhook :: !(Maybe (Map.Map String A.Value)) -- ^ "last_webhook" - Information about the last webhook fired for the Item.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NullableItemStatus
instance A.FromJSON NullableItemStatus where
  parseJSON = A.withObject "NullableItemStatus" $ \o ->
    NullableItemStatus
      <$> (o .:? "investments")
      <*> (o .:? "transactions")
      <*> (o .:? "last_webhook")

-- | ToJSON NullableItemStatus
instance A.ToJSON NullableItemStatus where
  toJSON NullableItemStatus {..} =
   _omitNulls
      [ "investments" .= nullableItemStatusInvestments
      , "transactions" .= nullableItemStatusTransactions
      , "last_webhook" .= nullableItemStatusLastWebhook
      ]


-- | Construct a value of type 'NullableItemStatus' (by applying it's required fields, if any)
mkNullableItemStatus
  :: NullableItemStatus
mkNullableItemStatus =
  NullableItemStatus
  { nullableItemStatusInvestments = Nothing
  , nullableItemStatusTransactions = Nothing
  , nullableItemStatusLastWebhook = Nothing
  }

-- ** NullableNumbersACH
-- | NullableNumbersACH
data NullableNumbersACH = NullableNumbersACH
  { nullableNumbersACHAccountId :: !(Text) -- ^ /Required/ "account_id" - The Plaid account ID associated with the account numbers
  , nullableNumbersACHAccount :: !(Text) -- ^ /Required/ "account" - The ACH account number for the account
  , nullableNumbersACHRouting :: !(Text) -- ^ /Required/ "routing" - The ACH routing number for the account
  , nullableNumbersACHWireRouting :: !(Maybe Text) -- ^ "wire_routing" - The wire transfer routing number for the account, if available
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NullableNumbersACH
instance A.FromJSON NullableNumbersACH where
  parseJSON = A.withObject "NullableNumbersACH" $ \o ->
    NullableNumbersACH
      <$> (o .:  "account_id")
      <*> (o .:  "account")
      <*> (o .:  "routing")
      <*> (o .:? "wire_routing")

-- | ToJSON NullableNumbersACH
instance A.ToJSON NullableNumbersACH where
  toJSON NullableNumbersACH {..} =
   _omitNulls
      [ "account_id" .= nullableNumbersACHAccountId
      , "account" .= nullableNumbersACHAccount
      , "routing" .= nullableNumbersACHRouting
      , "wire_routing" .= nullableNumbersACHWireRouting
      ]


-- | Construct a value of type 'NullableNumbersACH' (by applying it's required fields, if any)
mkNullableNumbersACH
  :: Text -- ^ 'nullableNumbersACHAccountId': The Plaid account ID associated with the account numbers
  -> Text -- ^ 'nullableNumbersACHAccount': The ACH account number for the account
  -> Text -- ^ 'nullableNumbersACHRouting': The ACH routing number for the account
  -> NullableNumbersACH
mkNullableNumbersACH nullableNumbersACHAccountId nullableNumbersACHAccount nullableNumbersACHRouting =
  NullableNumbersACH
  { nullableNumbersACHAccountId
  , nullableNumbersACHAccount
  , nullableNumbersACHRouting
  , nullableNumbersACHWireRouting = Nothing
  }

-- ** NullableNumbersBACS
-- | NullableNumbersBACS
data NullableNumbersBACS = NullableNumbersBACS
  { nullableNumbersBACSAccountId :: !(Text) -- ^ /Required/ "account_id" - The Plaid account ID associated with the account numbers
  , nullableNumbersBACSAccount :: !(Text) -- ^ /Required/ "account" - The BACS account number for the account
  , nullableNumbersBACSSortCode :: !(Text) -- ^ /Required/ "sort_code" - The BACS sort code for the account
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NullableNumbersBACS
instance A.FromJSON NullableNumbersBACS where
  parseJSON = A.withObject "NullableNumbersBACS" $ \o ->
    NullableNumbersBACS
      <$> (o .:  "account_id")
      <*> (o .:  "account")
      <*> (o .:  "sort_code")

-- | ToJSON NullableNumbersBACS
instance A.ToJSON NullableNumbersBACS where
  toJSON NullableNumbersBACS {..} =
   _omitNulls
      [ "account_id" .= nullableNumbersBACSAccountId
      , "account" .= nullableNumbersBACSAccount
      , "sort_code" .= nullableNumbersBACSSortCode
      ]


-- | Construct a value of type 'NullableNumbersBACS' (by applying it's required fields, if any)
mkNullableNumbersBACS
  :: Text -- ^ 'nullableNumbersBACSAccountId': The Plaid account ID associated with the account numbers
  -> Text -- ^ 'nullableNumbersBACSAccount': The BACS account number for the account
  -> Text -- ^ 'nullableNumbersBACSSortCode': The BACS sort code for the account
  -> NullableNumbersBACS
mkNullableNumbersBACS nullableNumbersBACSAccountId nullableNumbersBACSAccount nullableNumbersBACSSortCode =
  NullableNumbersBACS
  { nullableNumbersBACSAccountId
  , nullableNumbersBACSAccount
  , nullableNumbersBACSSortCode
  }

-- ** NullableNumbersEFT
-- | NullableNumbersEFT
data NullableNumbersEFT = NullableNumbersEFT
  { nullableNumbersEFTAccountId :: !(Text) -- ^ /Required/ "account_id" - The Plaid account ID associated with the account numbers
  , nullableNumbersEFTAccount :: !(Text) -- ^ /Required/ "account" - The EFT account number for the account
  , nullableNumbersEFTInstitution :: !(Text) -- ^ /Required/ "institution" - The EFT institution number for the account
  , nullableNumbersEFTBranch :: !(Text) -- ^ /Required/ "branch" - The EFT branch number for the account
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NullableNumbersEFT
instance A.FromJSON NullableNumbersEFT where
  parseJSON = A.withObject "NullableNumbersEFT" $ \o ->
    NullableNumbersEFT
      <$> (o .:  "account_id")
      <*> (o .:  "account")
      <*> (o .:  "institution")
      <*> (o .:  "branch")

-- | ToJSON NullableNumbersEFT
instance A.ToJSON NullableNumbersEFT where
  toJSON NullableNumbersEFT {..} =
   _omitNulls
      [ "account_id" .= nullableNumbersEFTAccountId
      , "account" .= nullableNumbersEFTAccount
      , "institution" .= nullableNumbersEFTInstitution
      , "branch" .= nullableNumbersEFTBranch
      ]


-- | Construct a value of type 'NullableNumbersEFT' (by applying it's required fields, if any)
mkNullableNumbersEFT
  :: Text -- ^ 'nullableNumbersEFTAccountId': The Plaid account ID associated with the account numbers
  -> Text -- ^ 'nullableNumbersEFTAccount': The EFT account number for the account
  -> Text -- ^ 'nullableNumbersEFTInstitution': The EFT institution number for the account
  -> Text -- ^ 'nullableNumbersEFTBranch': The EFT branch number for the account
  -> NullableNumbersEFT
mkNullableNumbersEFT nullableNumbersEFTAccountId nullableNumbersEFTAccount nullableNumbersEFTInstitution nullableNumbersEFTBranch =
  NullableNumbersEFT
  { nullableNumbersEFTAccountId
  , nullableNumbersEFTAccount
  , nullableNumbersEFTInstitution
  , nullableNumbersEFTBranch
  }

-- ** NullableNumbersInternational
-- | NullableNumbersInternational
data NullableNumbersInternational = NullableNumbersInternational
  { nullableNumbersInternationalAccountId :: !(Text) -- ^ /Required/ "account_id" - The Plaid account ID associated with the account numbers
  , nullableNumbersInternationalIban :: !(Text) -- ^ /Required/ "iban" - The International Bank Account Number (IBAN) for the account
  , nullableNumbersInternationalBic :: !(Text) -- ^ /Required/ "bic" - The Bank Identifier Code (BIC) for the account
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NullableNumbersInternational
instance A.FromJSON NullableNumbersInternational where
  parseJSON = A.withObject "NullableNumbersInternational" $ \o ->
    NullableNumbersInternational
      <$> (o .:  "account_id")
      <*> (o .:  "iban")
      <*> (o .:  "bic")

-- | ToJSON NullableNumbersInternational
instance A.ToJSON NullableNumbersInternational where
  toJSON NullableNumbersInternational {..} =
   _omitNulls
      [ "account_id" .= nullableNumbersInternationalAccountId
      , "iban" .= nullableNumbersInternationalIban
      , "bic" .= nullableNumbersInternationalBic
      ]


-- | Construct a value of type 'NullableNumbersInternational' (by applying it's required fields, if any)
mkNullableNumbersInternational
  :: Text -- ^ 'nullableNumbersInternationalAccountId': The Plaid account ID associated with the account numbers
  -> Text -- ^ 'nullableNumbersInternationalIban': The International Bank Account Number (IBAN) for the account
  -> Text -- ^ 'nullableNumbersInternationalBic': The Bank Identifier Code (BIC) for the account
  -> NullableNumbersInternational
mkNullableNumbersInternational nullableNumbersInternationalAccountId nullableNumbersInternationalIban nullableNumbersInternationalBic =
  NullableNumbersInternational
  { nullableNumbersInternationalAccountId
  , nullableNumbersInternationalIban
  , nullableNumbersInternationalBic
  }

-- ** NullableRecipientBACS
-- | NullableRecipientBACS
data NullableRecipientBACS = NullableRecipientBACS
  { nullableRecipientBACSAccount :: !(Maybe Text) -- ^ "account" - The account number of the account. Maximum of 10 characters.
  , nullableRecipientBACSSortCode :: !(Maybe Text) -- ^ "sort_code" - The 6-character sort code of the account.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NullableRecipientBACS
instance A.FromJSON NullableRecipientBACS where
  parseJSON = A.withObject "NullableRecipientBACS" $ \o ->
    NullableRecipientBACS
      <$> (o .:? "account")
      <*> (o .:? "sort_code")

-- | ToJSON NullableRecipientBACS
instance A.ToJSON NullableRecipientBACS where
  toJSON NullableRecipientBACS {..} =
   _omitNulls
      [ "account" .= nullableRecipientBACSAccount
      , "sort_code" .= nullableRecipientBACSSortCode
      ]


-- | Construct a value of type 'NullableRecipientBACS' (by applying it's required fields, if any)
mkNullableRecipientBACS
  :: NullableRecipientBACS
mkNullableRecipientBACS =
  NullableRecipientBACS
  { nullableRecipientBACSAccount = Nothing
  , nullableRecipientBACSSortCode = Nothing
  }

-- ** Numbers
-- | Numbers
-- Numbers
-- 
-- Account and bank identifier number data used to configure the test account. All values are optional.
data Numbers = Numbers
  { numbersAccount :: !(Text) -- ^ /Required/ "account" - Will be used for the account number.
  , numbersAchRouting :: !(Text) -- ^ /Required/ "ach_routing" - Must be a valid ACH routing number.
  , numbersAchWireRouting :: !(Text) -- ^ /Required/ "ach_wire_routing" - Must be a valid wire transfer routing number.
  , numbersEftInstitution :: !(Text) -- ^ /Required/ "eft_institution" - EFT institution number. Must be specified alongside &#x60;eft_branch&#x60;.
  , numbersEftBranch :: !(Text) -- ^ /Required/ "eft_branch" - EFT branch number. Must be specified alongside &#x60;eft_institution&#x60;.
  , numbersInternationalBic :: !(Text) -- ^ /Required/ "international_bic" - Bank identifier code (BIC). Must be specified alongside &#x60;international_iban&#x60;.
  , numbersInternationalIban :: !(Text) -- ^ /Required/ "international_iban" - International bank account number (IBAN). If no account number is specified via &#x60;account&#x60;, will also be used as the account number by default. Must be specified alongside &#x60;international_bic&#x60;.
  , numbersBacsSortCode :: !(Text) -- ^ /Required/ "bacs_sort_code" - BACS sort code
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Numbers
instance A.FromJSON Numbers where
  parseJSON = A.withObject "Numbers" $ \o ->
    Numbers
      <$> (o .:  "account")
      <*> (o .:  "ach_routing")
      <*> (o .:  "ach_wire_routing")
      <*> (o .:  "eft_institution")
      <*> (o .:  "eft_branch")
      <*> (o .:  "international_bic")
      <*> (o .:  "international_iban")
      <*> (o .:  "bacs_sort_code")

-- | ToJSON Numbers
instance A.ToJSON Numbers where
  toJSON Numbers {..} =
   _omitNulls
      [ "account" .= numbersAccount
      , "ach_routing" .= numbersAchRouting
      , "ach_wire_routing" .= numbersAchWireRouting
      , "eft_institution" .= numbersEftInstitution
      , "eft_branch" .= numbersEftBranch
      , "international_bic" .= numbersInternationalBic
      , "international_iban" .= numbersInternationalIban
      , "bacs_sort_code" .= numbersBacsSortCode
      ]


-- | Construct a value of type 'Numbers' (by applying it's required fields, if any)
mkNumbers
  :: Text -- ^ 'numbersAccount': Will be used for the account number.
  -> Text -- ^ 'numbersAchRouting': Must be a valid ACH routing number.
  -> Text -- ^ 'numbersAchWireRouting': Must be a valid wire transfer routing number.
  -> Text -- ^ 'numbersEftInstitution': EFT institution number. Must be specified alongside `eft_branch`.
  -> Text -- ^ 'numbersEftBranch': EFT branch number. Must be specified alongside `eft_institution`.
  -> Text -- ^ 'numbersInternationalBic': Bank identifier code (BIC). Must be specified alongside `international_iban`.
  -> Text -- ^ 'numbersInternationalIban': International bank account number (IBAN). If no account number is specified via `account`, will also be used as the account number by default. Must be specified alongside `international_bic`.
  -> Text -- ^ 'numbersBacsSortCode': BACS sort code
  -> Numbers
mkNumbers numbersAccount numbersAchRouting numbersAchWireRouting numbersEftInstitution numbersEftBranch numbersInternationalBic numbersInternationalIban numbersBacsSortCode =
  Numbers
  { numbersAccount
  , numbersAchRouting
  , numbersAchWireRouting
  , numbersEftInstitution
  , numbersEftBranch
  , numbersInternationalBic
  , numbersInternationalIban
  , numbersBacsSortCode
  }

-- ** NumbersACH
-- | NumbersACH
-- NumbersACH
-- 
-- Identifying information for transferring money to or from a US account via ACH or wire transfer.
data NumbersACH = NumbersACH
  { numbersACHAccountId :: !(Text) -- ^ /Required/ "account_id" - The Plaid account ID associated with the account numbers
  , numbersACHAccount :: !(Text) -- ^ /Required/ "account" - The ACH account number for the account
  , numbersACHRouting :: !(Text) -- ^ /Required/ "routing" - The ACH routing number for the account
  , numbersACHWireRouting :: !(Maybe Text) -- ^ "wire_routing" - The wire transfer routing number for the account, if available
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NumbersACH
instance A.FromJSON NumbersACH where
  parseJSON = A.withObject "NumbersACH" $ \o ->
    NumbersACH
      <$> (o .:  "account_id")
      <*> (o .:  "account")
      <*> (o .:  "routing")
      <*> (o .:? "wire_routing")

-- | ToJSON NumbersACH
instance A.ToJSON NumbersACH where
  toJSON NumbersACH {..} =
   _omitNulls
      [ "account_id" .= numbersACHAccountId
      , "account" .= numbersACHAccount
      , "routing" .= numbersACHRouting
      , "wire_routing" .= numbersACHWireRouting
      ]


-- | Construct a value of type 'NumbersACH' (by applying it's required fields, if any)
mkNumbersACH
  :: Text -- ^ 'numbersACHAccountId': The Plaid account ID associated with the account numbers
  -> Text -- ^ 'numbersACHAccount': The ACH account number for the account
  -> Text -- ^ 'numbersACHRouting': The ACH routing number for the account
  -> NumbersACH
mkNumbersACH numbersACHAccountId numbersACHAccount numbersACHRouting =
  NumbersACH
  { numbersACHAccountId
  , numbersACHAccount
  , numbersACHRouting
  , numbersACHWireRouting = Nothing
  }

-- ** NumbersBACS
-- | NumbersBACS
-- NumbersBACS
-- 
-- Identifying information for transferring money to or from a UK bank account via BACS.
data NumbersBACS = NumbersBACS
  { numbersBACSAccountId :: !(Text) -- ^ /Required/ "account_id" - The Plaid account ID associated with the account numbers
  , numbersBACSAccount :: !(Text) -- ^ /Required/ "account" - The BACS account number for the account
  , numbersBACSSortCode :: !(Text) -- ^ /Required/ "sort_code" - The BACS sort code for the account
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NumbersBACS
instance A.FromJSON NumbersBACS where
  parseJSON = A.withObject "NumbersBACS" $ \o ->
    NumbersBACS
      <$> (o .:  "account_id")
      <*> (o .:  "account")
      <*> (o .:  "sort_code")

-- | ToJSON NumbersBACS
instance A.ToJSON NumbersBACS where
  toJSON NumbersBACS {..} =
   _omitNulls
      [ "account_id" .= numbersBACSAccountId
      , "account" .= numbersBACSAccount
      , "sort_code" .= numbersBACSSortCode
      ]


-- | Construct a value of type 'NumbersBACS' (by applying it's required fields, if any)
mkNumbersBACS
  :: Text -- ^ 'numbersBACSAccountId': The Plaid account ID associated with the account numbers
  -> Text -- ^ 'numbersBACSAccount': The BACS account number for the account
  -> Text -- ^ 'numbersBACSSortCode': The BACS sort code for the account
  -> NumbersBACS
mkNumbersBACS numbersBACSAccountId numbersBACSAccount numbersBACSSortCode =
  NumbersBACS
  { numbersBACSAccountId
  , numbersBACSAccount
  , numbersBACSSortCode
  }

-- ** NumbersEFT
-- | NumbersEFT
-- NumbersEFT
-- 
-- Identifying information for transferring money to or from a Canadian bank account via EFT.
data NumbersEFT = NumbersEFT
  { numbersEFTAccountId :: !(Text) -- ^ /Required/ "account_id" - The Plaid account ID associated with the account numbers
  , numbersEFTAccount :: !(Text) -- ^ /Required/ "account" - The EFT account number for the account
  , numbersEFTInstitution :: !(Text) -- ^ /Required/ "institution" - The EFT institution number for the account
  , numbersEFTBranch :: !(Text) -- ^ /Required/ "branch" - The EFT branch number for the account
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NumbersEFT
instance A.FromJSON NumbersEFT where
  parseJSON = A.withObject "NumbersEFT" $ \o ->
    NumbersEFT
      <$> (o .:  "account_id")
      <*> (o .:  "account")
      <*> (o .:  "institution")
      <*> (o .:  "branch")

-- | ToJSON NumbersEFT
instance A.ToJSON NumbersEFT where
  toJSON NumbersEFT {..} =
   _omitNulls
      [ "account_id" .= numbersEFTAccountId
      , "account" .= numbersEFTAccount
      , "institution" .= numbersEFTInstitution
      , "branch" .= numbersEFTBranch
      ]


-- | Construct a value of type 'NumbersEFT' (by applying it's required fields, if any)
mkNumbersEFT
  :: Text -- ^ 'numbersEFTAccountId': The Plaid account ID associated with the account numbers
  -> Text -- ^ 'numbersEFTAccount': The EFT account number for the account
  -> Text -- ^ 'numbersEFTInstitution': The EFT institution number for the account
  -> Text -- ^ 'numbersEFTBranch': The EFT branch number for the account
  -> NumbersEFT
mkNumbersEFT numbersEFTAccountId numbersEFTAccount numbersEFTInstitution numbersEFTBranch =
  NumbersEFT
  { numbersEFTAccountId
  , numbersEFTAccount
  , numbersEFTInstitution
  , numbersEFTBranch
  }

-- ** NumbersInternationals
-- | NumbersInternationals
-- NumbersInternationals
-- 
-- Identifying information for transferring money to or from an international bank account via wire transfer.
data NumbersInternationals = NumbersInternationals
  { numbersInternationalsAccountId :: !(Text) -- ^ /Required/ "account_id" - The Plaid account ID associated with the account numbers
  , numbersInternationalsIban :: !(Text) -- ^ /Required/ "iban" - The International Bank Account Number (IBAN) for the account
  , numbersInternationalsBic :: !(Text) -- ^ /Required/ "bic" - The Bank Identifier Code (BIC) for the account
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NumbersInternationals
instance A.FromJSON NumbersInternationals where
  parseJSON = A.withObject "NumbersInternationals" $ \o ->
    NumbersInternationals
      <$> (o .:  "account_id")
      <*> (o .:  "iban")
      <*> (o .:  "bic")

-- | ToJSON NumbersInternationals
instance A.ToJSON NumbersInternationals where
  toJSON NumbersInternationals {..} =
   _omitNulls
      [ "account_id" .= numbersInternationalsAccountId
      , "iban" .= numbersInternationalsIban
      , "bic" .= numbersInternationalsBic
      ]


-- | Construct a value of type 'NumbersInternationals' (by applying it's required fields, if any)
mkNumbersInternationals
  :: Text -- ^ 'numbersInternationalsAccountId': The Plaid account ID associated with the account numbers
  -> Text -- ^ 'numbersInternationalsIban': The International Bank Account Number (IBAN) for the account
  -> Text -- ^ 'numbersInternationalsBic': The Bank Identifier Code (BIC) for the account
  -> NumbersInternationals
mkNumbersInternationals numbersInternationalsAccountId numbersInternationalsIban numbersInternationalsBic =
  NumbersInternationals
  { numbersInternationalsAccountId
  , numbersInternationalsIban
  , numbersInternationalsBic
  }

-- ** OverrideAccounts
-- | OverrideAccounts
-- OverrideAccounts
-- 
-- Data to use to set values of test accounts. Some values cannot be specified in the schema and will instead will be calculated from other test data in order to achieve more consistent, realistic test data.
data OverrideAccounts = OverrideAccounts
  { overrideAccountsType :: !(AccountType) -- ^ /Required/ "type"
  , overrideAccountsSubtype :: !(AccountSubtype) -- ^ /Required/ "subtype"
  , overrideAccountsStartingBalance :: !(Double) -- ^ /Required/ "starting_balance" - If provided, the account will start with this amount as the current balance. 
  , overrideAccountsForceAvailableBalance :: !(Double) -- ^ /Required/ "force_available_balance" - If provided, the account will always have this amount as its  available balance, regardless of current balance or changes in transactions over time.
  , overrideAccountsCurrency :: !(Text) -- ^ /Required/ "currency" - ISO-4217 currency code. If provided, the account will be denominated in the given currency. Transactions will also be in this currency by default.
  , overrideAccountsMeta :: !(Meta) -- ^ /Required/ "meta"
  , overrideAccountsNumbers :: !(Numbers) -- ^ /Required/ "numbers"
  , overrideAccountsTransactions :: !([TransactionOverride]) -- ^ /Required/ "transactions" - Specify the list of transactions on the account.
  , overrideAccountsIdentity :: !(OwnerOverride) -- ^ /Required/ "identity"
  , overrideAccountsLiability :: !(LiabilityOverride) -- ^ /Required/ "liability"
  , overrideAccountsInflowModel :: !(InflowModel) -- ^ /Required/ "inflow_model"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OverrideAccounts
instance A.FromJSON OverrideAccounts where
  parseJSON = A.withObject "OverrideAccounts" $ \o ->
    OverrideAccounts
      <$> (o .:  "type")
      <*> (o .:  "subtype")
      <*> (o .:  "starting_balance")
      <*> (o .:  "force_available_balance")
      <*> (o .:  "currency")
      <*> (o .:  "meta")
      <*> (o .:  "numbers")
      <*> (o .:  "transactions")
      <*> (o .:  "identity")
      <*> (o .:  "liability")
      <*> (o .:  "inflow_model")

-- | ToJSON OverrideAccounts
instance A.ToJSON OverrideAccounts where
  toJSON OverrideAccounts {..} =
   _omitNulls
      [ "type" .= overrideAccountsType
      , "subtype" .= overrideAccountsSubtype
      , "starting_balance" .= overrideAccountsStartingBalance
      , "force_available_balance" .= overrideAccountsForceAvailableBalance
      , "currency" .= overrideAccountsCurrency
      , "meta" .= overrideAccountsMeta
      , "numbers" .= overrideAccountsNumbers
      , "transactions" .= overrideAccountsTransactions
      , "identity" .= overrideAccountsIdentity
      , "liability" .= overrideAccountsLiability
      , "inflow_model" .= overrideAccountsInflowModel
      ]


-- | Construct a value of type 'OverrideAccounts' (by applying it's required fields, if any)
mkOverrideAccounts
  :: AccountType -- ^ 'overrideAccountsType' 
  -> AccountSubtype -- ^ 'overrideAccountsSubtype' 
  -> Double -- ^ 'overrideAccountsStartingBalance': If provided, the account will start with this amount as the current balance. 
  -> Double -- ^ 'overrideAccountsForceAvailableBalance': If provided, the account will always have this amount as its  available balance, regardless of current balance or changes in transactions over time.
  -> Text -- ^ 'overrideAccountsCurrency': ISO-4217 currency code. If provided, the account will be denominated in the given currency. Transactions will also be in this currency by default.
  -> Meta -- ^ 'overrideAccountsMeta' 
  -> Numbers -- ^ 'overrideAccountsNumbers' 
  -> [TransactionOverride] -- ^ 'overrideAccountsTransactions': Specify the list of transactions on the account.
  -> OwnerOverride -- ^ 'overrideAccountsIdentity' 
  -> LiabilityOverride -- ^ 'overrideAccountsLiability' 
  -> InflowModel -- ^ 'overrideAccountsInflowModel' 
  -> OverrideAccounts
mkOverrideAccounts overrideAccountsType overrideAccountsSubtype overrideAccountsStartingBalance overrideAccountsForceAvailableBalance overrideAccountsCurrency overrideAccountsMeta overrideAccountsNumbers overrideAccountsTransactions overrideAccountsIdentity overrideAccountsLiability overrideAccountsInflowModel =
  OverrideAccounts
  { overrideAccountsType
  , overrideAccountsSubtype
  , overrideAccountsStartingBalance
  , overrideAccountsForceAvailableBalance
  , overrideAccountsCurrency
  , overrideAccountsMeta
  , overrideAccountsNumbers
  , overrideAccountsTransactions
  , overrideAccountsIdentity
  , overrideAccountsLiability
  , overrideAccountsInflowModel
  }

-- ** Owner
-- | Owner
-- Owner
-- 
-- Data returned from the financial institution about the owner or owners of an account. Only the `names` array must be non-empty.
data Owner = Owner
  { ownerNames :: !([Text]) -- ^ /Required/ "names" - A list of names associated with the account by the financial institution. These should always be the names of individuals, even for business accounts. If the name of a business is reported, please contact Plaid Support.  In the case of a joint account, the names of all account holders will be reported.  If an Item contains multiple accounts with different owner names, some institutions will report all names associated with the Item in each account&#39;s &#x60;names&#x60; array.
  , ownerPhoneNumbers :: !([PhoneNumber]) -- ^ /Required/ "phone_numbers" - A list of phone numbers associated with the account by the financial institution. May be an empty array if no relevant information is returned from the financial institution.
  , ownerEmails :: !([Email]) -- ^ /Required/ "emails" - A list of email addresses associated with the account by the financial institution. May be an empty array if no relevant information is returned from the financial institution.
  , ownerAddresses :: !([Address]) -- ^ /Required/ "addresses" - Data about the various addresses associated with the account by the financial institution. May be an empty array if no relevant information is returned from the financial institution.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Owner
instance A.FromJSON Owner where
  parseJSON = A.withObject "Owner" $ \o ->
    Owner
      <$> (o .:  "names")
      <*> (o .:  "phone_numbers")
      <*> (o .:  "emails")
      <*> (o .:  "addresses")

-- | ToJSON Owner
instance A.ToJSON Owner where
  toJSON Owner {..} =
   _omitNulls
      [ "names" .= ownerNames
      , "phone_numbers" .= ownerPhoneNumbers
      , "emails" .= ownerEmails
      , "addresses" .= ownerAddresses
      ]


-- | Construct a value of type 'Owner' (by applying it's required fields, if any)
mkOwner
  :: [Text] -- ^ 'ownerNames': A list of names associated with the account by the financial institution. These should always be the names of individuals, even for business accounts. If the name of a business is reported, please contact Plaid Support.  In the case of a joint account, the names of all account holders will be reported.  If an Item contains multiple accounts with different owner names, some institutions will report all names associated with the Item in each account's `names` array.
  -> [PhoneNumber] -- ^ 'ownerPhoneNumbers': A list of phone numbers associated with the account by the financial institution. May be an empty array if no relevant information is returned from the financial institution.
  -> [Email] -- ^ 'ownerEmails': A list of email addresses associated with the account by the financial institution. May be an empty array if no relevant information is returned from the financial institution.
  -> [Address] -- ^ 'ownerAddresses': Data about the various addresses associated with the account by the financial institution. May be an empty array if no relevant information is returned from the financial institution.
  -> Owner
mkOwner ownerNames ownerPhoneNumbers ownerEmails ownerAddresses =
  Owner
  { ownerNames
  , ownerPhoneNumbers
  , ownerEmails
  , ownerAddresses
  }

-- ** OwnerOverride
-- | OwnerOverride
-- OwnerOverride
-- 
-- Data about the owner or owners of an account. Any fields not specified will be filled in with default Sandbox information.
data OwnerOverride = OwnerOverride
  { ownerOverrideNames :: !([Text]) -- ^ /Required/ "names" - A list of names associated with the account by the financial institution. These should always be the names of individuals, even for business accounts. Note that the same name data will be used for all accounts associated with an Item.
  , ownerOverridePhoneNumbers :: !([PhoneNumber]) -- ^ /Required/ "phone_numbers" - A list of phone numbers associated with the account.
  , ownerOverrideEmails :: !([Email]) -- ^ /Required/ "emails" - A list of email addresses associated with the account.
  , ownerOverrideAddresses :: !([Address]) -- ^ /Required/ "addresses" - Data about the various addresses associated with the account.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OwnerOverride
instance A.FromJSON OwnerOverride where
  parseJSON = A.withObject "OwnerOverride" $ \o ->
    OwnerOverride
      <$> (o .:  "names")
      <*> (o .:  "phone_numbers")
      <*> (o .:  "emails")
      <*> (o .:  "addresses")

-- | ToJSON OwnerOverride
instance A.ToJSON OwnerOverride where
  toJSON OwnerOverride {..} =
   _omitNulls
      [ "names" .= ownerOverrideNames
      , "phone_numbers" .= ownerOverridePhoneNumbers
      , "emails" .= ownerOverrideEmails
      , "addresses" .= ownerOverrideAddresses
      ]


-- | Construct a value of type 'OwnerOverride' (by applying it's required fields, if any)
mkOwnerOverride
  :: [Text] -- ^ 'ownerOverrideNames': A list of names associated with the account by the financial institution. These should always be the names of individuals, even for business accounts. Note that the same name data will be used for all accounts associated with an Item.
  -> [PhoneNumber] -- ^ 'ownerOverridePhoneNumbers': A list of phone numbers associated with the account.
  -> [Email] -- ^ 'ownerOverrideEmails': A list of email addresses associated with the account.
  -> [Address] -- ^ 'ownerOverrideAddresses': Data about the various addresses associated with the account.
  -> OwnerOverride
mkOwnerOverride ownerOverrideNames ownerOverridePhoneNumbers ownerOverrideEmails ownerOverrideAddresses =
  OwnerOverride
  { ownerOverrideNames
  , ownerOverridePhoneNumbers
  , ownerOverrideEmails
  , ownerOverrideAddresses
  }

-- ** PSLFStatus
-- | PSLFStatus
-- PSLFStatus
-- 
-- Information about the student's eligibility in the Public Service Loan Forgiveness program. This is only returned if the institution is Fedloan (`ins_116527`). 
data PSLFStatus = PSLFStatus
  { pSLFStatusEstimatedEligibilityDate :: !(Maybe Text) -- ^ "estimated_eligibility_date" - The estimated date borrower will have completed 120 qualifying monthly payments. Returned in ISO 8601 format (YYYY-MM-DD).
  , pSLFStatusPaymentsMade :: !(Maybe Double) -- ^ "payments_made" - The number of qualifying payments that have been made.
  , pSLFStatusPaymentsRemaining :: !(Maybe Double) -- ^ "payments_remaining" - The number of qualifying payments remaining.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PSLFStatus
instance A.FromJSON PSLFStatus where
  parseJSON = A.withObject "PSLFStatus" $ \o ->
    PSLFStatus
      <$> (o .:? "estimated_eligibility_date")
      <*> (o .:? "payments_made")
      <*> (o .:? "payments_remaining")

-- | ToJSON PSLFStatus
instance A.ToJSON PSLFStatus where
  toJSON PSLFStatus {..} =
   _omitNulls
      [ "estimated_eligibility_date" .= pSLFStatusEstimatedEligibilityDate
      , "payments_made" .= pSLFStatusPaymentsMade
      , "payments_remaining" .= pSLFStatusPaymentsRemaining
      ]


-- | Construct a value of type 'PSLFStatus' (by applying it's required fields, if any)
mkPSLFStatus
  :: PSLFStatus
mkPSLFStatus =
  PSLFStatus
  { pSLFStatusEstimatedEligibilityDate = Nothing
  , pSLFStatusPaymentsMade = Nothing
  , pSLFStatusPaymentsRemaining = Nothing
  }

-- ** PayFrequency
-- | PayFrequency
-- PayFrequency
-- 
data PayFrequency = PayFrequency
  { payFrequencyValue :: !(E'Value) -- ^ /Required/ "value" - The frequency of the pay period.
  , payFrequencyVerificationStatus :: !(VerificationStatus) -- ^ /Required/ "verification_status"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PayFrequency
instance A.FromJSON PayFrequency where
  parseJSON = A.withObject "PayFrequency" $ \o ->
    PayFrequency
      <$> (o .:  "value")
      <*> (o .:  "verification_status")

-- | ToJSON PayFrequency
instance A.ToJSON PayFrequency where
  toJSON PayFrequency {..} =
   _omitNulls
      [ "value" .= payFrequencyValue
      , "verification_status" .= payFrequencyVerificationStatus
      ]


-- | Construct a value of type 'PayFrequency' (by applying it's required fields, if any)
mkPayFrequency
  :: E'Value -- ^ 'payFrequencyValue': The frequency of the pay period.
  -> VerificationStatus -- ^ 'payFrequencyVerificationStatus' 
  -> PayFrequency
mkPayFrequency payFrequencyValue payFrequencyVerificationStatus =
  PayFrequency
  { payFrequencyValue
  , payFrequencyVerificationStatus
  }

-- ** PayPeriodDetails
-- | PayPeriodDetails
-- PayPeriodDetails
-- 
-- Details about the pay period.
data PayPeriodDetails = PayPeriodDetails
  { payPeriodDetailsStartDate :: !(Maybe Text) -- ^ "start_date" - The pay period start date, in ISO 8601 format: \&quot;yyyy-mm-dd\&quot;.
  , payPeriodDetailsEndDate :: !(Maybe Text) -- ^ "end_date" - The pay period end date, in ISO 8601 format: \&quot;yyyy-mm-dd\&quot;.
  , payPeriodDetailsPayDay :: !(Maybe Text) -- ^ "pay_day" - The date on which the paystub was issued, in ISO 8601 format (\&quot;yyyy-mm-dd\&quot;).
  , payPeriodDetailsGrossEarnings :: !(Maybe Double) -- ^ "gross_earnings" - Total earnings before tax.
  , payPeriodDetailsCheckAmount :: !(Maybe Double) -- ^ "check_amount" - The net amount of the paycheck.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PayPeriodDetails
instance A.FromJSON PayPeriodDetails where
  parseJSON = A.withObject "PayPeriodDetails" $ \o ->
    PayPeriodDetails
      <$> (o .:? "start_date")
      <*> (o .:? "end_date")
      <*> (o .:? "pay_day")
      <*> (o .:? "gross_earnings")
      <*> (o .:? "check_amount")

-- | ToJSON PayPeriodDetails
instance A.ToJSON PayPeriodDetails where
  toJSON PayPeriodDetails {..} =
   _omitNulls
      [ "start_date" .= payPeriodDetailsStartDate
      , "end_date" .= payPeriodDetailsEndDate
      , "pay_day" .= payPeriodDetailsPayDay
      , "gross_earnings" .= payPeriodDetailsGrossEarnings
      , "check_amount" .= payPeriodDetailsCheckAmount
      ]


-- | Construct a value of type 'PayPeriodDetails' (by applying it's required fields, if any)
mkPayPeriodDetails
  :: PayPeriodDetails
mkPayPeriodDetails =
  PayPeriodDetails
  { payPeriodDetailsStartDate = Nothing
  , payPeriodDetailsEndDate = Nothing
  , payPeriodDetailsPayDay = Nothing
  , payPeriodDetailsGrossEarnings = Nothing
  , payPeriodDetailsCheckAmount = Nothing
  }

-- ** PaymentAmount
-- | PaymentAmount
-- PaymentAmount
-- 
-- The amount and currency of a payment
data PaymentAmount = PaymentAmount
  { paymentAmountCurrency :: !(Text) -- ^ /Required/ "currency" - The ISO-4217 currency code of the payment amount
  , paymentAmountValue :: !(Double) -- ^ /Required/ "value" - The payment amount
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PaymentAmount
instance A.FromJSON PaymentAmount where
  parseJSON = A.withObject "PaymentAmount" $ \o ->
    PaymentAmount
      <$> (o .:  "currency")
      <*> (o .:  "value")

-- | ToJSON PaymentAmount
instance A.ToJSON PaymentAmount where
  toJSON PaymentAmount {..} =
   _omitNulls
      [ "currency" .= paymentAmountCurrency
      , "value" .= paymentAmountValue
      ]


-- | Construct a value of type 'PaymentAmount' (by applying it's required fields, if any)
mkPaymentAmount
  :: Text -- ^ 'paymentAmountCurrency': The ISO-4217 currency code of the payment amount
  -> Double -- ^ 'paymentAmountValue': The payment amount
  -> PaymentAmount
mkPaymentAmount paymentAmountCurrency paymentAmountValue =
  PaymentAmount
  { paymentAmountCurrency
  , paymentAmountValue
  }

-- ** PaymentInitiationAddress
-- | PaymentInitiationAddress
-- PaymentInitiationAddress
-- 
-- The optional address of the payment recipient. This object is not currently required to make payments from UK institutions and should not be populated, though may be necessary for future European expansion.
data PaymentInitiationAddress = PaymentInitiationAddress
  { paymentInitiationAddressStreet :: !(Maybe [Text]) -- ^ "street" - An array of length 1-2 representing the street address where the recipient is located. Maximum of 70 characters.
  , paymentInitiationAddressCity :: !(Maybe Text) -- ^ "city" - The city where the recipient is located. Maximum of 35 characters.
  , paymentInitiationAddressPostalCode :: !(Maybe Text) -- ^ "postal_code" - The postal code where the recipient is located. Maximum of 16 characters.
  , paymentInitiationAddressCountry :: !(Maybe Text) -- ^ "country" - The ISO 3166-1 alpha-2 country code where the recipient is located.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PaymentInitiationAddress
instance A.FromJSON PaymentInitiationAddress where
  parseJSON = A.withObject "PaymentInitiationAddress" $ \o ->
    PaymentInitiationAddress
      <$> (o .:? "street")
      <*> (o .:? "city")
      <*> (o .:? "postal_code")
      <*> (o .:? "country")

-- | ToJSON PaymentInitiationAddress
instance A.ToJSON PaymentInitiationAddress where
  toJSON PaymentInitiationAddress {..} =
   _omitNulls
      [ "street" .= paymentInitiationAddressStreet
      , "city" .= paymentInitiationAddressCity
      , "postal_code" .= paymentInitiationAddressPostalCode
      , "country" .= paymentInitiationAddressCountry
      ]


-- | Construct a value of type 'PaymentInitiationAddress' (by applying it's required fields, if any)
mkPaymentInitiationAddress
  :: PaymentInitiationAddress
mkPaymentInitiationAddress =
  PaymentInitiationAddress
  { paymentInitiationAddressStreet = Nothing
  , paymentInitiationAddressCity = Nothing
  , paymentInitiationAddressPostalCode = Nothing
  , paymentInitiationAddressCountry = Nothing
  }

-- ** PaymentInitiationPaymentCreateRequest
-- | PaymentInitiationPaymentCreateRequest
-- PaymentInitiationPaymentCreateRequest defines the request schema for `/payment_initiation/payment/create`
data PaymentInitiationPaymentCreateRequest = PaymentInitiationPaymentCreateRequest
  { paymentInitiationPaymentCreateRequestClientId :: !(Maybe Text) -- ^ "client_id" - Your Plaid API &#x60;client_id&#x60;.
  , paymentInitiationPaymentCreateRequestSecret :: !(Maybe Text) -- ^ "secret" - Your Plaid API &#x60;secret&#x60;.
  , paymentInitiationPaymentCreateRequestRecipientId :: !(Text) -- ^ /Required/ "recipient_id" - The ID of the recipient the payment is for.
  , paymentInitiationPaymentCreateRequestReference :: !(Text) -- ^ /Required/ "reference" - A reference for the payment. This must be an alphanumeric string with at most 18 characters and must not contain any special characters (since not all institutions support them).
  , paymentInitiationPaymentCreateRequestAmount :: !(Amount) -- ^ /Required/ "amount"
  , paymentInitiationPaymentCreateRequestSchedule :: !(Maybe ExternalPaymentSchedule) -- ^ "schedule"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PaymentInitiationPaymentCreateRequest
instance A.FromJSON PaymentInitiationPaymentCreateRequest where
  parseJSON = A.withObject "PaymentInitiationPaymentCreateRequest" $ \o ->
    PaymentInitiationPaymentCreateRequest
      <$> (o .:? "client_id")
      <*> (o .:? "secret")
      <*> (o .:  "recipient_id")
      <*> (o .:  "reference")
      <*> (o .:  "amount")
      <*> (o .:? "schedule")

-- | ToJSON PaymentInitiationPaymentCreateRequest
instance A.ToJSON PaymentInitiationPaymentCreateRequest where
  toJSON PaymentInitiationPaymentCreateRequest {..} =
   _omitNulls
      [ "client_id" .= paymentInitiationPaymentCreateRequestClientId
      , "secret" .= paymentInitiationPaymentCreateRequestSecret
      , "recipient_id" .= paymentInitiationPaymentCreateRequestRecipientId
      , "reference" .= paymentInitiationPaymentCreateRequestReference
      , "amount" .= paymentInitiationPaymentCreateRequestAmount
      , "schedule" .= paymentInitiationPaymentCreateRequestSchedule
      ]


-- | Construct a value of type 'PaymentInitiationPaymentCreateRequest' (by applying it's required fields, if any)
mkPaymentInitiationPaymentCreateRequest
  :: Text -- ^ 'paymentInitiationPaymentCreateRequestRecipientId': The ID of the recipient the payment is for.
  -> Text -- ^ 'paymentInitiationPaymentCreateRequestReference': A reference for the payment. This must be an alphanumeric string with at most 18 characters and must not contain any special characters (since not all institutions support them).
  -> Amount -- ^ 'paymentInitiationPaymentCreateRequestAmount' 
  -> PaymentInitiationPaymentCreateRequest
mkPaymentInitiationPaymentCreateRequest paymentInitiationPaymentCreateRequestRecipientId paymentInitiationPaymentCreateRequestReference paymentInitiationPaymentCreateRequestAmount =
  PaymentInitiationPaymentCreateRequest
  { paymentInitiationPaymentCreateRequestClientId = Nothing
  , paymentInitiationPaymentCreateRequestSecret = Nothing
  , paymentInitiationPaymentCreateRequestRecipientId
  , paymentInitiationPaymentCreateRequestReference
  , paymentInitiationPaymentCreateRequestAmount
  , paymentInitiationPaymentCreateRequestSchedule = Nothing
  }

-- ** PaymentInitiationPaymentCreateResponse
-- | PaymentInitiationPaymentCreateResponse
-- PaymentInitiationPaymentCreateResponse defines the response schema for `/payment_initiation/payment/create`
data PaymentInitiationPaymentCreateResponse = PaymentInitiationPaymentCreateResponse
  { paymentInitiationPaymentCreateResponsePaymentId :: !(Text) -- ^ /Required/ "payment_id" - A unique ID identifying the payment
  , paymentInitiationPaymentCreateResponseStatus :: !(Text) -- ^ /Required/ "status" - For a payment returned by this endpoint, there is only one possible value:  &#x60;PAYMENT_STATUS_INPUT_NEEDED&#x60;: The initial phase of the payment
  , paymentInitiationPaymentCreateResponseRequestId :: !(Text) -- ^ /Required/ "request_id" - A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PaymentInitiationPaymentCreateResponse
instance A.FromJSON PaymentInitiationPaymentCreateResponse where
  parseJSON = A.withObject "PaymentInitiationPaymentCreateResponse" $ \o ->
    PaymentInitiationPaymentCreateResponse
      <$> (o .:  "payment_id")
      <*> (o .:  "status")
      <*> (o .:  "request_id")

-- | ToJSON PaymentInitiationPaymentCreateResponse
instance A.ToJSON PaymentInitiationPaymentCreateResponse where
  toJSON PaymentInitiationPaymentCreateResponse {..} =
   _omitNulls
      [ "payment_id" .= paymentInitiationPaymentCreateResponsePaymentId
      , "status" .= paymentInitiationPaymentCreateResponseStatus
      , "request_id" .= paymentInitiationPaymentCreateResponseRequestId
      ]


-- | Construct a value of type 'PaymentInitiationPaymentCreateResponse' (by applying it's required fields, if any)
mkPaymentInitiationPaymentCreateResponse
  :: Text -- ^ 'paymentInitiationPaymentCreateResponsePaymentId': A unique ID identifying the payment
  -> Text -- ^ 'paymentInitiationPaymentCreateResponseStatus': For a payment returned by this endpoint, there is only one possible value:  `PAYMENT_STATUS_INPUT_NEEDED`: The initial phase of the payment
  -> Text -- ^ 'paymentInitiationPaymentCreateResponseRequestId': A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  -> PaymentInitiationPaymentCreateResponse
mkPaymentInitiationPaymentCreateResponse paymentInitiationPaymentCreateResponsePaymentId paymentInitiationPaymentCreateResponseStatus paymentInitiationPaymentCreateResponseRequestId =
  PaymentInitiationPaymentCreateResponse
  { paymentInitiationPaymentCreateResponsePaymentId
  , paymentInitiationPaymentCreateResponseStatus
  , paymentInitiationPaymentCreateResponseRequestId
  }

-- ** PaymentInitiationPaymentGetRequest
-- | PaymentInitiationPaymentGetRequest
-- PaymentInitiationPaymentGetRequest defines the request schema for `/payment_initiation/payment/get`
data PaymentInitiationPaymentGetRequest = PaymentInitiationPaymentGetRequest
  { paymentInitiationPaymentGetRequestClientId :: !(Maybe Text) -- ^ "client_id" - Your Plaid API &#x60;client_id&#x60;.
  , paymentInitiationPaymentGetRequestSecret :: !(Maybe Text) -- ^ "secret" - Your Plaid API &#x60;secret&#x60;.
  , paymentInitiationPaymentGetRequestPaymentId :: !(Text) -- ^ /Required/ "payment_id" - The &#x60;payment_id&#x60; returned from &#x60;/payment_initiation/payment/create&#x60;.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PaymentInitiationPaymentGetRequest
instance A.FromJSON PaymentInitiationPaymentGetRequest where
  parseJSON = A.withObject "PaymentInitiationPaymentGetRequest" $ \o ->
    PaymentInitiationPaymentGetRequest
      <$> (o .:? "client_id")
      <*> (o .:? "secret")
      <*> (o .:  "payment_id")

-- | ToJSON PaymentInitiationPaymentGetRequest
instance A.ToJSON PaymentInitiationPaymentGetRequest where
  toJSON PaymentInitiationPaymentGetRequest {..} =
   _omitNulls
      [ "client_id" .= paymentInitiationPaymentGetRequestClientId
      , "secret" .= paymentInitiationPaymentGetRequestSecret
      , "payment_id" .= paymentInitiationPaymentGetRequestPaymentId
      ]


-- | Construct a value of type 'PaymentInitiationPaymentGetRequest' (by applying it's required fields, if any)
mkPaymentInitiationPaymentGetRequest
  :: Text -- ^ 'paymentInitiationPaymentGetRequestPaymentId': The `payment_id` returned from `/payment_initiation/payment/create`.
  -> PaymentInitiationPaymentGetRequest
mkPaymentInitiationPaymentGetRequest paymentInitiationPaymentGetRequestPaymentId =
  PaymentInitiationPaymentGetRequest
  { paymentInitiationPaymentGetRequestClientId = Nothing
  , paymentInitiationPaymentGetRequestSecret = Nothing
  , paymentInitiationPaymentGetRequestPaymentId
  }

-- ** PaymentInitiationPaymentGetResponse
-- | PaymentInitiationPaymentGetResponse
-- PaymentInitiationPaymentGetResponse defines the response schema for `/payment_initation/payment/get`
data PaymentInitiationPaymentGetResponse = PaymentInitiationPaymentGetResponse
  { paymentInitiationPaymentGetResponsePaymentId :: !(Text) -- ^ /Required/ "payment_id" - The ID of the payment. Like all Plaid identifiers, the &#x60;payment_id&#x60; is case sensitive.
  , paymentInitiationPaymentGetResponseRequestId :: !(Maybe Text) -- ^ "request_id" - A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  , paymentInitiationPaymentGetResponseAmount :: !(PaymentAmount) -- ^ /Required/ "amount"
  , paymentInitiationPaymentGetResponseStatus :: !(E'Status) -- ^ /Required/ "status" - The status of the payment.  &#x60;PAYMENT_STATUS_INPUT_NEEDED&#x60;: This is the initial state of all payments. It indicates that the payment is waiting on user input to continue processing. A payment may re-enter this state later on if further input is needed.  &#x60;PAYMENT_STATUS_PROCESSING&#x60;: The payment is currently being processed. The payment will automatically exit this state when processing is complete.  &#x60;PAYMENT_STATUS_INITIATED&#x60;: The payment has been successfully initiated and is considered complete.  &#x60;PAYMENT_STATUS_COMPLETED&#x60;: Indicates that the standing order has been successfully established. This state is only used for standing orders.  &#x60;PAYMENT_STATUS_INSUFFICIENT_FUNDS&#x60;: The payment has failed due to insufficient funds.  &#x60;PAYMENT_STATUS_FAILED&#x60;: The payment has failed to be initiated. This error is retryable once the root cause is resolved.  &#x60;PAYMENT_STATUS_BLOCKED&#x60;: The payment has been blocked. This is a retryable error.  &#x60;PAYMENT_STATUS_UNKNOWN&#x60;: The payment status is unknown.
  , paymentInitiationPaymentGetResponseRecipientId :: !(Text) -- ^ /Required/ "recipient_id" - The ID of the recipient
  , paymentInitiationPaymentGetResponseReference :: !(Text) -- ^ /Required/ "reference" - A reference for the payment.
  , paymentInitiationPaymentGetResponseAdjustedReference :: !(Maybe Text) -- ^ "adjusted_reference" - The value of the reference sent to the bank after adjustment to pass bank validation rules.
  , paymentInitiationPaymentGetResponseLastStatusUpdate :: !(Text) -- ^ /Required/ "last_status_update" - The date and time of the last time the &#x60;status&#x60; was updated, in IS0 8601 format
  , paymentInitiationPaymentGetResponseSchedule :: !(Maybe ExternalPaymentScheduleGet) -- ^ "schedule"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PaymentInitiationPaymentGetResponse
instance A.FromJSON PaymentInitiationPaymentGetResponse where
  parseJSON = A.withObject "PaymentInitiationPaymentGetResponse" $ \o ->
    PaymentInitiationPaymentGetResponse
      <$> (o .:  "payment_id")
      <*> (o .:? "request_id")
      <*> (o .:  "amount")
      <*> (o .:  "status")
      <*> (o .:  "recipient_id")
      <*> (o .:  "reference")
      <*> (o .:? "adjusted_reference")
      <*> (o .:  "last_status_update")
      <*> (o .:? "schedule")

-- | ToJSON PaymentInitiationPaymentGetResponse
instance A.ToJSON PaymentInitiationPaymentGetResponse where
  toJSON PaymentInitiationPaymentGetResponse {..} =
   _omitNulls
      [ "payment_id" .= paymentInitiationPaymentGetResponsePaymentId
      , "request_id" .= paymentInitiationPaymentGetResponseRequestId
      , "amount" .= paymentInitiationPaymentGetResponseAmount
      , "status" .= paymentInitiationPaymentGetResponseStatus
      , "recipient_id" .= paymentInitiationPaymentGetResponseRecipientId
      , "reference" .= paymentInitiationPaymentGetResponseReference
      , "adjusted_reference" .= paymentInitiationPaymentGetResponseAdjustedReference
      , "last_status_update" .= paymentInitiationPaymentGetResponseLastStatusUpdate
      , "schedule" .= paymentInitiationPaymentGetResponseSchedule
      ]


-- | Construct a value of type 'PaymentInitiationPaymentGetResponse' (by applying it's required fields, if any)
mkPaymentInitiationPaymentGetResponse
  :: Text -- ^ 'paymentInitiationPaymentGetResponsePaymentId': The ID of the payment. Like all Plaid identifiers, the `payment_id` is case sensitive.
  -> PaymentAmount -- ^ 'paymentInitiationPaymentGetResponseAmount' 
  -> E'Status -- ^ 'paymentInitiationPaymentGetResponseStatus': The status of the payment.  `PAYMENT_STATUS_INPUT_NEEDED`: This is the initial state of all payments. It indicates that the payment is waiting on user input to continue processing. A payment may re-enter this state later on if further input is needed.  `PAYMENT_STATUS_PROCESSING`: The payment is currently being processed. The payment will automatically exit this state when processing is complete.  `PAYMENT_STATUS_INITIATED`: The payment has been successfully initiated and is considered complete.  `PAYMENT_STATUS_COMPLETED`: Indicates that the standing order has been successfully established. This state is only used for standing orders.  `PAYMENT_STATUS_INSUFFICIENT_FUNDS`: The payment has failed due to insufficient funds.  `PAYMENT_STATUS_FAILED`: The payment has failed to be initiated. This error is retryable once the root cause is resolved.  `PAYMENT_STATUS_BLOCKED`: The payment has been blocked. This is a retryable error.  `PAYMENT_STATUS_UNKNOWN`: The payment status is unknown.
  -> Text -- ^ 'paymentInitiationPaymentGetResponseRecipientId': The ID of the recipient
  -> Text -- ^ 'paymentInitiationPaymentGetResponseReference': A reference for the payment.
  -> Text -- ^ 'paymentInitiationPaymentGetResponseLastStatusUpdate': The date and time of the last time the `status` was updated, in IS0 8601 format
  -> PaymentInitiationPaymentGetResponse
mkPaymentInitiationPaymentGetResponse paymentInitiationPaymentGetResponsePaymentId paymentInitiationPaymentGetResponseAmount paymentInitiationPaymentGetResponseStatus paymentInitiationPaymentGetResponseRecipientId paymentInitiationPaymentGetResponseReference paymentInitiationPaymentGetResponseLastStatusUpdate =
  PaymentInitiationPaymentGetResponse
  { paymentInitiationPaymentGetResponsePaymentId
  , paymentInitiationPaymentGetResponseRequestId = Nothing
  , paymentInitiationPaymentGetResponseAmount
  , paymentInitiationPaymentGetResponseStatus
  , paymentInitiationPaymentGetResponseRecipientId
  , paymentInitiationPaymentGetResponseReference
  , paymentInitiationPaymentGetResponseAdjustedReference = Nothing
  , paymentInitiationPaymentGetResponseLastStatusUpdate
  , paymentInitiationPaymentGetResponseSchedule = Nothing
  }

-- ** PaymentInitiationPaymentListRequest
-- | PaymentInitiationPaymentListRequest
-- PaymentInitiationPaymentListRequest defines the request schema for `/payment_initiation/payment/list`
data PaymentInitiationPaymentListRequest = PaymentInitiationPaymentListRequest
  { paymentInitiationPaymentListRequestClientId :: !(Maybe Text) -- ^ "client_id" - Your Plaid API &#x60;client_id&#x60;.
  , paymentInitiationPaymentListRequestSecret :: !(Maybe Text) -- ^ "secret" - Your Plaid API &#x60;secret&#x60;.
  , paymentInitiationPaymentListRequestCount :: !(Maybe Int) -- ^ "count" - The maximum number of payments to return. If &#x60;count&#x60; is not specified, a maximum of 10 payments will be returned, beginning with the most recent payment before the cursor (if specified).
  , paymentInitiationPaymentListRequestCursor :: !(Maybe Text) -- ^ "cursor" - A string in RFC 3339 format (i.e. \&quot;2019-12-06T22:35:49Z\&quot;). Only payments created before the cursor will be returned.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PaymentInitiationPaymentListRequest
instance A.FromJSON PaymentInitiationPaymentListRequest where
  parseJSON = A.withObject "PaymentInitiationPaymentListRequest" $ \o ->
    PaymentInitiationPaymentListRequest
      <$> (o .:? "client_id")
      <*> (o .:? "secret")
      <*> (o .:? "count")
      <*> (o .:? "cursor")

-- | ToJSON PaymentInitiationPaymentListRequest
instance A.ToJSON PaymentInitiationPaymentListRequest where
  toJSON PaymentInitiationPaymentListRequest {..} =
   _omitNulls
      [ "client_id" .= paymentInitiationPaymentListRequestClientId
      , "secret" .= paymentInitiationPaymentListRequestSecret
      , "count" .= paymentInitiationPaymentListRequestCount
      , "cursor" .= paymentInitiationPaymentListRequestCursor
      ]


-- | Construct a value of type 'PaymentInitiationPaymentListRequest' (by applying it's required fields, if any)
mkPaymentInitiationPaymentListRequest
  :: PaymentInitiationPaymentListRequest
mkPaymentInitiationPaymentListRequest =
  PaymentInitiationPaymentListRequest
  { paymentInitiationPaymentListRequestClientId = Nothing
  , paymentInitiationPaymentListRequestSecret = Nothing
  , paymentInitiationPaymentListRequestCount = Nothing
  , paymentInitiationPaymentListRequestCursor = Nothing
  }

-- ** PaymentInitiationPaymentListResponse
-- | PaymentInitiationPaymentListResponse
-- PaymentInitiationPaymentListResponse defines the response schema for `/payment_initiation/payment/list`
data PaymentInitiationPaymentListResponse = PaymentInitiationPaymentListResponse
  { paymentInitiationPaymentListResponsePayments :: !([PaymentInitiationPaymentGetResponse]) -- ^ /Required/ "payments" - An array of payments that have been created, associated with the given &#x60;client_id&#x60;.
  , paymentInitiationPaymentListResponseNextCursor :: !(Text) -- ^ /Required/ "next_cursor" - The value that, when used as the optional &#x60;cursor&#x60; parameter to &#x60;/payment_initiation/payment/list&#x60;, will return the next unreturned payment as its first payment.
  , paymentInitiationPaymentListResponseRequestId :: !(Text) -- ^ /Required/ "request_id" - A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PaymentInitiationPaymentListResponse
instance A.FromJSON PaymentInitiationPaymentListResponse where
  parseJSON = A.withObject "PaymentInitiationPaymentListResponse" $ \o ->
    PaymentInitiationPaymentListResponse
      <$> (o .:  "payments")
      <*> (o .:  "next_cursor")
      <*> (o .:  "request_id")

-- | ToJSON PaymentInitiationPaymentListResponse
instance A.ToJSON PaymentInitiationPaymentListResponse where
  toJSON PaymentInitiationPaymentListResponse {..} =
   _omitNulls
      [ "payments" .= paymentInitiationPaymentListResponsePayments
      , "next_cursor" .= paymentInitiationPaymentListResponseNextCursor
      , "request_id" .= paymentInitiationPaymentListResponseRequestId
      ]


-- | Construct a value of type 'PaymentInitiationPaymentListResponse' (by applying it's required fields, if any)
mkPaymentInitiationPaymentListResponse
  :: [PaymentInitiationPaymentGetResponse] -- ^ 'paymentInitiationPaymentListResponsePayments': An array of payments that have been created, associated with the given `client_id`.
  -> Text -- ^ 'paymentInitiationPaymentListResponseNextCursor': The value that, when used as the optional `cursor` parameter to `/payment_initiation/payment/list`, will return the next unreturned payment as its first payment.
  -> Text -- ^ 'paymentInitiationPaymentListResponseRequestId': A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  -> PaymentInitiationPaymentListResponse
mkPaymentInitiationPaymentListResponse paymentInitiationPaymentListResponsePayments paymentInitiationPaymentListResponseNextCursor paymentInitiationPaymentListResponseRequestId =
  PaymentInitiationPaymentListResponse
  { paymentInitiationPaymentListResponsePayments
  , paymentInitiationPaymentListResponseNextCursor
  , paymentInitiationPaymentListResponseRequestId
  }

-- ** PaymentInitiationPaymentTokenCreateRequest
-- | PaymentInitiationPaymentTokenCreateRequest
-- PaymentInitiationPaymentTokenCreateRequest defines the request schema for `/payment_initiation/payment/token/create`
data PaymentInitiationPaymentTokenCreateRequest = PaymentInitiationPaymentTokenCreateRequest
  { paymentInitiationPaymentTokenCreateRequestClientId :: !(Maybe Text) -- ^ "client_id" - Your Plaid API &#x60;client_id&#x60;.
  , paymentInitiationPaymentTokenCreateRequestSecret :: !(Maybe Text) -- ^ "secret" - Your Plaid API &#x60;secret&#x60;.
  , paymentInitiationPaymentTokenCreateRequestPaymentId :: !(Text) -- ^ /Required/ "payment_id" - The &#x60;payment_id&#x60; returned from &#x60;/payment_initiation/payment/create&#x60;.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PaymentInitiationPaymentTokenCreateRequest
instance A.FromJSON PaymentInitiationPaymentTokenCreateRequest where
  parseJSON = A.withObject "PaymentInitiationPaymentTokenCreateRequest" $ \o ->
    PaymentInitiationPaymentTokenCreateRequest
      <$> (o .:? "client_id")
      <*> (o .:? "secret")
      <*> (o .:  "payment_id")

-- | ToJSON PaymentInitiationPaymentTokenCreateRequest
instance A.ToJSON PaymentInitiationPaymentTokenCreateRequest where
  toJSON PaymentInitiationPaymentTokenCreateRequest {..} =
   _omitNulls
      [ "client_id" .= paymentInitiationPaymentTokenCreateRequestClientId
      , "secret" .= paymentInitiationPaymentTokenCreateRequestSecret
      , "payment_id" .= paymentInitiationPaymentTokenCreateRequestPaymentId
      ]


-- | Construct a value of type 'PaymentInitiationPaymentTokenCreateRequest' (by applying it's required fields, if any)
mkPaymentInitiationPaymentTokenCreateRequest
  :: Text -- ^ 'paymentInitiationPaymentTokenCreateRequestPaymentId': The `payment_id` returned from `/payment_initiation/payment/create`.
  -> PaymentInitiationPaymentTokenCreateRequest
mkPaymentInitiationPaymentTokenCreateRequest paymentInitiationPaymentTokenCreateRequestPaymentId =
  PaymentInitiationPaymentTokenCreateRequest
  { paymentInitiationPaymentTokenCreateRequestClientId = Nothing
  , paymentInitiationPaymentTokenCreateRequestSecret = Nothing
  , paymentInitiationPaymentTokenCreateRequestPaymentId
  }

-- ** PaymentInitiationPaymentTokenCreateResponse
-- | PaymentInitiationPaymentTokenCreateResponse
-- PaymentInitiationPaymentTokenCreateResponse defines the response schema for `/payment_initiation/payment/token/create`
data PaymentInitiationPaymentTokenCreateResponse = PaymentInitiationPaymentTokenCreateResponse
  { paymentInitiationPaymentTokenCreateResponsePaymentToken :: !(Text) -- ^ /Required/ "payment_token" - A &#x60;payment_token&#x60; that can be provided to Link initialization to enter the payment initiation flow
  , paymentInitiationPaymentTokenCreateResponsePaymentTokenExpirationTime :: !(Text) -- ^ /Required/ "payment_token_expiration_time" - The date and time at which the token will expire, in ISO 8601 format. A &#x60;payment_token&#x60; expires after 15 minutes.
  , paymentInitiationPaymentTokenCreateResponseRequestId :: !(Text) -- ^ /Required/ "request_id" - A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PaymentInitiationPaymentTokenCreateResponse
instance A.FromJSON PaymentInitiationPaymentTokenCreateResponse where
  parseJSON = A.withObject "PaymentInitiationPaymentTokenCreateResponse" $ \o ->
    PaymentInitiationPaymentTokenCreateResponse
      <$> (o .:  "payment_token")
      <*> (o .:  "payment_token_expiration_time")
      <*> (o .:  "request_id")

-- | ToJSON PaymentInitiationPaymentTokenCreateResponse
instance A.ToJSON PaymentInitiationPaymentTokenCreateResponse where
  toJSON PaymentInitiationPaymentTokenCreateResponse {..} =
   _omitNulls
      [ "payment_token" .= paymentInitiationPaymentTokenCreateResponsePaymentToken
      , "payment_token_expiration_time" .= paymentInitiationPaymentTokenCreateResponsePaymentTokenExpirationTime
      , "request_id" .= paymentInitiationPaymentTokenCreateResponseRequestId
      ]


-- | Construct a value of type 'PaymentInitiationPaymentTokenCreateResponse' (by applying it's required fields, if any)
mkPaymentInitiationPaymentTokenCreateResponse
  :: Text -- ^ 'paymentInitiationPaymentTokenCreateResponsePaymentToken': A `payment_token` that can be provided to Link initialization to enter the payment initiation flow
  -> Text -- ^ 'paymentInitiationPaymentTokenCreateResponsePaymentTokenExpirationTime': The date and time at which the token will expire, in ISO 8601 format. A `payment_token` expires after 15 minutes.
  -> Text -- ^ 'paymentInitiationPaymentTokenCreateResponseRequestId': A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  -> PaymentInitiationPaymentTokenCreateResponse
mkPaymentInitiationPaymentTokenCreateResponse paymentInitiationPaymentTokenCreateResponsePaymentToken paymentInitiationPaymentTokenCreateResponsePaymentTokenExpirationTime paymentInitiationPaymentTokenCreateResponseRequestId =
  PaymentInitiationPaymentTokenCreateResponse
  { paymentInitiationPaymentTokenCreateResponsePaymentToken
  , paymentInitiationPaymentTokenCreateResponsePaymentTokenExpirationTime
  , paymentInitiationPaymentTokenCreateResponseRequestId
  }

-- ** PaymentInitiationRecipient
-- | PaymentInitiationRecipient
-- PaymentInitiationRecipient
-- 
-- Information about a payment recipient configured for the Payment Initiation product
data PaymentInitiationRecipient = PaymentInitiationRecipient
  { paymentInitiationRecipientRecipientId :: !(Text) -- ^ /Required/ "recipient_id" - The ID of the recipient. Like all Plaid identifiers, the &#x60;recipient_id&#x60; is case sensitive.
  , paymentInitiationRecipientName :: !(Text) -- ^ /Required/ "name" - The name of the recipient
  , paymentInitiationRecipientAddress :: !(PaymentInitiationAddress) -- ^ /Required/ "address"
  , paymentInitiationRecipientIban :: !(Maybe Text) -- ^ "iban" - The International Bank Account Number (IBAN) for the recipient.
  , paymentInitiationRecipientBacs :: !(Maybe (Map.Map String A.Value)) -- ^ "bacs"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PaymentInitiationRecipient
instance A.FromJSON PaymentInitiationRecipient where
  parseJSON = A.withObject "PaymentInitiationRecipient" $ \o ->
    PaymentInitiationRecipient
      <$> (o .:  "recipient_id")
      <*> (o .:  "name")
      <*> (o .:  "address")
      <*> (o .:? "iban")
      <*> (o .:? "bacs")

-- | ToJSON PaymentInitiationRecipient
instance A.ToJSON PaymentInitiationRecipient where
  toJSON PaymentInitiationRecipient {..} =
   _omitNulls
      [ "recipient_id" .= paymentInitiationRecipientRecipientId
      , "name" .= paymentInitiationRecipientName
      , "address" .= paymentInitiationRecipientAddress
      , "iban" .= paymentInitiationRecipientIban
      , "bacs" .= paymentInitiationRecipientBacs
      ]


-- | Construct a value of type 'PaymentInitiationRecipient' (by applying it's required fields, if any)
mkPaymentInitiationRecipient
  :: Text -- ^ 'paymentInitiationRecipientRecipientId': The ID of the recipient. Like all Plaid identifiers, the `recipient_id` is case sensitive.
  -> Text -- ^ 'paymentInitiationRecipientName': The name of the recipient
  -> PaymentInitiationAddress -- ^ 'paymentInitiationRecipientAddress' 
  -> PaymentInitiationRecipient
mkPaymentInitiationRecipient paymentInitiationRecipientRecipientId paymentInitiationRecipientName paymentInitiationRecipientAddress =
  PaymentInitiationRecipient
  { paymentInitiationRecipientRecipientId
  , paymentInitiationRecipientName
  , paymentInitiationRecipientAddress
  , paymentInitiationRecipientIban = Nothing
  , paymentInitiationRecipientBacs = Nothing
  }

-- ** PaymentInitiationRecipientCreateRequest
-- | PaymentInitiationRecipientCreateRequest
-- PaymentInitiationRecipientCreateRequest defines the request schema for `/payment_initiation/recipient/create`
data PaymentInitiationRecipientCreateRequest = PaymentInitiationRecipientCreateRequest
  { paymentInitiationRecipientCreateRequestClientId :: !(Maybe Text) -- ^ "client_id" - Your Plaid API &#x60;client_id&#x60;.
  , paymentInitiationRecipientCreateRequestSecret :: !(Maybe Text) -- ^ "secret" - Your Plaid API &#x60;secret&#x60;.
  , paymentInitiationRecipientCreateRequestName :: !(Text) -- ^ /Required/ "name" - The name of the recipient
  , paymentInitiationRecipientCreateRequestIban :: !(Maybe Text) -- ^ "iban" - The International Bank Account Number (IBAN) for the recipient. If BACS data is not provided, an IBAN is required.
  , paymentInitiationRecipientCreateRequestBacs :: !(Maybe NullableRecipientBACS) -- ^ "bacs"
  , paymentInitiationRecipientCreateRequestAddress :: !(Maybe PaymentInitiationAddress) -- ^ "address"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PaymentInitiationRecipientCreateRequest
instance A.FromJSON PaymentInitiationRecipientCreateRequest where
  parseJSON = A.withObject "PaymentInitiationRecipientCreateRequest" $ \o ->
    PaymentInitiationRecipientCreateRequest
      <$> (o .:? "client_id")
      <*> (o .:? "secret")
      <*> (o .:  "name")
      <*> (o .:? "iban")
      <*> (o .:? "bacs")
      <*> (o .:? "address")

-- | ToJSON PaymentInitiationRecipientCreateRequest
instance A.ToJSON PaymentInitiationRecipientCreateRequest where
  toJSON PaymentInitiationRecipientCreateRequest {..} =
   _omitNulls
      [ "client_id" .= paymentInitiationRecipientCreateRequestClientId
      , "secret" .= paymentInitiationRecipientCreateRequestSecret
      , "name" .= paymentInitiationRecipientCreateRequestName
      , "iban" .= paymentInitiationRecipientCreateRequestIban
      , "bacs" .= paymentInitiationRecipientCreateRequestBacs
      , "address" .= paymentInitiationRecipientCreateRequestAddress
      ]


-- | Construct a value of type 'PaymentInitiationRecipientCreateRequest' (by applying it's required fields, if any)
mkPaymentInitiationRecipientCreateRequest
  :: Text -- ^ 'paymentInitiationRecipientCreateRequestName': The name of the recipient
  -> PaymentInitiationRecipientCreateRequest
mkPaymentInitiationRecipientCreateRequest paymentInitiationRecipientCreateRequestName =
  PaymentInitiationRecipientCreateRequest
  { paymentInitiationRecipientCreateRequestClientId = Nothing
  , paymentInitiationRecipientCreateRequestSecret = Nothing
  , paymentInitiationRecipientCreateRequestName
  , paymentInitiationRecipientCreateRequestIban = Nothing
  , paymentInitiationRecipientCreateRequestBacs = Nothing
  , paymentInitiationRecipientCreateRequestAddress = Nothing
  }

-- ** PaymentInitiationRecipientCreateResponse
-- | PaymentInitiationRecipientCreateResponse
-- PaymentInitiationRecipientCreateResponse defines the response schema for `/payment_initation/recipient/create`
data PaymentInitiationRecipientCreateResponse = PaymentInitiationRecipientCreateResponse
  { paymentInitiationRecipientCreateResponseRecipientId :: !(Text) -- ^ /Required/ "recipient_id" - A unique ID identifying the recipient
  , paymentInitiationRecipientCreateResponseRequestId :: !(Text) -- ^ /Required/ "request_id" - A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PaymentInitiationRecipientCreateResponse
instance A.FromJSON PaymentInitiationRecipientCreateResponse where
  parseJSON = A.withObject "PaymentInitiationRecipientCreateResponse" $ \o ->
    PaymentInitiationRecipientCreateResponse
      <$> (o .:  "recipient_id")
      <*> (o .:  "request_id")

-- | ToJSON PaymentInitiationRecipientCreateResponse
instance A.ToJSON PaymentInitiationRecipientCreateResponse where
  toJSON PaymentInitiationRecipientCreateResponse {..} =
   _omitNulls
      [ "recipient_id" .= paymentInitiationRecipientCreateResponseRecipientId
      , "request_id" .= paymentInitiationRecipientCreateResponseRequestId
      ]


-- | Construct a value of type 'PaymentInitiationRecipientCreateResponse' (by applying it's required fields, if any)
mkPaymentInitiationRecipientCreateResponse
  :: Text -- ^ 'paymentInitiationRecipientCreateResponseRecipientId': A unique ID identifying the recipient
  -> Text -- ^ 'paymentInitiationRecipientCreateResponseRequestId': A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  -> PaymentInitiationRecipientCreateResponse
mkPaymentInitiationRecipientCreateResponse paymentInitiationRecipientCreateResponseRecipientId paymentInitiationRecipientCreateResponseRequestId =
  PaymentInitiationRecipientCreateResponse
  { paymentInitiationRecipientCreateResponseRecipientId
  , paymentInitiationRecipientCreateResponseRequestId
  }

-- ** PaymentInitiationRecipientGetRequest
-- | PaymentInitiationRecipientGetRequest
-- PaymentInitiationRecipientGetRequest defines the request schema for `/payment_initiation/recipient/get`
data PaymentInitiationRecipientGetRequest = PaymentInitiationRecipientGetRequest
  { paymentInitiationRecipientGetRequestClientId :: !(Maybe Text) -- ^ "client_id" - Your Plaid API &#x60;client_id&#x60;.
  , paymentInitiationRecipientGetRequestSecret :: !(Maybe Text) -- ^ "secret" - Your Plaid API &#x60;secret&#x60;.
  , paymentInitiationRecipientGetRequestRecipientId :: !(Text) -- ^ /Required/ "recipient_id" - The ID of the recipient
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PaymentInitiationRecipientGetRequest
instance A.FromJSON PaymentInitiationRecipientGetRequest where
  parseJSON = A.withObject "PaymentInitiationRecipientGetRequest" $ \o ->
    PaymentInitiationRecipientGetRequest
      <$> (o .:? "client_id")
      <*> (o .:? "secret")
      <*> (o .:  "recipient_id")

-- | ToJSON PaymentInitiationRecipientGetRequest
instance A.ToJSON PaymentInitiationRecipientGetRequest where
  toJSON PaymentInitiationRecipientGetRequest {..} =
   _omitNulls
      [ "client_id" .= paymentInitiationRecipientGetRequestClientId
      , "secret" .= paymentInitiationRecipientGetRequestSecret
      , "recipient_id" .= paymentInitiationRecipientGetRequestRecipientId
      ]


-- | Construct a value of type 'PaymentInitiationRecipientGetRequest' (by applying it's required fields, if any)
mkPaymentInitiationRecipientGetRequest
  :: Text -- ^ 'paymentInitiationRecipientGetRequestRecipientId': The ID of the recipient
  -> PaymentInitiationRecipientGetRequest
mkPaymentInitiationRecipientGetRequest paymentInitiationRecipientGetRequestRecipientId =
  PaymentInitiationRecipientGetRequest
  { paymentInitiationRecipientGetRequestClientId = Nothing
  , paymentInitiationRecipientGetRequestSecret = Nothing
  , paymentInitiationRecipientGetRequestRecipientId
  }

-- ** PaymentInitiationRecipientGetResponse
-- | PaymentInitiationRecipientGetResponse
-- PaymentInitiationRecipientGetResponse defines the response schema for `/payment_initiation/recipient/get`
data PaymentInitiationRecipientGetResponse = PaymentInitiationRecipientGetResponse
  { paymentInitiationRecipientGetResponseRecipientId :: !(Text) -- ^ /Required/ "recipient_id" - The ID of the recipient.
  , paymentInitiationRecipientGetResponseName :: !(Text) -- ^ /Required/ "name" - The name of the recipient.
  , paymentInitiationRecipientGetResponseAddress :: !(Maybe PaymentInitiationAddress) -- ^ "address"
  , paymentInitiationRecipientGetResponseIban :: !(Text) -- ^ /Required/ "iban" - The International Bank Account Number (IBAN) for the recipient.
  , paymentInitiationRecipientGetResponseBacs :: !(Maybe NullableRecipientBACS) -- ^ "bacs"
  , paymentInitiationRecipientGetResponseRequestId :: !(Text) -- ^ /Required/ "request_id" - A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PaymentInitiationRecipientGetResponse
instance A.FromJSON PaymentInitiationRecipientGetResponse where
  parseJSON = A.withObject "PaymentInitiationRecipientGetResponse" $ \o ->
    PaymentInitiationRecipientGetResponse
      <$> (o .:  "recipient_id")
      <*> (o .:  "name")
      <*> (o .:? "address")
      <*> (o .:  "iban")
      <*> (o .:? "bacs")
      <*> (o .:  "request_id")

-- | ToJSON PaymentInitiationRecipientGetResponse
instance A.ToJSON PaymentInitiationRecipientGetResponse where
  toJSON PaymentInitiationRecipientGetResponse {..} =
   _omitNulls
      [ "recipient_id" .= paymentInitiationRecipientGetResponseRecipientId
      , "name" .= paymentInitiationRecipientGetResponseName
      , "address" .= paymentInitiationRecipientGetResponseAddress
      , "iban" .= paymentInitiationRecipientGetResponseIban
      , "bacs" .= paymentInitiationRecipientGetResponseBacs
      , "request_id" .= paymentInitiationRecipientGetResponseRequestId
      ]


-- | Construct a value of type 'PaymentInitiationRecipientGetResponse' (by applying it's required fields, if any)
mkPaymentInitiationRecipientGetResponse
  :: Text -- ^ 'paymentInitiationRecipientGetResponseRecipientId': The ID of the recipient.
  -> Text -- ^ 'paymentInitiationRecipientGetResponseName': The name of the recipient.
  -> Text -- ^ 'paymentInitiationRecipientGetResponseIban': The International Bank Account Number (IBAN) for the recipient.
  -> Text -- ^ 'paymentInitiationRecipientGetResponseRequestId': A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  -> PaymentInitiationRecipientGetResponse
mkPaymentInitiationRecipientGetResponse paymentInitiationRecipientGetResponseRecipientId paymentInitiationRecipientGetResponseName paymentInitiationRecipientGetResponseIban paymentInitiationRecipientGetResponseRequestId =
  PaymentInitiationRecipientGetResponse
  { paymentInitiationRecipientGetResponseRecipientId
  , paymentInitiationRecipientGetResponseName
  , paymentInitiationRecipientGetResponseAddress = Nothing
  , paymentInitiationRecipientGetResponseIban
  , paymentInitiationRecipientGetResponseBacs = Nothing
  , paymentInitiationRecipientGetResponseRequestId
  }

-- ** PaymentInitiationRecipientListRequest
-- | PaymentInitiationRecipientListRequest
-- PaymentInitiationRecipientListRequest defines the request schema for `/payment_initiation/recipient/list`
data PaymentInitiationRecipientListRequest = PaymentInitiationRecipientListRequest
  { paymentInitiationRecipientListRequestClientId :: !(Maybe Text) -- ^ "client_id" - Your Plaid API &#x60;client_id&#x60;.
  , paymentInitiationRecipientListRequestSecret :: !(Maybe Text) -- ^ "secret" - Your Plaid API &#x60;secret&#x60;.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PaymentInitiationRecipientListRequest
instance A.FromJSON PaymentInitiationRecipientListRequest where
  parseJSON = A.withObject "PaymentInitiationRecipientListRequest" $ \o ->
    PaymentInitiationRecipientListRequest
      <$> (o .:? "client_id")
      <*> (o .:? "secret")

-- | ToJSON PaymentInitiationRecipientListRequest
instance A.ToJSON PaymentInitiationRecipientListRequest where
  toJSON PaymentInitiationRecipientListRequest {..} =
   _omitNulls
      [ "client_id" .= paymentInitiationRecipientListRequestClientId
      , "secret" .= paymentInitiationRecipientListRequestSecret
      ]


-- | Construct a value of type 'PaymentInitiationRecipientListRequest' (by applying it's required fields, if any)
mkPaymentInitiationRecipientListRequest
  :: PaymentInitiationRecipientListRequest
mkPaymentInitiationRecipientListRequest =
  PaymentInitiationRecipientListRequest
  { paymentInitiationRecipientListRequestClientId = Nothing
  , paymentInitiationRecipientListRequestSecret = Nothing
  }

-- ** PaymentInitiationRecipientListResponse
-- | PaymentInitiationRecipientListResponse
-- PaymentInitiationRecipientListResponse defines the response schema for `/payment_initiation/recipient/list`
data PaymentInitiationRecipientListResponse = PaymentInitiationRecipientListResponse
  { paymentInitiationRecipientListResponseRecipients :: !([PaymentInitiationRecipient]) -- ^ /Required/ "recipients" - An array of payment recipients created for Payment Initiation
  , paymentInitiationRecipientListResponseRequestId :: !(Text) -- ^ /Required/ "request_id" - A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PaymentInitiationRecipientListResponse
instance A.FromJSON PaymentInitiationRecipientListResponse where
  parseJSON = A.withObject "PaymentInitiationRecipientListResponse" $ \o ->
    PaymentInitiationRecipientListResponse
      <$> (o .:  "recipients")
      <*> (o .:  "request_id")

-- | ToJSON PaymentInitiationRecipientListResponse
instance A.ToJSON PaymentInitiationRecipientListResponse where
  toJSON PaymentInitiationRecipientListResponse {..} =
   _omitNulls
      [ "recipients" .= paymentInitiationRecipientListResponseRecipients
      , "request_id" .= paymentInitiationRecipientListResponseRequestId
      ]


-- | Construct a value of type 'PaymentInitiationRecipientListResponse' (by applying it's required fields, if any)
mkPaymentInitiationRecipientListResponse
  :: [PaymentInitiationRecipient] -- ^ 'paymentInitiationRecipientListResponseRecipients': An array of payment recipients created for Payment Initiation
  -> Text -- ^ 'paymentInitiationRecipientListResponseRequestId': A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  -> PaymentInitiationRecipientListResponse
mkPaymentInitiationRecipientListResponse paymentInitiationRecipientListResponseRecipients paymentInitiationRecipientListResponseRequestId =
  PaymentInitiationRecipientListResponse
  { paymentInitiationRecipientListResponseRecipients
  , paymentInitiationRecipientListResponseRequestId
  }

-- ** PaymentMeta
-- | PaymentMeta
-- payment_meta
-- 
-- Transaction information specific to inter-bank transfers. If the transaction was not an inter-bank transfer, all fields will be `null`.  If the `transaction` object was returned by a Transactions endpoint such as `/transactions/get`, the `payment_meta` key will always appear, but no data elements are guaranteed. If the `transaction` object was returned by an Assets endpoint such as `/asset_report/get/` or `/asset_report/pdf/get`, this field will only appear in an Asset Report with Insights.
data PaymentMeta = PaymentMeta
  { paymentMetaReferenceNumber :: !(Maybe Text) -- ^ "reference_number" - The transaction reference number supplied by the financial institution.
  , paymentMetaPpdId :: !(Maybe Text) -- ^ "ppd_id" - The ACH PPD ID for the payer.
  , paymentMetaPayee :: !(Maybe Text) -- ^ "payee" - For transfers, the party that is receiving the transaction.
  , paymentMetaByOrderOf :: !(Maybe Text) -- ^ "by_order_of" - The party initiating a wire transfer. Will be &#x60;null&#x60; if the transaction is not a wire transfer.
  , paymentMetaPayer :: !(Maybe Text) -- ^ "payer" - For transfers, the party that is paying the transaction.
  , paymentMetaPaymentMethod :: !(Maybe Text) -- ^ "payment_method" - The type of transfer, e.g. &#39;ACH&#39;
  , paymentMetaPaymentProcessor :: !(Maybe Text) -- ^ "payment_processor" - The name of the payment processor
  , paymentMetaReason :: !(Maybe Text) -- ^ "reason" - The payer-supplied description of the transfer.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PaymentMeta
instance A.FromJSON PaymentMeta where
  parseJSON = A.withObject "PaymentMeta" $ \o ->
    PaymentMeta
      <$> (o .:? "reference_number")
      <*> (o .:? "ppd_id")
      <*> (o .:? "payee")
      <*> (o .:? "by_order_of")
      <*> (o .:? "payer")
      <*> (o .:? "payment_method")
      <*> (o .:? "payment_processor")
      <*> (o .:? "reason")

-- | ToJSON PaymentMeta
instance A.ToJSON PaymentMeta where
  toJSON PaymentMeta {..} =
   _omitNulls
      [ "reference_number" .= paymentMetaReferenceNumber
      , "ppd_id" .= paymentMetaPpdId
      , "payee" .= paymentMetaPayee
      , "by_order_of" .= paymentMetaByOrderOf
      , "payer" .= paymentMetaPayer
      , "payment_method" .= paymentMetaPaymentMethod
      , "payment_processor" .= paymentMetaPaymentProcessor
      , "reason" .= paymentMetaReason
      ]


-- | Construct a value of type 'PaymentMeta' (by applying it's required fields, if any)
mkPaymentMeta
  :: PaymentMeta
mkPaymentMeta =
  PaymentMeta
  { paymentMetaReferenceNumber = Nothing
  , paymentMetaPpdId = Nothing
  , paymentMetaPayee = Nothing
  , paymentMetaByOrderOf = Nothing
  , paymentMetaPayer = Nothing
  , paymentMetaPaymentMethod = Nothing
  , paymentMetaPaymentProcessor = Nothing
  , paymentMetaReason = Nothing
  }

-- ** PaymentStatusUpdateWebhook
-- | PaymentStatusUpdateWebhook
-- PaymentStatusUpdateWebhook
-- 
-- Fired when the status of a payment has changed.
data PaymentStatusUpdateWebhook = PaymentStatusUpdateWebhook
  { paymentStatusUpdateWebhookWebhookType :: !(Text) -- ^ /Required/ "webhook_type" - &#x60;PAYMENT_INITIATION&#x60;
  , paymentStatusUpdateWebhookWebhookCode :: !(Text) -- ^ /Required/ "webhook_code" - &#x60;PAYMENT_STATUS_UPDATE&#x60;
  , paymentStatusUpdateWebhookPaymentId :: !(Text) -- ^ /Required/ "payment_id" - The &#x60;payment_id&#x60; for the payment being updated
  , paymentStatusUpdateWebhookNewPaymentStatus :: !(E'Status) -- ^ /Required/ "new_payment_status" - The new status of the payment.  &#x60;PAYMENT_STATUS_INPUT_NEEDED&#x60;: This is the initial state of all payments. It indicates that the payment is waiting on user input to continue processing. A payment may re-enter this state later on if further input is needed.  &#x60;PAYMENT_STATUS_PROCESSING&#x60;: The payment is currently being processed. The payment will automatically exit this state when processing is complete.  &#x60;PAYMENT_STATUS_INITIATED&#x60;: The payment has been successfully initiated and is considered complete.  &#x60;PAYMENT_STATUS_COMPLETED&#x60;: Indicates that the standing order has been successfully established. This state is only used for standing orders.  &#x60;PAYMENT_STATUS_INSUFFICIENT_FUNDS&#x60;: The payment has failed due to insufficient funds.  &#x60;PAYMENT_STATUS_FAILED&#x60;: The payment has failed to be initiated. This error is retryable once the root cause is resolved.  &#x60;PAYMENT_STATUS_BLOCKED&#x60;: The payment has been blocked. This is a retryable error.  &#x60;PAYMENT_STATUS_UNKNOWN&#x60;: The payment status is unknown.
  , paymentStatusUpdateWebhookOldPaymentStatus :: !(E'Status) -- ^ /Required/ "old_payment_status" - The previous status of the payment.  &#x60;PAYMENT_STATUS_INPUT_NEEDED&#x60;: This is the initial state of all payments. It indicates that the payment is waiting on user input to continue processing. A payment may re-enter this state later on if further input is needed.  &#x60;PAYMENT_STATUS_PROCESSING&#x60;: The payment is currently being processed. The payment will automatically exit this state when processing is complete.  &#x60;PAYMENT_STATUS_INITIATED&#x60;: The payment has been successfully initiated and is considered complete.  &#x60;PAYMENT_STATUS_COMPLETED&#x60;: Indicates that the standing order has been successfully established. This state is only used for standing orders.  &#x60;PAYMENT_STATUS_INSUFFICIENT_FUNDS&#x60;: The payment has failed due to insufficient funds.  &#x60;PAYMENT_STATUS_FAILED&#x60;: The payment has failed to be initiated. This error is retryable once the root cause is resolved.  &#x60;PAYMENT_STATUS_BLOCKED&#x60;: The payment has been blocked. This is a retryable error.  &#x60;PAYMENT_STATUS_UNKNOWN&#x60;: The payment status is unknown.
  , paymentStatusUpdateWebhookOriginalReference :: !(Maybe Text) -- ^ "original_reference" - The original value of the reference when creating the payment.
  , paymentStatusUpdateWebhookAdjustedReference :: !(Maybe Text) -- ^ "adjusted_reference" - The value of the reference sent to the bank after adjustment to pass bank validation rules.
  , paymentStatusUpdateWebhookOriginalStartDate :: !(Maybe Date) -- ^ "original_start_date" - The original value of the &#x60;start_date&#x60; provided during the creation of a standing order. If the payment is not a standing order, this field will be &#x60;null&#x60;.
  , paymentStatusUpdateWebhookAdjustedStartDate :: !(Maybe Date) -- ^ "adjusted_start_date" - The start date sent to the bank after adjusting for holidays or weekends.  Will be provided in ISO 8601 format (YYYY-MM-DD). If the start date did not require adjustment, or if the payment is not a standing order, this field will be &#x60;null&#x60;.
  , paymentStatusUpdateWebhookTimestamp :: !(Text) -- ^ /Required/ "timestamp" - The timestamp of the update, in ISO 8601 format, e.g. &#x60;\&quot;2017-09-14T14:42:19.350Z\&quot;&#x60;
  , paymentStatusUpdateWebhookError :: !(Maybe Error) -- ^ "error"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PaymentStatusUpdateWebhook
instance A.FromJSON PaymentStatusUpdateWebhook where
  parseJSON = A.withObject "PaymentStatusUpdateWebhook" $ \o ->
    PaymentStatusUpdateWebhook
      <$> (o .:  "webhook_type")
      <*> (o .:  "webhook_code")
      <*> (o .:  "payment_id")
      <*> (o .:  "new_payment_status")
      <*> (o .:  "old_payment_status")
      <*> (o .:? "original_reference")
      <*> (o .:? "adjusted_reference")
      <*> (o .:? "original_start_date")
      <*> (o .:? "adjusted_start_date")
      <*> (o .:  "timestamp")
      <*> (o .:? "error")

-- | ToJSON PaymentStatusUpdateWebhook
instance A.ToJSON PaymentStatusUpdateWebhook where
  toJSON PaymentStatusUpdateWebhook {..} =
   _omitNulls
      [ "webhook_type" .= paymentStatusUpdateWebhookWebhookType
      , "webhook_code" .= paymentStatusUpdateWebhookWebhookCode
      , "payment_id" .= paymentStatusUpdateWebhookPaymentId
      , "new_payment_status" .= paymentStatusUpdateWebhookNewPaymentStatus
      , "old_payment_status" .= paymentStatusUpdateWebhookOldPaymentStatus
      , "original_reference" .= paymentStatusUpdateWebhookOriginalReference
      , "adjusted_reference" .= paymentStatusUpdateWebhookAdjustedReference
      , "original_start_date" .= paymentStatusUpdateWebhookOriginalStartDate
      , "adjusted_start_date" .= paymentStatusUpdateWebhookAdjustedStartDate
      , "timestamp" .= paymentStatusUpdateWebhookTimestamp
      , "error" .= paymentStatusUpdateWebhookError
      ]


-- | Construct a value of type 'PaymentStatusUpdateWebhook' (by applying it's required fields, if any)
mkPaymentStatusUpdateWebhook
  :: Text -- ^ 'paymentStatusUpdateWebhookWebhookType': `PAYMENT_INITIATION`
  -> Text -- ^ 'paymentStatusUpdateWebhookWebhookCode': `PAYMENT_STATUS_UPDATE`
  -> Text -- ^ 'paymentStatusUpdateWebhookPaymentId': The `payment_id` for the payment being updated
  -> E'Status -- ^ 'paymentStatusUpdateWebhookNewPaymentStatus': The new status of the payment.  `PAYMENT_STATUS_INPUT_NEEDED`: This is the initial state of all payments. It indicates that the payment is waiting on user input to continue processing. A payment may re-enter this state later on if further input is needed.  `PAYMENT_STATUS_PROCESSING`: The payment is currently being processed. The payment will automatically exit this state when processing is complete.  `PAYMENT_STATUS_INITIATED`: The payment has been successfully initiated and is considered complete.  `PAYMENT_STATUS_COMPLETED`: Indicates that the standing order has been successfully established. This state is only used for standing orders.  `PAYMENT_STATUS_INSUFFICIENT_FUNDS`: The payment has failed due to insufficient funds.  `PAYMENT_STATUS_FAILED`: The payment has failed to be initiated. This error is retryable once the root cause is resolved.  `PAYMENT_STATUS_BLOCKED`: The payment has been blocked. This is a retryable error.  `PAYMENT_STATUS_UNKNOWN`: The payment status is unknown.
  -> E'Status -- ^ 'paymentStatusUpdateWebhookOldPaymentStatus': The previous status of the payment.  `PAYMENT_STATUS_INPUT_NEEDED`: This is the initial state of all payments. It indicates that the payment is waiting on user input to continue processing. A payment may re-enter this state later on if further input is needed.  `PAYMENT_STATUS_PROCESSING`: The payment is currently being processed. The payment will automatically exit this state when processing is complete.  `PAYMENT_STATUS_INITIATED`: The payment has been successfully initiated and is considered complete.  `PAYMENT_STATUS_COMPLETED`: Indicates that the standing order has been successfully established. This state is only used for standing orders.  `PAYMENT_STATUS_INSUFFICIENT_FUNDS`: The payment has failed due to insufficient funds.  `PAYMENT_STATUS_FAILED`: The payment has failed to be initiated. This error is retryable once the root cause is resolved.  `PAYMENT_STATUS_BLOCKED`: The payment has been blocked. This is a retryable error.  `PAYMENT_STATUS_UNKNOWN`: The payment status is unknown.
  -> Text -- ^ 'paymentStatusUpdateWebhookTimestamp': The timestamp of the update, in ISO 8601 format, e.g. `\"2017-09-14T14:42:19.350Z\"`
  -> PaymentStatusUpdateWebhook
mkPaymentStatusUpdateWebhook paymentStatusUpdateWebhookWebhookType paymentStatusUpdateWebhookWebhookCode paymentStatusUpdateWebhookPaymentId paymentStatusUpdateWebhookNewPaymentStatus paymentStatusUpdateWebhookOldPaymentStatus paymentStatusUpdateWebhookTimestamp =
  PaymentStatusUpdateWebhook
  { paymentStatusUpdateWebhookWebhookType
  , paymentStatusUpdateWebhookWebhookCode
  , paymentStatusUpdateWebhookPaymentId
  , paymentStatusUpdateWebhookNewPaymentStatus
  , paymentStatusUpdateWebhookOldPaymentStatus
  , paymentStatusUpdateWebhookOriginalReference = Nothing
  , paymentStatusUpdateWebhookAdjustedReference = Nothing
  , paymentStatusUpdateWebhookOriginalStartDate = Nothing
  , paymentStatusUpdateWebhookAdjustedStartDate = Nothing
  , paymentStatusUpdateWebhookTimestamp
  , paymentStatusUpdateWebhookError = Nothing
  }

-- ** Paystub
-- | Paystub
-- Paystub
-- 
-- An object representing data extracted from the end user's paystub.
data Paystub = Paystub
  { paystubPaystubId :: !(Text) -- ^ /Required/ "paystub_id" - The unique identifier for this paystub.
  , paystubAccountId :: !(Maybe Text) -- ^ "account_id" - The account identifier for the account associated with this paystub.
  , paystubEmployer :: !(Employer) -- ^ /Required/ "employer"
  , paystubEmployee :: !(Employee) -- ^ /Required/ "employee"
  , paystubPayPeriodDetails :: !(PayPeriodDetails) -- ^ /Required/ "pay_period_details"
  , paystubIncomeBreakdown :: !(IncomeBreakdown) -- ^ /Required/ "income_breakdown"
  , paystubYtdEarnings :: !(PaystubYTDDetails) -- ^ /Required/ "ytd_earnings"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Paystub
instance A.FromJSON Paystub where
  parseJSON = A.withObject "Paystub" $ \o ->
    Paystub
      <$> (o .:  "paystub_id")
      <*> (o .:? "account_id")
      <*> (o .:  "employer")
      <*> (o .:  "employee")
      <*> (o .:  "pay_period_details")
      <*> (o .:  "income_breakdown")
      <*> (o .:  "ytd_earnings")

-- | ToJSON Paystub
instance A.ToJSON Paystub where
  toJSON Paystub {..} =
   _omitNulls
      [ "paystub_id" .= paystubPaystubId
      , "account_id" .= paystubAccountId
      , "employer" .= paystubEmployer
      , "employee" .= paystubEmployee
      , "pay_period_details" .= paystubPayPeriodDetails
      , "income_breakdown" .= paystubIncomeBreakdown
      , "ytd_earnings" .= paystubYtdEarnings
      ]


-- | Construct a value of type 'Paystub' (by applying it's required fields, if any)
mkPaystub
  :: Text -- ^ 'paystubPaystubId': The unique identifier for this paystub.
  -> Employer -- ^ 'paystubEmployer' 
  -> Employee -- ^ 'paystubEmployee' 
  -> PayPeriodDetails -- ^ 'paystubPayPeriodDetails' 
  -> IncomeBreakdown -- ^ 'paystubIncomeBreakdown' 
  -> PaystubYTDDetails -- ^ 'paystubYtdEarnings' 
  -> Paystub
mkPaystub paystubPaystubId paystubEmployer paystubEmployee paystubPayPeriodDetails paystubIncomeBreakdown paystubYtdEarnings =
  Paystub
  { paystubPaystubId
  , paystubAccountId = Nothing
  , paystubEmployer
  , paystubEmployee
  , paystubPayPeriodDetails
  , paystubIncomeBreakdown
  , paystubYtdEarnings
  }

-- ** PaystubDeduction
-- | PaystubDeduction
-- PaystubDeduction
-- 
data PaystubDeduction = PaystubDeduction
  { paystubDeductionType :: !(Maybe Text) -- ^ "type" - The description of the deduction, as provided on the paystub. For example: &#x60;\&quot;401(k)\&quot;&#x60;, &#x60;\&quot;FICA MED TAX\&quot;&#x60;.
  , paystubDeductionIsPretax :: !(Maybe Bool) -- ^ "is_pretax" - &#x60;true&#x60; if the deduction is pre-tax; &#x60;false&#x60; otherwise.
  , paystubDeductionTotal :: !(Maybe Double) -- ^ "total" - The amount of the deduction.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PaystubDeduction
instance A.FromJSON PaystubDeduction where
  parseJSON = A.withObject "PaystubDeduction" $ \o ->
    PaystubDeduction
      <$> (o .:? "type")
      <*> (o .:? "is_pretax")
      <*> (o .:? "total")

-- | ToJSON PaystubDeduction
instance A.ToJSON PaystubDeduction where
  toJSON PaystubDeduction {..} =
   _omitNulls
      [ "type" .= paystubDeductionType
      , "is_pretax" .= paystubDeductionIsPretax
      , "total" .= paystubDeductionTotal
      ]


-- | Construct a value of type 'PaystubDeduction' (by applying it's required fields, if any)
mkPaystubDeduction
  :: PaystubDeduction
mkPaystubDeduction =
  PaystubDeduction
  { paystubDeductionType = Nothing
  , paystubDeductionIsPretax = Nothing
  , paystubDeductionTotal = Nothing
  }

-- ** PaystubYTDDetails
-- | PaystubYTDDetails
-- PaystubYTDDetails
-- 
data PaystubYTDDetails = PaystubYTDDetails
  { paystubYTDDetailsGrossEarnings :: !(Double) -- ^ /Required/ "gross_earnings" - Year-to-date gross earnings.
  , paystubYTDDetailsNetEarnings :: !(Double) -- ^ /Required/ "net_earnings" - Year-to-date net (take home) earnings.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PaystubYTDDetails
instance A.FromJSON PaystubYTDDetails where
  parseJSON = A.withObject "PaystubYTDDetails" $ \o ->
    PaystubYTDDetails
      <$> (o .:  "gross_earnings")
      <*> (o .:  "net_earnings")

-- | ToJSON PaystubYTDDetails
instance A.ToJSON PaystubYTDDetails where
  toJSON PaystubYTDDetails {..} =
   _omitNulls
      [ "gross_earnings" .= paystubYTDDetailsGrossEarnings
      , "net_earnings" .= paystubYTDDetailsNetEarnings
      ]


-- | Construct a value of type 'PaystubYTDDetails' (by applying it's required fields, if any)
mkPaystubYTDDetails
  :: Double -- ^ 'paystubYTDDetailsGrossEarnings': Year-to-date gross earnings.
  -> Double -- ^ 'paystubYTDDetailsNetEarnings': Year-to-date net (take home) earnings.
  -> PaystubYTDDetails
mkPaystubYTDDetails paystubYTDDetailsGrossEarnings paystubYTDDetailsNetEarnings =
  PaystubYTDDetails
  { paystubYTDDetailsGrossEarnings
  , paystubYTDDetailsNetEarnings
  }

-- ** PendingExpirationWebhook
-- | PendingExpirationWebhook
-- PendingExpirationWebhook
-- 
-- Fired when an Item’s access consent is expiring in 7 days. Some Items have explicit expiration times and we try to relay this when possible to reduce service disruption. This can be resolved by having the user go through Link’s update mode.
data PendingExpirationWebhook = PendingExpirationWebhook
  { pendingExpirationWebhookWebhookType :: !(Text) -- ^ /Required/ "webhook_type" - &#x60;ITEM&#x60;
  , pendingExpirationWebhookWebhookCode :: !(Text) -- ^ /Required/ "webhook_code" - &#x60;PENDING_EXPIRATION&#x60;
  , pendingExpirationWebhookItemId :: !(ItemId) -- ^ /Required/ "item_id" - The &#x60;item_id&#x60; of the Item associated with this webhook, warning, or error
  , pendingExpirationWebhookConsentExpirationTime :: !(Maybe TI.UTCTime) -- ^ /Required/ "consent_expiration_time" - The date and time at which the Item&#39;s access consent will expire, in ISO 8601 format
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PendingExpirationWebhook
instance A.FromJSON PendingExpirationWebhook where
  parseJSON = A.withObject "PendingExpirationWebhook" $ \o ->
    PendingExpirationWebhook
      <$> (o .:  "webhook_type")
      <*> (o .:  "webhook_code")
      <*> (o .:  "item_id")
      <*> (fmap unDateTime <$> (o .:?  "consent_expiration_time"))

-- | ToJSON PendingExpirationWebhook
instance A.ToJSON PendingExpirationWebhook where
  toJSON PendingExpirationWebhook {..} =
   _omitNulls
      [ "webhook_type" .= pendingExpirationWebhookWebhookType
      , "webhook_code" .= pendingExpirationWebhookWebhookCode
      , "item_id" .= pendingExpirationWebhookItemId
      , "consent_expiration_time" .= (DateTime <$> pendingExpirationWebhookConsentExpirationTime)
      ]


-- | Construct a value of type 'PendingExpirationWebhook' (by applying it's required fields, if any)
mkPendingExpirationWebhook
  :: Text -- ^ 'pendingExpirationWebhookWebhookType': `ITEM`
  -> Text -- ^ 'pendingExpirationWebhookWebhookCode': `PENDING_EXPIRATION`
  -> ItemId -- ^ 'pendingExpirationWebhookItemId': The `item_id` of the Item associated with this webhook, warning, or error
  -> (Maybe TI.UTCTime) -- ^ 'pendingExpirationWebhookConsentExpirationTime': The date and time at which the Item's access consent will expire, in ISO 8601 format
  -> PendingExpirationWebhook
mkPendingExpirationWebhook pendingExpirationWebhookWebhookType pendingExpirationWebhookWebhookCode pendingExpirationWebhookItemId pendingExpirationWebhookConsentExpirationTime =
  PendingExpirationWebhook
  { pendingExpirationWebhookWebhookType
  , pendingExpirationWebhookWebhookCode
  , pendingExpirationWebhookItemId
  , pendingExpirationWebhookConsentExpirationTime
  }

-- ** PhoneNumber
-- | PhoneNumber
-- PhoneNumber
-- 
-- A phone number
data PhoneNumber = PhoneNumber
  { phoneNumberData :: !(Text) -- ^ /Required/ "data" - The phone number.
  , phoneNumberPrimary :: !(Maybe Bool) -- ^ "primary" - When &#x60;true&#x60;, identifies the phone number as the primary number on an account.
  , phoneNumberType :: !(Maybe E'Type) -- ^ "type" - The type of phone number.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PhoneNumber
instance A.FromJSON PhoneNumber where
  parseJSON = A.withObject "PhoneNumber" $ \o ->
    PhoneNumber
      <$> (o .:  "data")
      <*> (o .:? "primary")
      <*> (o .:? "type")

-- | ToJSON PhoneNumber
instance A.ToJSON PhoneNumber where
  toJSON PhoneNumber {..} =
   _omitNulls
      [ "data" .= phoneNumberData
      , "primary" .= phoneNumberPrimary
      , "type" .= phoneNumberType
      ]


-- | Construct a value of type 'PhoneNumber' (by applying it's required fields, if any)
mkPhoneNumber
  :: Text -- ^ 'phoneNumberData': The phone number.
  -> PhoneNumber
mkPhoneNumber phoneNumberData =
  PhoneNumber
  { phoneNumberData
  , phoneNumberPrimary = Nothing
  , phoneNumberType = Nothing
  }

-- ** ProcessorApexProcessorTokenCreateRequest
-- | ProcessorApexProcessorTokenCreateRequest
-- ProcessorApexProcessorTokenCreateRequest defines the request schema for `/processor/apex/processor_token/create`
data ProcessorApexProcessorTokenCreateRequest = ProcessorApexProcessorTokenCreateRequest
  { processorApexProcessorTokenCreateRequestClientId :: !(Maybe Text) -- ^ "client_id" - Your Plaid API &#x60;client_id&#x60;.
  , processorApexProcessorTokenCreateRequestSecret :: !(Maybe Text) -- ^ "secret" - Your Plaid API &#x60;secret&#x60;.
  , processorApexProcessorTokenCreateRequestAccessToken :: !(AccessToken) -- ^ /Required/ "access_token" - The access token associated with the Item data is being requested for.
  , processorApexProcessorTokenCreateRequestAccountId :: !(Text) -- ^ /Required/ "account_id" - The &#x60;account_id&#x60; value obtained from the &#x60;onSuccess&#x60; callback in Link
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ProcessorApexProcessorTokenCreateRequest
instance A.FromJSON ProcessorApexProcessorTokenCreateRequest where
  parseJSON = A.withObject "ProcessorApexProcessorTokenCreateRequest" $ \o ->
    ProcessorApexProcessorTokenCreateRequest
      <$> (o .:? "client_id")
      <*> (o .:? "secret")
      <*> (o .:  "access_token")
      <*> (o .:  "account_id")

-- | ToJSON ProcessorApexProcessorTokenCreateRequest
instance A.ToJSON ProcessorApexProcessorTokenCreateRequest where
  toJSON ProcessorApexProcessorTokenCreateRequest {..} =
   _omitNulls
      [ "client_id" .= processorApexProcessorTokenCreateRequestClientId
      , "secret" .= processorApexProcessorTokenCreateRequestSecret
      , "access_token" .= processorApexProcessorTokenCreateRequestAccessToken
      , "account_id" .= processorApexProcessorTokenCreateRequestAccountId
      ]


-- | Construct a value of type 'ProcessorApexProcessorTokenCreateRequest' (by applying it's required fields, if any)
mkProcessorApexProcessorTokenCreateRequest
  :: AccessToken -- ^ 'processorApexProcessorTokenCreateRequestAccessToken': The access token associated with the Item data is being requested for.
  -> Text -- ^ 'processorApexProcessorTokenCreateRequestAccountId': The `account_id` value obtained from the `onSuccess` callback in Link
  -> ProcessorApexProcessorTokenCreateRequest
mkProcessorApexProcessorTokenCreateRequest processorApexProcessorTokenCreateRequestAccessToken processorApexProcessorTokenCreateRequestAccountId =
  ProcessorApexProcessorTokenCreateRequest
  { processorApexProcessorTokenCreateRequestClientId = Nothing
  , processorApexProcessorTokenCreateRequestSecret = Nothing
  , processorApexProcessorTokenCreateRequestAccessToken
  , processorApexProcessorTokenCreateRequestAccountId
  }

-- ** ProcessorAuthGetRequest
-- | ProcessorAuthGetRequest
-- ProcessorAuthGetRequest defines the request schema for `/processor/auth/get`
data ProcessorAuthGetRequest = ProcessorAuthGetRequest
  { processorAuthGetRequestClientId :: !(Maybe Text) -- ^ "client_id" - Your Plaid API &#x60;client_id&#x60;.
  , processorAuthGetRequestSecret :: !(Maybe Text) -- ^ "secret" - Your Plaid API &#x60;secret&#x60;.
  , processorAuthGetRequestProcessorToken :: !(Text) -- ^ /Required/ "processor_token" - The processor token obtained from the Plaid integration partner. Processor tokens are in the format: &#x60;processor-&lt;environment&gt;-&lt;identifier&gt;&#x60;
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ProcessorAuthGetRequest
instance A.FromJSON ProcessorAuthGetRequest where
  parseJSON = A.withObject "ProcessorAuthGetRequest" $ \o ->
    ProcessorAuthGetRequest
      <$> (o .:? "client_id")
      <*> (o .:? "secret")
      <*> (o .:  "processor_token")

-- | ToJSON ProcessorAuthGetRequest
instance A.ToJSON ProcessorAuthGetRequest where
  toJSON ProcessorAuthGetRequest {..} =
   _omitNulls
      [ "client_id" .= processorAuthGetRequestClientId
      , "secret" .= processorAuthGetRequestSecret
      , "processor_token" .= processorAuthGetRequestProcessorToken
      ]


-- | Construct a value of type 'ProcessorAuthGetRequest' (by applying it's required fields, if any)
mkProcessorAuthGetRequest
  :: Text -- ^ 'processorAuthGetRequestProcessorToken': The processor token obtained from the Plaid integration partner. Processor tokens are in the format: `processor-<environment>-<identifier>`
  -> ProcessorAuthGetRequest
mkProcessorAuthGetRequest processorAuthGetRequestProcessorToken =
  ProcessorAuthGetRequest
  { processorAuthGetRequestClientId = Nothing
  , processorAuthGetRequestSecret = Nothing
  , processorAuthGetRequestProcessorToken
  }

-- ** ProcessorAuthGetResponse
-- | ProcessorAuthGetResponse
-- ProcessorAuthGetResponse defines the response schema for `/processor/auth/get`
data ProcessorAuthGetResponse = ProcessorAuthGetResponse
  { processorAuthGetResponseRequestId :: !(Text) -- ^ /Required/ "request_id" - A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  , processorAuthGetResponseNumbers :: !(ProcessorNumber) -- ^ /Required/ "numbers"
  , processorAuthGetResponseAccount :: !(AccountBase) -- ^ /Required/ "account"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ProcessorAuthGetResponse
instance A.FromJSON ProcessorAuthGetResponse where
  parseJSON = A.withObject "ProcessorAuthGetResponse" $ \o ->
    ProcessorAuthGetResponse
      <$> (o .:  "request_id")
      <*> (o .:  "numbers")
      <*> (o .:  "account")

-- | ToJSON ProcessorAuthGetResponse
instance A.ToJSON ProcessorAuthGetResponse where
  toJSON ProcessorAuthGetResponse {..} =
   _omitNulls
      [ "request_id" .= processorAuthGetResponseRequestId
      , "numbers" .= processorAuthGetResponseNumbers
      , "account" .= processorAuthGetResponseAccount
      ]


-- | Construct a value of type 'ProcessorAuthGetResponse' (by applying it's required fields, if any)
mkProcessorAuthGetResponse
  :: Text -- ^ 'processorAuthGetResponseRequestId': A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  -> ProcessorNumber -- ^ 'processorAuthGetResponseNumbers' 
  -> AccountBase -- ^ 'processorAuthGetResponseAccount' 
  -> ProcessorAuthGetResponse
mkProcessorAuthGetResponse processorAuthGetResponseRequestId processorAuthGetResponseNumbers processorAuthGetResponseAccount =
  ProcessorAuthGetResponse
  { processorAuthGetResponseRequestId
  , processorAuthGetResponseNumbers
  , processorAuthGetResponseAccount
  }

-- ** ProcessorBalanceGetRequest
-- | ProcessorBalanceGetRequest
-- ProcessorBalanceGetRequest defines the request schema for `/processor/balance/get`
data ProcessorBalanceGetRequest = ProcessorBalanceGetRequest
  { processorBalanceGetRequestClientId :: !(Maybe Text) -- ^ "client_id" - Your Plaid API &#x60;client_id&#x60;.
  , processorBalanceGetRequestSecret :: !(Maybe Text) -- ^ "secret" - Your Plaid API &#x60;secret&#x60;.
  , processorBalanceGetRequestProcessorToken :: !(Text) -- ^ /Required/ "processor_token" - The processor token obtained from the Plaid integration partner. Processor tokens are in the format: &#x60;processor-&lt;environment&gt;-&lt;identifier&gt;&#x60;
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ProcessorBalanceGetRequest
instance A.FromJSON ProcessorBalanceGetRequest where
  parseJSON = A.withObject "ProcessorBalanceGetRequest" $ \o ->
    ProcessorBalanceGetRequest
      <$> (o .:? "client_id")
      <*> (o .:? "secret")
      <*> (o .:  "processor_token")

-- | ToJSON ProcessorBalanceGetRequest
instance A.ToJSON ProcessorBalanceGetRequest where
  toJSON ProcessorBalanceGetRequest {..} =
   _omitNulls
      [ "client_id" .= processorBalanceGetRequestClientId
      , "secret" .= processorBalanceGetRequestSecret
      , "processor_token" .= processorBalanceGetRequestProcessorToken
      ]


-- | Construct a value of type 'ProcessorBalanceGetRequest' (by applying it's required fields, if any)
mkProcessorBalanceGetRequest
  :: Text -- ^ 'processorBalanceGetRequestProcessorToken': The processor token obtained from the Plaid integration partner. Processor tokens are in the format: `processor-<environment>-<identifier>`
  -> ProcessorBalanceGetRequest
mkProcessorBalanceGetRequest processorBalanceGetRequestProcessorToken =
  ProcessorBalanceGetRequest
  { processorBalanceGetRequestClientId = Nothing
  , processorBalanceGetRequestSecret = Nothing
  , processorBalanceGetRequestProcessorToken
  }

-- ** ProcessorBalanceGetResponse
-- | ProcessorBalanceGetResponse
-- ProcessorBalanceGetResponse defines the response schema for `/processor/balance/get`
data ProcessorBalanceGetResponse = ProcessorBalanceGetResponse
  { processorBalanceGetResponseAccount :: !(AccountBase) -- ^ /Required/ "account"
  , processorBalanceGetResponseRequestId :: !(Text) -- ^ /Required/ "request_id" - A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ProcessorBalanceGetResponse
instance A.FromJSON ProcessorBalanceGetResponse where
  parseJSON = A.withObject "ProcessorBalanceGetResponse" $ \o ->
    ProcessorBalanceGetResponse
      <$> (o .:  "account")
      <*> (o .:  "request_id")

-- | ToJSON ProcessorBalanceGetResponse
instance A.ToJSON ProcessorBalanceGetResponse where
  toJSON ProcessorBalanceGetResponse {..} =
   _omitNulls
      [ "account" .= processorBalanceGetResponseAccount
      , "request_id" .= processorBalanceGetResponseRequestId
      ]


-- | Construct a value of type 'ProcessorBalanceGetResponse' (by applying it's required fields, if any)
mkProcessorBalanceGetResponse
  :: AccountBase -- ^ 'processorBalanceGetResponseAccount' 
  -> Text -- ^ 'processorBalanceGetResponseRequestId': A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  -> ProcessorBalanceGetResponse
mkProcessorBalanceGetResponse processorBalanceGetResponseAccount processorBalanceGetResponseRequestId =
  ProcessorBalanceGetResponse
  { processorBalanceGetResponseAccount
  , processorBalanceGetResponseRequestId
  }

-- ** ProcessorIdentityGetRequest
-- | ProcessorIdentityGetRequest
-- ProcessorIdentityGetRequest defines the request schema for `/processor/identity/get`
data ProcessorIdentityGetRequest = ProcessorIdentityGetRequest
  { processorIdentityGetRequestClientId :: !(Maybe Text) -- ^ "client_id" - Your Plaid API &#x60;client_id&#x60;.
  , processorIdentityGetRequestSecret :: !(Maybe Text) -- ^ "secret" - Your Plaid API &#x60;secret&#x60;.
  , processorIdentityGetRequestProcessorToken :: !(Text) -- ^ /Required/ "processor_token" - The processor token obtained from the Plaid integration partner. Processor tokens are in the format: &#x60;processor-&lt;environment&gt;-&lt;identifier&gt;&#x60;
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ProcessorIdentityGetRequest
instance A.FromJSON ProcessorIdentityGetRequest where
  parseJSON = A.withObject "ProcessorIdentityGetRequest" $ \o ->
    ProcessorIdentityGetRequest
      <$> (o .:? "client_id")
      <*> (o .:? "secret")
      <*> (o .:  "processor_token")

-- | ToJSON ProcessorIdentityGetRequest
instance A.ToJSON ProcessorIdentityGetRequest where
  toJSON ProcessorIdentityGetRequest {..} =
   _omitNulls
      [ "client_id" .= processorIdentityGetRequestClientId
      , "secret" .= processorIdentityGetRequestSecret
      , "processor_token" .= processorIdentityGetRequestProcessorToken
      ]


-- | Construct a value of type 'ProcessorIdentityGetRequest' (by applying it's required fields, if any)
mkProcessorIdentityGetRequest
  :: Text -- ^ 'processorIdentityGetRequestProcessorToken': The processor token obtained from the Plaid integration partner. Processor tokens are in the format: `processor-<environment>-<identifier>`
  -> ProcessorIdentityGetRequest
mkProcessorIdentityGetRequest processorIdentityGetRequestProcessorToken =
  ProcessorIdentityGetRequest
  { processorIdentityGetRequestClientId = Nothing
  , processorIdentityGetRequestSecret = Nothing
  , processorIdentityGetRequestProcessorToken
  }

-- ** ProcessorIdentityGetResponse
-- | ProcessorIdentityGetResponse
-- ProcessorIdentityGetResponse defines the response schema for `/processor/identity/get`
data ProcessorIdentityGetResponse = ProcessorIdentityGetResponse
  { processorIdentityGetResponseAccount :: !(AccountIdentity) -- ^ /Required/ "account"
  , processorIdentityGetResponseRequestId :: !(Text) -- ^ /Required/ "request_id" - A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ProcessorIdentityGetResponse
instance A.FromJSON ProcessorIdentityGetResponse where
  parseJSON = A.withObject "ProcessorIdentityGetResponse" $ \o ->
    ProcessorIdentityGetResponse
      <$> (o .:  "account")
      <*> (o .:  "request_id")

-- | ToJSON ProcessorIdentityGetResponse
instance A.ToJSON ProcessorIdentityGetResponse where
  toJSON ProcessorIdentityGetResponse {..} =
   _omitNulls
      [ "account" .= processorIdentityGetResponseAccount
      , "request_id" .= processorIdentityGetResponseRequestId
      ]


-- | Construct a value of type 'ProcessorIdentityGetResponse' (by applying it's required fields, if any)
mkProcessorIdentityGetResponse
  :: AccountIdentity -- ^ 'processorIdentityGetResponseAccount' 
  -> Text -- ^ 'processorIdentityGetResponseRequestId': A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  -> ProcessorIdentityGetResponse
mkProcessorIdentityGetResponse processorIdentityGetResponseAccount processorIdentityGetResponseRequestId =
  ProcessorIdentityGetResponse
  { processorIdentityGetResponseAccount
  , processorIdentityGetResponseRequestId
  }

-- ** ProcessorNumber
-- | ProcessorNumber
-- An object containing identifying numbers used for making electronic transfers to and from the `account`. The identifying number type (ACH, EFT, IBAN, or BACS) used will depend on the country of the account. An account may have more than one number type. If a particular identifying number type is not used by the `account` for which auth data has been requested, a null value will be returned.
data ProcessorNumber = ProcessorNumber
  { processorNumberAch :: !(Maybe NullableNumbersACH) -- ^ "ach"
  , processorNumberEft :: !(Maybe NullableNumbersEFT) -- ^ "eft"
  , processorNumberInternational :: !(Maybe NullableNumbersInternational) -- ^ "international"
  , processorNumberBacs :: !(Maybe NullableNumbersBACS) -- ^ "bacs"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ProcessorNumber
instance A.FromJSON ProcessorNumber where
  parseJSON = A.withObject "ProcessorNumber" $ \o ->
    ProcessorNumber
      <$> (o .:? "ach")
      <*> (o .:? "eft")
      <*> (o .:? "international")
      <*> (o .:? "bacs")

-- | ToJSON ProcessorNumber
instance A.ToJSON ProcessorNumber where
  toJSON ProcessorNumber {..} =
   _omitNulls
      [ "ach" .= processorNumberAch
      , "eft" .= processorNumberEft
      , "international" .= processorNumberInternational
      , "bacs" .= processorNumberBacs
      ]


-- | Construct a value of type 'ProcessorNumber' (by applying it's required fields, if any)
mkProcessorNumber
  :: ProcessorNumber
mkProcessorNumber =
  ProcessorNumber
  { processorNumberAch = Nothing
  , processorNumberEft = Nothing
  , processorNumberInternational = Nothing
  , processorNumberBacs = Nothing
  }

-- ** ProcessorStripeBankAccountTokenCreateRequest
-- | ProcessorStripeBankAccountTokenCreateRequest
-- ProcessorStripeBankAccountTokenCreateRequest defines the request schema for `/processor/stripe/bank_account/create`
data ProcessorStripeBankAccountTokenCreateRequest = ProcessorStripeBankAccountTokenCreateRequest
  { processorStripeBankAccountTokenCreateRequestClientId :: !(Maybe Text) -- ^ "client_id" - Your Plaid API &#x60;client_id&#x60;.
  , processorStripeBankAccountTokenCreateRequestSecret :: !(Maybe Text) -- ^ "secret" - Your Plaid API &#x60;secret&#x60;.
  , processorStripeBankAccountTokenCreateRequestAccessToken :: !(AccessToken) -- ^ /Required/ "access_token" - The access token associated with the Item data is being requested for.
  , processorStripeBankAccountTokenCreateRequestAccountId :: !(Text) -- ^ /Required/ "account_id" - The &#x60;account_id&#x60; value obtained from the &#x60;onSuccess&#x60; callback in Link
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ProcessorStripeBankAccountTokenCreateRequest
instance A.FromJSON ProcessorStripeBankAccountTokenCreateRequest where
  parseJSON = A.withObject "ProcessorStripeBankAccountTokenCreateRequest" $ \o ->
    ProcessorStripeBankAccountTokenCreateRequest
      <$> (o .:? "client_id")
      <*> (o .:? "secret")
      <*> (o .:  "access_token")
      <*> (o .:  "account_id")

-- | ToJSON ProcessorStripeBankAccountTokenCreateRequest
instance A.ToJSON ProcessorStripeBankAccountTokenCreateRequest where
  toJSON ProcessorStripeBankAccountTokenCreateRequest {..} =
   _omitNulls
      [ "client_id" .= processorStripeBankAccountTokenCreateRequestClientId
      , "secret" .= processorStripeBankAccountTokenCreateRequestSecret
      , "access_token" .= processorStripeBankAccountTokenCreateRequestAccessToken
      , "account_id" .= processorStripeBankAccountTokenCreateRequestAccountId
      ]


-- | Construct a value of type 'ProcessorStripeBankAccountTokenCreateRequest' (by applying it's required fields, if any)
mkProcessorStripeBankAccountTokenCreateRequest
  :: AccessToken -- ^ 'processorStripeBankAccountTokenCreateRequestAccessToken': The access token associated with the Item data is being requested for.
  -> Text -- ^ 'processorStripeBankAccountTokenCreateRequestAccountId': The `account_id` value obtained from the `onSuccess` callback in Link
  -> ProcessorStripeBankAccountTokenCreateRequest
mkProcessorStripeBankAccountTokenCreateRequest processorStripeBankAccountTokenCreateRequestAccessToken processorStripeBankAccountTokenCreateRequestAccountId =
  ProcessorStripeBankAccountTokenCreateRequest
  { processorStripeBankAccountTokenCreateRequestClientId = Nothing
  , processorStripeBankAccountTokenCreateRequestSecret = Nothing
  , processorStripeBankAccountTokenCreateRequestAccessToken
  , processorStripeBankAccountTokenCreateRequestAccountId
  }

-- ** ProcessorStripeBankAccountTokenCreateResponse
-- | ProcessorStripeBankAccountTokenCreateResponse
-- ProcessorStripeBankAccountTokenCreateResponse defines the response schema for `/processor/stripe/bank_account/create`
data ProcessorStripeBankAccountTokenCreateResponse = ProcessorStripeBankAccountTokenCreateResponse
  { processorStripeBankAccountTokenCreateResponseStripeBankAccountToken :: !(Text) -- ^ /Required/ "stripe_bank_account_token" - A token that can be sent to Stripe for use in making API calls to Plaid
  , processorStripeBankAccountTokenCreateResponseRequestId :: !(Text) -- ^ /Required/ "request_id" - A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ProcessorStripeBankAccountTokenCreateResponse
instance A.FromJSON ProcessorStripeBankAccountTokenCreateResponse where
  parseJSON = A.withObject "ProcessorStripeBankAccountTokenCreateResponse" $ \o ->
    ProcessorStripeBankAccountTokenCreateResponse
      <$> (o .:  "stripe_bank_account_token")
      <*> (o .:  "request_id")

-- | ToJSON ProcessorStripeBankAccountTokenCreateResponse
instance A.ToJSON ProcessorStripeBankAccountTokenCreateResponse where
  toJSON ProcessorStripeBankAccountTokenCreateResponse {..} =
   _omitNulls
      [ "stripe_bank_account_token" .= processorStripeBankAccountTokenCreateResponseStripeBankAccountToken
      , "request_id" .= processorStripeBankAccountTokenCreateResponseRequestId
      ]


-- | Construct a value of type 'ProcessorStripeBankAccountTokenCreateResponse' (by applying it's required fields, if any)
mkProcessorStripeBankAccountTokenCreateResponse
  :: Text -- ^ 'processorStripeBankAccountTokenCreateResponseStripeBankAccountToken': A token that can be sent to Stripe for use in making API calls to Plaid
  -> Text -- ^ 'processorStripeBankAccountTokenCreateResponseRequestId': A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  -> ProcessorStripeBankAccountTokenCreateResponse
mkProcessorStripeBankAccountTokenCreateResponse processorStripeBankAccountTokenCreateResponseStripeBankAccountToken processorStripeBankAccountTokenCreateResponseRequestId =
  ProcessorStripeBankAccountTokenCreateResponse
  { processorStripeBankAccountTokenCreateResponseStripeBankAccountToken
  , processorStripeBankAccountTokenCreateResponseRequestId
  }

-- ** ProcessorTokenCreateRequest
-- | ProcessorTokenCreateRequest
-- ProcessorTokenCreateRequest defines the request schema for `/processor/token/create`
data ProcessorTokenCreateRequest = ProcessorTokenCreateRequest
  { processorTokenCreateRequestClientId :: !(Maybe Text) -- ^ "client_id" - Your Plaid API &#x60;client_id&#x60;.
  , processorTokenCreateRequestSecret :: !(Maybe Text) -- ^ "secret" - Your Plaid API &#x60;secret&#x60;.
  , processorTokenCreateRequestAccessToken :: !(AccessToken) -- ^ /Required/ "access_token" - The access token associated with the Item data is being requested for.
  , processorTokenCreateRequestAccountId :: !(Text) -- ^ /Required/ "account_id" - The &#x60;account_id&#x60; value obtained from the &#x60;onSuccess&#x60; callback in Link
  , processorTokenCreateRequestProcessor :: !(Text) -- ^ /Required/ "processor" - The processor you are integrating with. Valid values are &#x60;\&quot;achq\&quot;&#x60;, &#x60;\&quot;check\&quot;&#x60;, &#x60;\&quot;checkbook\&quot;&#x60;, &#x60;\&quot;circle\&quot;&#x60;, &#x60;\&quot;drivewealth\&quot;&#x60;, &#x60;\&quot;dwolla\&quot;&#x60;, &#x60;\&quot;galileo\&quot;&#x60;, \&quot;&#x60;interactive_brokers&#x60;\&quot;, &#x60;\&quot;modern_treasury\&quot;&#x60;, &#x60;\&quot;ocrolus\&quot;&#x60;, &#x60;\&quot;prime_trust\&quot;&#x60;, &#x60;\&quot;rize\&quot;&#x60;, &#x60;\&quot;sila_money\&quot;&#x60;, &#x60;\&quot;unit\&quot;&#x60;, &#x60;\&quot;velox\&quot;&#x60;, &#x60;\&quot;vesta\&quot;&#x60;, &#x60;\&quot;vopay\&quot;&#x60;, &#x60;\&quot;wyre\&quot;&#x60;
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ProcessorTokenCreateRequest
instance A.FromJSON ProcessorTokenCreateRequest where
  parseJSON = A.withObject "ProcessorTokenCreateRequest" $ \o ->
    ProcessorTokenCreateRequest
      <$> (o .:? "client_id")
      <*> (o .:? "secret")
      <*> (o .:  "access_token")
      <*> (o .:  "account_id")
      <*> (o .:  "processor")

-- | ToJSON ProcessorTokenCreateRequest
instance A.ToJSON ProcessorTokenCreateRequest where
  toJSON ProcessorTokenCreateRequest {..} =
   _omitNulls
      [ "client_id" .= processorTokenCreateRequestClientId
      , "secret" .= processorTokenCreateRequestSecret
      , "access_token" .= processorTokenCreateRequestAccessToken
      , "account_id" .= processorTokenCreateRequestAccountId
      , "processor" .= processorTokenCreateRequestProcessor
      ]


-- | Construct a value of type 'ProcessorTokenCreateRequest' (by applying it's required fields, if any)
mkProcessorTokenCreateRequest
  :: AccessToken -- ^ 'processorTokenCreateRequestAccessToken': The access token associated with the Item data is being requested for.
  -> Text -- ^ 'processorTokenCreateRequestAccountId': The `account_id` value obtained from the `onSuccess` callback in Link
  -> Text -- ^ 'processorTokenCreateRequestProcessor': The processor you are integrating with. Valid values are `\"achq\"`, `\"check\"`, `\"checkbook\"`, `\"circle\"`, `\"drivewealth\"`, `\"dwolla\"`, `\"galileo\"`, \"`interactive_brokers`\", `\"modern_treasury\"`, `\"ocrolus\"`, `\"prime_trust\"`, `\"rize\"`, `\"sila_money\"`, `\"unit\"`, `\"velox\"`, `\"vesta\"`, `\"vopay\"`, `\"wyre\"`
  -> ProcessorTokenCreateRequest
mkProcessorTokenCreateRequest processorTokenCreateRequestAccessToken processorTokenCreateRequestAccountId processorTokenCreateRequestProcessor =
  ProcessorTokenCreateRequest
  { processorTokenCreateRequestClientId = Nothing
  , processorTokenCreateRequestSecret = Nothing
  , processorTokenCreateRequestAccessToken
  , processorTokenCreateRequestAccountId
  , processorTokenCreateRequestProcessor
  }

-- ** ProcessorTokenCreateResponse
-- | ProcessorTokenCreateResponse
-- ProcessorTokenCreateResponse defines the response schema for `/processor/token/create` and `/processor/apex/processor_token/create`
data ProcessorTokenCreateResponse = ProcessorTokenCreateResponse
  { processorTokenCreateResponseProcessorToken :: !(Text) -- ^ /Required/ "processor_token" - The &#x60;processor_token&#x60; that can then be used by the Plaid partner to make API requests
  , processorTokenCreateResponseRequestId :: !(Text) -- ^ /Required/ "request_id" - A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ProcessorTokenCreateResponse
instance A.FromJSON ProcessorTokenCreateResponse where
  parseJSON = A.withObject "ProcessorTokenCreateResponse" $ \o ->
    ProcessorTokenCreateResponse
      <$> (o .:  "processor_token")
      <*> (o .:  "request_id")

-- | ToJSON ProcessorTokenCreateResponse
instance A.ToJSON ProcessorTokenCreateResponse where
  toJSON ProcessorTokenCreateResponse {..} =
   _omitNulls
      [ "processor_token" .= processorTokenCreateResponseProcessorToken
      , "request_id" .= processorTokenCreateResponseRequestId
      ]


-- | Construct a value of type 'ProcessorTokenCreateResponse' (by applying it's required fields, if any)
mkProcessorTokenCreateResponse
  :: Text -- ^ 'processorTokenCreateResponseProcessorToken': The `processor_token` that can then be used by the Plaid partner to make API requests
  -> Text -- ^ 'processorTokenCreateResponseRequestId': A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  -> ProcessorTokenCreateResponse
mkProcessorTokenCreateResponse processorTokenCreateResponseProcessorToken processorTokenCreateResponseRequestId =
  ProcessorTokenCreateResponse
  { processorTokenCreateResponseProcessorToken
  , processorTokenCreateResponseRequestId
  }

-- ** ProductStatus
-- | ProductStatus
-- ProductStatus
-- 
-- A representation of the status health of a request type. Auth requests, Balance requests, Identity requests, Transactions updates, Investments updates, and Item logins each have their own status object.
data ProductStatus = ProductStatus
  { productStatusStatus :: !(E'Status2) -- ^ /Required/ "status" - &#x60;HEALTHY&#x60;: the majority of requests are successful &#x60;DEGRADED&#x60;: only some requests are successful &#x60;DOWN&#x60;: all requests are failing
  , productStatusLastStatusChange :: !(Text) -- ^ /Required/ "last_status_change" - ISO 8601 formatted timestamp of the last status change for the institution.
  , productStatusBreakdown :: !(ProductStatusBreakdown) -- ^ /Required/ "breakdown"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ProductStatus
instance A.FromJSON ProductStatus where
  parseJSON = A.withObject "ProductStatus" $ \o ->
    ProductStatus
      <$> (o .:  "status")
      <*> (o .:  "last_status_change")
      <*> (o .:  "breakdown")

-- | ToJSON ProductStatus
instance A.ToJSON ProductStatus where
  toJSON ProductStatus {..} =
   _omitNulls
      [ "status" .= productStatusStatus
      , "last_status_change" .= productStatusLastStatusChange
      , "breakdown" .= productStatusBreakdown
      ]


-- | Construct a value of type 'ProductStatus' (by applying it's required fields, if any)
mkProductStatus
  :: E'Status2 -- ^ 'productStatusStatus': `HEALTHY`: the majority of requests are successful `DEGRADED`: only some requests are successful `DOWN`: all requests are failing
  -> Text -- ^ 'productStatusLastStatusChange': ISO 8601 formatted timestamp of the last status change for the institution.
  -> ProductStatusBreakdown -- ^ 'productStatusBreakdown'
  -> ProductStatus
mkProductStatus productStatusStatus productStatusLastStatusChange productStatusBreakdown =
  ProductStatus
  { productStatusStatus
  , productStatusLastStatusChange
  , productStatusBreakdown
  }

-- ** ProductStatusBreakdown
-- | ProductStatusBreakdown
-- StatusBreakdown
-- 
-- A detailed breakdown of the institution's performance for a request type. The values for `success`, `error_plaid`, and `error_institution` sum to 1.
data ProductStatusBreakdown = ProductStatusBreakdown
  { productStatusBreakdownSuccess :: !(Double) -- ^ /Required/ "success" - The percentage of login attempts that are successful, expressed as a decimal.
  , productStatusBreakdownErrorPlaid :: !(Double) -- ^ /Required/ "error_plaid" - The percentage of logins that are failing due to an internal Plaid issue, expressed as a decimal. 
  , productStatusBreakdownErrorInstitution :: !(Double) -- ^ /Required/ "error_institution" - The percentage of logins that are failing due to an issue in the institution&#39;s system, expressed as a decimal.
  , productStatusBreakdownRefreshInterval :: !(Maybe E'RefreshInterval) -- ^ "refresh_interval" - The &#x60;refresh_interval&#x60; may be &#x60;DELAYED&#x60; or &#x60;STOPPED&#x60; even when the success rate is high. This value is only returned for Transactions status breakdowns.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ProductStatusBreakdown
instance A.FromJSON ProductStatusBreakdown where
  parseJSON = A.withObject "ProductStatusBreakdown" $ \o ->
    ProductStatusBreakdown
      <$> (o .:  "success")
      <*> (o .:  "error_plaid")
      <*> (o .:  "error_institution")
      <*> (o .:? "refresh_interval")

-- | ToJSON ProductStatusBreakdown
instance A.ToJSON ProductStatusBreakdown where
  toJSON ProductStatusBreakdown {..} =
   _omitNulls
      [ "success" .= productStatusBreakdownSuccess
      , "error_plaid" .= productStatusBreakdownErrorPlaid
      , "error_institution" .= productStatusBreakdownErrorInstitution
      , "refresh_interval" .= productStatusBreakdownRefreshInterval
      ]


-- | Construct a value of type 'ProductStatusBreakdown' (by applying it's required fields, if any)
mkProductStatusBreakdown
  :: Double -- ^ 'productStatusBreakdownSuccess': The percentage of login attempts that are successful, expressed as a decimal.
  -> Double -- ^ 'productStatusBreakdownErrorPlaid': The percentage of logins that are failing due to an internal Plaid issue, expressed as a decimal. 
  -> Double -- ^ 'productStatusBreakdownErrorInstitution': The percentage of logins that are failing due to an issue in the institution's system, expressed as a decimal.
  -> ProductStatusBreakdown
mkProductStatusBreakdown productStatusBreakdownSuccess productStatusBreakdownErrorPlaid productStatusBreakdownErrorInstitution =
  ProductStatusBreakdown
  { productStatusBreakdownSuccess
  , productStatusBreakdownErrorPlaid
  , productStatusBreakdownErrorInstitution
  , productStatusBreakdownRefreshInterval = Nothing
  }

-- ** ProjectedIncomeSummaryFieldNumber
-- | ProjectedIncomeSummaryFieldNumber
data ProjectedIncomeSummaryFieldNumber = ProjectedIncomeSummaryFieldNumber
  { projectedIncomeSummaryFieldNumberValue :: !(Double) -- ^ /Required/ "value" - The value of the field.
  , projectedIncomeSummaryFieldNumberVerificationStatus :: !(VerificationStatus) -- ^ /Required/ "verification_status"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ProjectedIncomeSummaryFieldNumber
instance A.FromJSON ProjectedIncomeSummaryFieldNumber where
  parseJSON = A.withObject "ProjectedIncomeSummaryFieldNumber" $ \o ->
    ProjectedIncomeSummaryFieldNumber
      <$> (o .:  "value")
      <*> (o .:  "verification_status")

-- | ToJSON ProjectedIncomeSummaryFieldNumber
instance A.ToJSON ProjectedIncomeSummaryFieldNumber where
  toJSON ProjectedIncomeSummaryFieldNumber {..} =
   _omitNulls
      [ "value" .= projectedIncomeSummaryFieldNumberValue
      , "verification_status" .= projectedIncomeSummaryFieldNumberVerificationStatus
      ]


-- | Construct a value of type 'ProjectedIncomeSummaryFieldNumber' (by applying it's required fields, if any)
mkProjectedIncomeSummaryFieldNumber
  :: Double -- ^ 'projectedIncomeSummaryFieldNumberValue': The value of the field.
  -> VerificationStatus -- ^ 'projectedIncomeSummaryFieldNumberVerificationStatus'
  -> ProjectedIncomeSummaryFieldNumber
mkProjectedIncomeSummaryFieldNumber projectedIncomeSummaryFieldNumberValue projectedIncomeSummaryFieldNumberVerificationStatus =
  ProjectedIncomeSummaryFieldNumber
  { projectedIncomeSummaryFieldNumberValue
  , projectedIncomeSummaryFieldNumberVerificationStatus
  }

-- ** RecaptchaRequiredError
-- | RecaptchaRequiredError
-- Recaptcha_RequiredError
-- 
-- The request was flagged by Plaid's fraud system, and requires additional verification to ensure they are not a bot.
data RecaptchaRequiredError = RecaptchaRequiredError
  { recaptchaRequiredErrorErrorType :: !(Text) -- ^ /Required/ "error_type" - RECAPTCHA_ERROR
  , recaptchaRequiredErrorErrorCode :: !(Text) -- ^ /Required/ "error_code" - RECAPTCHA_REQUIRED
  , recaptchaRequiredErrorDisplayMessage :: !(Text) -- ^ /Required/ "display_message"
  , recaptchaRequiredErrorHttpCode :: !(Text) -- ^ /Required/ "http_code" - 400
  , recaptchaRequiredErrorLinkUserExperience :: !(Text) -- ^ /Required/ "link_user_experience" - Your user will be prompted to solve a Google reCAPTCHA challenge in the Link Recaptcha pane. If they solve the challenge successfully, the user&#39;s request is resubmitted and they are directed to the next Item creation step.
  , recaptchaRequiredErrorCommonCauses :: !(Text) -- ^ /Required/ "common_causes" - Plaid&#39;s fraud system detects abusive traffic and considers a variety of parameters throughout Item creation requests. When a request is considered risky or possibly fraudulent, Link presents a reCAPTCHA for the user to solve.
  , recaptchaRequiredErrorTroubleshootingSteps :: !(Text) -- ^ /Required/ "troubleshooting_steps" - Link will automatically guide your user through reCAPTCHA verification. As a general rule, we recommend instrumenting basic fraud monitoring to detect and protect your website from spam and abuse.  If your user cannot verify their session, please submit a Support ticket with the following identifiers: &#x60;link_session_id&#x60; or &#x60;request_id&#x60;
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RecaptchaRequiredError
instance A.FromJSON RecaptchaRequiredError where
  parseJSON = A.withObject "RecaptchaRequiredError" $ \o ->
    RecaptchaRequiredError
      <$> (o .:  "error_type")
      <*> (o .:  "error_code")
      <*> (o .:  "display_message")
      <*> (o .:  "http_code")
      <*> (o .:  "link_user_experience")
      <*> (o .:  "common_causes")
      <*> (o .:  "troubleshooting_steps")

-- | ToJSON RecaptchaRequiredError
instance A.ToJSON RecaptchaRequiredError where
  toJSON RecaptchaRequiredError {..} =
   _omitNulls
      [ "error_type" .= recaptchaRequiredErrorErrorType
      , "error_code" .= recaptchaRequiredErrorErrorCode
      , "display_message" .= recaptchaRequiredErrorDisplayMessage
      , "http_code" .= recaptchaRequiredErrorHttpCode
      , "link_user_experience" .= recaptchaRequiredErrorLinkUserExperience
      , "common_causes" .= recaptchaRequiredErrorCommonCauses
      , "troubleshooting_steps" .= recaptchaRequiredErrorTroubleshootingSteps
      ]


-- | Construct a value of type 'RecaptchaRequiredError' (by applying it's required fields, if any)
mkRecaptchaRequiredError
  :: Text -- ^ 'recaptchaRequiredErrorErrorType': RECAPTCHA_ERROR
  -> Text -- ^ 'recaptchaRequiredErrorErrorCode': RECAPTCHA_REQUIRED
  -> Text -- ^ 'recaptchaRequiredErrorDisplayMessage' 
  -> Text -- ^ 'recaptchaRequiredErrorHttpCode': 400
  -> Text -- ^ 'recaptchaRequiredErrorLinkUserExperience': Your user will be prompted to solve a Google reCAPTCHA challenge in the Link Recaptcha pane. If they solve the challenge successfully, the user's request is resubmitted and they are directed to the next Item creation step.
  -> Text -- ^ 'recaptchaRequiredErrorCommonCauses': Plaid's fraud system detects abusive traffic and considers a variety of parameters throughout Item creation requests. When a request is considered risky or possibly fraudulent, Link presents a reCAPTCHA for the user to solve.
  -> Text -- ^ 'recaptchaRequiredErrorTroubleshootingSteps': Link will automatically guide your user through reCAPTCHA verification. As a general rule, we recommend instrumenting basic fraud monitoring to detect and protect your website from spam and abuse.  If your user cannot verify their session, please submit a Support ticket with the following identifiers: `link_session_id` or `request_id`
  -> RecaptchaRequiredError
mkRecaptchaRequiredError recaptchaRequiredErrorErrorType recaptchaRequiredErrorErrorCode recaptchaRequiredErrorDisplayMessage recaptchaRequiredErrorHttpCode recaptchaRequiredErrorLinkUserExperience recaptchaRequiredErrorCommonCauses recaptchaRequiredErrorTroubleshootingSteps =
  RecaptchaRequiredError
  { recaptchaRequiredErrorErrorType
  , recaptchaRequiredErrorErrorCode
  , recaptchaRequiredErrorDisplayMessage
  , recaptchaRequiredErrorHttpCode
  , recaptchaRequiredErrorLinkUserExperience
  , recaptchaRequiredErrorCommonCauses
  , recaptchaRequiredErrorTroubleshootingSteps
  }

-- ** RecipientBACS
-- | RecipientBACS
-- RecipientBACS
-- 
-- An object containing a BACS account number and sort code. If an IBAN is not provided or if this recipient needs to accept domestic GBP-denominated payments, BACS data is required.
data RecipientBACS = RecipientBACS
  { recipientBACSAccount :: !(Maybe Text) -- ^ "account" - The account number of the account. Maximum of 10 characters.
  , recipientBACSSortCode :: !(Maybe Text) -- ^ "sort_code" - The 6-character sort code of the account.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RecipientBACS
instance A.FromJSON RecipientBACS where
  parseJSON = A.withObject "RecipientBACS" $ \o ->
    RecipientBACS
      <$> (o .:? "account")
      <*> (o .:? "sort_code")

-- | ToJSON RecipientBACS
instance A.ToJSON RecipientBACS where
  toJSON RecipientBACS {..} =
   _omitNulls
      [ "account" .= recipientBACSAccount
      , "sort_code" .= recipientBACSSortCode
      ]


-- | Construct a value of type 'RecipientBACS' (by applying it's required fields, if any)
mkRecipientBACS
  :: RecipientBACS
mkRecipientBACS =
  RecipientBACS
  { recipientBACSAccount = Nothing
  , recipientBACSSortCode = Nothing
  }

-- ** RemovedTransaction
-- | RemovedTransaction
-- RemovedTransaction
-- 
-- A representation of a removed transaction
data RemovedTransaction = RemovedTransaction
  { removedTransactionTransactionId :: !(Maybe Text) -- ^ "transaction_id" - The ID of the removed transaction.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RemovedTransaction
instance A.FromJSON RemovedTransaction where
  parseJSON = A.withObject "RemovedTransaction" $ \o ->
    RemovedTransaction
      <$> (o .:? "transaction_id")

-- | ToJSON RemovedTransaction
instance A.ToJSON RemovedTransaction where
  toJSON RemovedTransaction {..} =
   _omitNulls
      [ "transaction_id" .= removedTransactionTransactionId
      ]


-- | Construct a value of type 'RemovedTransaction' (by applying it's required fields, if any)
mkRemovedTransaction
  :: RemovedTransaction
mkRemovedTransaction =
  RemovedTransaction
  { removedTransactionTransactionId = Nothing
  }

-- ** SandboxBankTransferSimulateRequest
-- | SandboxBankTransferSimulateRequest
-- SandboxBankTransferSimulateRequest
-- 
-- SandboxBankTransferSimulateRequest defines the request schema for `/sandbox/bank_transfer/simulate`
data SandboxBankTransferSimulateRequest = SandboxBankTransferSimulateRequest
  { sandboxBankTransferSimulateRequestClientId :: !(Maybe Text) -- ^ "client_id" - Your Plaid API &#x60;client_id&#x60;.
  , sandboxBankTransferSimulateRequestSecret :: !(Maybe Text) -- ^ "secret" - Your Plaid API &#x60;secret&#x60;.
  , sandboxBankTransferSimulateRequestBankTransferId :: !(Text) -- ^ /Required/ "bank_transfer_id" - Plaid’s unique identifier for a bank transfer.
  , sandboxBankTransferSimulateRequestEventType :: !(Text) -- ^ /Required/ "event_type" - The asynchronous event to be simulated. May be: &#x60;posted&#x60;, &#x60;failed&#x60;, or &#x60;reversed&#x60;.  An error will be returned if the event type is incompatible with the current transfer status. Compatible status --&gt; event type transitions include:  &#x60;pending&#x60; --&gt; &#x60;failed&#x60;  &#x60;pending&#x60; --&gt; &#x60;posted&#x60;  &#x60;posted&#x60; --&gt; &#x60;reversed&#x60; 
  , sandboxBankTransferSimulateRequestFailureReason :: !(Maybe BankTransferFailure) -- ^ "failure_reason"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SandboxBankTransferSimulateRequest
instance A.FromJSON SandboxBankTransferSimulateRequest where
  parseJSON = A.withObject "SandboxBankTransferSimulateRequest" $ \o ->
    SandboxBankTransferSimulateRequest
      <$> (o .:? "client_id")
      <*> (o .:? "secret")
      <*> (o .:  "bank_transfer_id")
      <*> (o .:  "event_type")
      <*> (o .:? "failure_reason")

-- | ToJSON SandboxBankTransferSimulateRequest
instance A.ToJSON SandboxBankTransferSimulateRequest where
  toJSON SandboxBankTransferSimulateRequest {..} =
   _omitNulls
      [ "client_id" .= sandboxBankTransferSimulateRequestClientId
      , "secret" .= sandboxBankTransferSimulateRequestSecret
      , "bank_transfer_id" .= sandboxBankTransferSimulateRequestBankTransferId
      , "event_type" .= sandboxBankTransferSimulateRequestEventType
      , "failure_reason" .= sandboxBankTransferSimulateRequestFailureReason
      ]


-- | Construct a value of type 'SandboxBankTransferSimulateRequest' (by applying it's required fields, if any)
mkSandboxBankTransferSimulateRequest
  :: Text -- ^ 'sandboxBankTransferSimulateRequestBankTransferId': Plaid’s unique identifier for a bank transfer.
  -> Text -- ^ 'sandboxBankTransferSimulateRequestEventType': The asynchronous event to be simulated. May be: `posted`, `failed`, or `reversed`.  An error will be returned if the event type is incompatible with the current transfer status. Compatible status --> event type transitions include:  `pending` --> `failed`  `pending` --> `posted`  `posted` --> `reversed` 
  -> SandboxBankTransferSimulateRequest
mkSandboxBankTransferSimulateRequest sandboxBankTransferSimulateRequestBankTransferId sandboxBankTransferSimulateRequestEventType =
  SandboxBankTransferSimulateRequest
  { sandboxBankTransferSimulateRequestClientId = Nothing
  , sandboxBankTransferSimulateRequestSecret = Nothing
  , sandboxBankTransferSimulateRequestBankTransferId
  , sandboxBankTransferSimulateRequestEventType
  , sandboxBankTransferSimulateRequestFailureReason = Nothing
  }

-- ** SandboxBankTransferSimulateResponse
-- | SandboxBankTransferSimulateResponse
-- SandboxBankTransferSimulateResponse
-- 
-- SandboxBankTransferSimulateResponse defines the response schema for `/sandbox/bank_transfer/simulate`
data SandboxBankTransferSimulateResponse = SandboxBankTransferSimulateResponse
  { sandboxBankTransferSimulateResponseRequestId :: !(Text) -- ^ /Required/ "request_id" - A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SandboxBankTransferSimulateResponse
instance A.FromJSON SandboxBankTransferSimulateResponse where
  parseJSON = A.withObject "SandboxBankTransferSimulateResponse" $ \o ->
    SandboxBankTransferSimulateResponse
      <$> (o .:  "request_id")

-- | ToJSON SandboxBankTransferSimulateResponse
instance A.ToJSON SandboxBankTransferSimulateResponse where
  toJSON SandboxBankTransferSimulateResponse {..} =
   _omitNulls
      [ "request_id" .= sandboxBankTransferSimulateResponseRequestId
      ]


-- | Construct a value of type 'SandboxBankTransferSimulateResponse' (by applying it's required fields, if any)
mkSandboxBankTransferSimulateResponse
  :: Text -- ^ 'sandboxBankTransferSimulateResponseRequestId': A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  -> SandboxBankTransferSimulateResponse
mkSandboxBankTransferSimulateResponse sandboxBankTransferSimulateResponseRequestId =
  SandboxBankTransferSimulateResponse
  { sandboxBankTransferSimulateResponseRequestId
  }

-- ** SandboxItemFireWebhookRequest
-- | SandboxItemFireWebhookRequest
-- SandboxItemFireWebhookRequest defines the request schema for `/sandbox/item/fire_webhook`
data SandboxItemFireWebhookRequest = SandboxItemFireWebhookRequest
  { sandboxItemFireWebhookRequestClientId :: !(Maybe Text) -- ^ "client_id" - Your Plaid API &#x60;client_id&#x60;.
  , sandboxItemFireWebhookRequestSecret :: !(Maybe Text) -- ^ "secret" - Your Plaid API &#x60;secret&#x60;.
  , sandboxItemFireWebhookRequestAccessToken :: !(AccessToken) -- ^ /Required/ "access_token" - The access token associated with the Item data is being requested for.
  , sandboxItemFireWebhookRequestWebhookCode :: !(Maybe E'WebhookCode) -- ^ "webhook_code" - The following values for &#x60;webhook_code&#x60; are supported:  * &#x60;DEFAULT_UPDATE&#x60;
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SandboxItemFireWebhookRequest
instance A.FromJSON SandboxItemFireWebhookRequest where
  parseJSON = A.withObject "SandboxItemFireWebhookRequest" $ \o ->
    SandboxItemFireWebhookRequest
      <$> (o .:? "client_id")
      <*> (o .:? "secret")
      <*> (o .:  "access_token")
      <*> (o .:? "webhook_code")

-- | ToJSON SandboxItemFireWebhookRequest
instance A.ToJSON SandboxItemFireWebhookRequest where
  toJSON SandboxItemFireWebhookRequest {..} =
   _omitNulls
      [ "client_id" .= sandboxItemFireWebhookRequestClientId
      , "secret" .= sandboxItemFireWebhookRequestSecret
      , "access_token" .= sandboxItemFireWebhookRequestAccessToken
      , "webhook_code" .= sandboxItemFireWebhookRequestWebhookCode
      ]


-- | Construct a value of type 'SandboxItemFireWebhookRequest' (by applying it's required fields, if any)
mkSandboxItemFireWebhookRequest
  :: AccessToken -- ^ 'sandboxItemFireWebhookRequestAccessToken': The access token associated with the Item data is being requested for.
  -> SandboxItemFireWebhookRequest
mkSandboxItemFireWebhookRequest sandboxItemFireWebhookRequestAccessToken =
  SandboxItemFireWebhookRequest
  { sandboxItemFireWebhookRequestClientId = Nothing
  , sandboxItemFireWebhookRequestSecret = Nothing
  , sandboxItemFireWebhookRequestAccessToken
  , sandboxItemFireWebhookRequestWebhookCode = Nothing
  }

-- ** SandboxItemFireWebhookResponse
-- | SandboxItemFireWebhookResponse
-- SandboxItemFireWebhookResponse defines the response schema for `/sandbox/item/fire_webhook`
data SandboxItemFireWebhookResponse = SandboxItemFireWebhookResponse
  { sandboxItemFireWebhookResponseWebhookFired :: !(Bool) -- ^ /Required/ "webhook_fired" - Value is &#x60;true&#x60;  if the test&#x60; webhook_code&#x60;  was successfully fired.
  , sandboxItemFireWebhookResponseRequestId :: !(Text) -- ^ /Required/ "request_id" - A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SandboxItemFireWebhookResponse
instance A.FromJSON SandboxItemFireWebhookResponse where
  parseJSON = A.withObject "SandboxItemFireWebhookResponse" $ \o ->
    SandboxItemFireWebhookResponse
      <$> (o .:  "webhook_fired")
      <*> (o .:  "request_id")

-- | ToJSON SandboxItemFireWebhookResponse
instance A.ToJSON SandboxItemFireWebhookResponse where
  toJSON SandboxItemFireWebhookResponse {..} =
   _omitNulls
      [ "webhook_fired" .= sandboxItemFireWebhookResponseWebhookFired
      , "request_id" .= sandboxItemFireWebhookResponseRequestId
      ]


-- | Construct a value of type 'SandboxItemFireWebhookResponse' (by applying it's required fields, if any)
mkSandboxItemFireWebhookResponse
  :: Bool -- ^ 'sandboxItemFireWebhookResponseWebhookFired': Value is `true`  if the test` webhook_code`  was successfully fired.
  -> Text -- ^ 'sandboxItemFireWebhookResponseRequestId': A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  -> SandboxItemFireWebhookResponse
mkSandboxItemFireWebhookResponse sandboxItemFireWebhookResponseWebhookFired sandboxItemFireWebhookResponseRequestId =
  SandboxItemFireWebhookResponse
  { sandboxItemFireWebhookResponseWebhookFired
  , sandboxItemFireWebhookResponseRequestId
  }

-- ** SandboxItemResetLoginRequest
-- | SandboxItemResetLoginRequest
-- SandboxItemResetLoginRequest defines the request schema for `/sandbox/item/reset_login`
data SandboxItemResetLoginRequest = SandboxItemResetLoginRequest
  { sandboxItemResetLoginRequestClientId :: !(Maybe Text) -- ^ "client_id" - Your Plaid API &#x60;client_id&#x60;.
  , sandboxItemResetLoginRequestSecret :: !(Maybe Text) -- ^ "secret" - Your Plaid API &#x60;secret&#x60;.
  , sandboxItemResetLoginRequestAccessToken :: !(AccessToken) -- ^ /Required/ "access_token" - The access token associated with the Item data is being requested for.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SandboxItemResetLoginRequest
instance A.FromJSON SandboxItemResetLoginRequest where
  parseJSON = A.withObject "SandboxItemResetLoginRequest" $ \o ->
    SandboxItemResetLoginRequest
      <$> (o .:? "client_id")
      <*> (o .:? "secret")
      <*> (o .:  "access_token")

-- | ToJSON SandboxItemResetLoginRequest
instance A.ToJSON SandboxItemResetLoginRequest where
  toJSON SandboxItemResetLoginRequest {..} =
   _omitNulls
      [ "client_id" .= sandboxItemResetLoginRequestClientId
      , "secret" .= sandboxItemResetLoginRequestSecret
      , "access_token" .= sandboxItemResetLoginRequestAccessToken
      ]


-- | Construct a value of type 'SandboxItemResetLoginRequest' (by applying it's required fields, if any)
mkSandboxItemResetLoginRequest
  :: AccessToken -- ^ 'sandboxItemResetLoginRequestAccessToken': The access token associated with the Item data is being requested for.
  -> SandboxItemResetLoginRequest
mkSandboxItemResetLoginRequest sandboxItemResetLoginRequestAccessToken =
  SandboxItemResetLoginRequest
  { sandboxItemResetLoginRequestClientId = Nothing
  , sandboxItemResetLoginRequestSecret = Nothing
  , sandboxItemResetLoginRequestAccessToken
  }

-- ** SandboxItemResetLoginResponse
-- | SandboxItemResetLoginResponse
-- SandboxItemResetLoginResponse defines the response schema for `/sandbox/item/reset_login`
data SandboxItemResetLoginResponse = SandboxItemResetLoginResponse
  { sandboxItemResetLoginResponseResetLogin :: !(Bool) -- ^ /Required/ "reset_login" - &#x60;true&#x60; if the call succeeded
  , sandboxItemResetLoginResponseRequestId :: !(Text) -- ^ /Required/ "request_id" - A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SandboxItemResetLoginResponse
instance A.FromJSON SandboxItemResetLoginResponse where
  parseJSON = A.withObject "SandboxItemResetLoginResponse" $ \o ->
    SandboxItemResetLoginResponse
      <$> (o .:  "reset_login")
      <*> (o .:  "request_id")

-- | ToJSON SandboxItemResetLoginResponse
instance A.ToJSON SandboxItemResetLoginResponse where
  toJSON SandboxItemResetLoginResponse {..} =
   _omitNulls
      [ "reset_login" .= sandboxItemResetLoginResponseResetLogin
      , "request_id" .= sandboxItemResetLoginResponseRequestId
      ]


-- | Construct a value of type 'SandboxItemResetLoginResponse' (by applying it's required fields, if any)
mkSandboxItemResetLoginResponse
  :: Bool -- ^ 'sandboxItemResetLoginResponseResetLogin': `true` if the call succeeded
  -> Text -- ^ 'sandboxItemResetLoginResponseRequestId': A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  -> SandboxItemResetLoginResponse
mkSandboxItemResetLoginResponse sandboxItemResetLoginResponseResetLogin sandboxItemResetLoginResponseRequestId =
  SandboxItemResetLoginResponse
  { sandboxItemResetLoginResponseResetLogin
  , sandboxItemResetLoginResponseRequestId
  }

-- ** SandboxItemSetVerificationStatusRequest
-- | SandboxItemSetVerificationStatusRequest
-- SandboxItemSetVerificationStatusRequest defines the request schema for `/sandbox/item/set_verification_status`
data SandboxItemSetVerificationStatusRequest = SandboxItemSetVerificationStatusRequest
  { sandboxItemSetVerificationStatusRequestClientId :: !(Maybe Text) -- ^ "client_id" - Your Plaid API &#x60;client_id&#x60;.
  , sandboxItemSetVerificationStatusRequestSecret :: !(Maybe Text) -- ^ "secret" - Your Plaid API &#x60;secret&#x60;.
  , sandboxItemSetVerificationStatusRequestAccessToken :: !(AccessToken) -- ^ /Required/ "access_token" - The access token associated with the Item data is being requested for.
  , sandboxItemSetVerificationStatusRequestAccountId :: !(Text) -- ^ /Required/ "account_id" - The &#x60;account_id&#x60; of the account whose verification status is to be modified
  , sandboxItemSetVerificationStatusRequestVerificationStatus :: !(E'VerificationStatus) -- ^ /Required/ "verification_status" - The verification status to set the account to.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SandboxItemSetVerificationStatusRequest
instance A.FromJSON SandboxItemSetVerificationStatusRequest where
  parseJSON = A.withObject "SandboxItemSetVerificationStatusRequest" $ \o ->
    SandboxItemSetVerificationStatusRequest
      <$> (o .:? "client_id")
      <*> (o .:? "secret")
      <*> (o .:  "access_token")
      <*> (o .:  "account_id")
      <*> (o .:  "verification_status")

-- | ToJSON SandboxItemSetVerificationStatusRequest
instance A.ToJSON SandboxItemSetVerificationStatusRequest where
  toJSON SandboxItemSetVerificationStatusRequest {..} =
   _omitNulls
      [ "client_id" .= sandboxItemSetVerificationStatusRequestClientId
      , "secret" .= sandboxItemSetVerificationStatusRequestSecret
      , "access_token" .= sandboxItemSetVerificationStatusRequestAccessToken
      , "account_id" .= sandboxItemSetVerificationStatusRequestAccountId
      , "verification_status" .= sandboxItemSetVerificationStatusRequestVerificationStatus
      ]


-- | Construct a value of type 'SandboxItemSetVerificationStatusRequest' (by applying it's required fields, if any)
mkSandboxItemSetVerificationStatusRequest
  :: AccessToken -- ^ 'sandboxItemSetVerificationStatusRequestAccessToken': The access token associated with the Item data is being requested for.
  -> Text -- ^ 'sandboxItemSetVerificationStatusRequestAccountId': The `account_id` of the account whose verification status is to be modified
  -> E'VerificationStatus -- ^ 'sandboxItemSetVerificationStatusRequestVerificationStatus': The verification status to set the account to.
  -> SandboxItemSetVerificationStatusRequest
mkSandboxItemSetVerificationStatusRequest sandboxItemSetVerificationStatusRequestAccessToken sandboxItemSetVerificationStatusRequestAccountId sandboxItemSetVerificationStatusRequestVerificationStatus =
  SandboxItemSetVerificationStatusRequest
  { sandboxItemSetVerificationStatusRequestClientId = Nothing
  , sandboxItemSetVerificationStatusRequestSecret = Nothing
  , sandboxItemSetVerificationStatusRequestAccessToken
  , sandboxItemSetVerificationStatusRequestAccountId
  , sandboxItemSetVerificationStatusRequestVerificationStatus
  }

-- ** SandboxItemSetVerificationStatusResponse
-- | SandboxItemSetVerificationStatusResponse
-- SandboxItemSetVerificationStatusResponse defines the response schema for `/sandbox/item/set_verification_status`
data SandboxItemSetVerificationStatusResponse = SandboxItemSetVerificationStatusResponse
  { sandboxItemSetVerificationStatusResponseRequestId :: !(Text) -- ^ /Required/ "request_id" - A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SandboxItemSetVerificationStatusResponse
instance A.FromJSON SandboxItemSetVerificationStatusResponse where
  parseJSON = A.withObject "SandboxItemSetVerificationStatusResponse" $ \o ->
    SandboxItemSetVerificationStatusResponse
      <$> (o .:  "request_id")

-- | ToJSON SandboxItemSetVerificationStatusResponse
instance A.ToJSON SandboxItemSetVerificationStatusResponse where
  toJSON SandboxItemSetVerificationStatusResponse {..} =
   _omitNulls
      [ "request_id" .= sandboxItemSetVerificationStatusResponseRequestId
      ]


-- | Construct a value of type 'SandboxItemSetVerificationStatusResponse' (by applying it's required fields, if any)
mkSandboxItemSetVerificationStatusResponse
  :: Text -- ^ 'sandboxItemSetVerificationStatusResponseRequestId': A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  -> SandboxItemSetVerificationStatusResponse
mkSandboxItemSetVerificationStatusResponse sandboxItemSetVerificationStatusResponseRequestId =
  SandboxItemSetVerificationStatusResponse
  { sandboxItemSetVerificationStatusResponseRequestId
  }

-- ** SandboxProcessorTokenCreateRequest
-- | SandboxProcessorTokenCreateRequest
data SandboxProcessorTokenCreateRequest = SandboxProcessorTokenCreateRequest
  { sandboxProcessorTokenCreateRequestClientId :: !(Maybe Text) -- ^ "client_id" - Your Plaid API &#x60;client_id&#x60;.
  , sandboxProcessorTokenCreateRequestSecret :: !(Maybe Text) -- ^ "secret" - Your Plaid API &#x60;secret&#x60;.
  , sandboxProcessorTokenCreateRequestInstitutionId :: !(Text) -- ^ /Required/ "institution_id" - The ID of the institution the Item will be associated with
  , sandboxProcessorTokenCreateRequestOptions :: !(Maybe SandboxProcessorTokenCreateRequestOptions) -- ^ "options"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SandboxProcessorTokenCreateRequest
instance A.FromJSON SandboxProcessorTokenCreateRequest where
  parseJSON = A.withObject "SandboxProcessorTokenCreateRequest" $ \o ->
    SandboxProcessorTokenCreateRequest
      <$> (o .:? "client_id")
      <*> (o .:? "secret")
      <*> (o .:  "institution_id")
      <*> (o .:? "options")

-- | ToJSON SandboxProcessorTokenCreateRequest
instance A.ToJSON SandboxProcessorTokenCreateRequest where
  toJSON SandboxProcessorTokenCreateRequest {..} =
   _omitNulls
      [ "client_id" .= sandboxProcessorTokenCreateRequestClientId
      , "secret" .= sandboxProcessorTokenCreateRequestSecret
      , "institution_id" .= sandboxProcessorTokenCreateRequestInstitutionId
      , "options" .= sandboxProcessorTokenCreateRequestOptions
      ]


-- | Construct a value of type 'SandboxProcessorTokenCreateRequest' (by applying it's required fields, if any)
mkSandboxProcessorTokenCreateRequest
  :: Text -- ^ 'sandboxProcessorTokenCreateRequestInstitutionId': The ID of the institution the Item will be associated with
  -> SandboxProcessorTokenCreateRequest
mkSandboxProcessorTokenCreateRequest sandboxProcessorTokenCreateRequestInstitutionId =
  SandboxProcessorTokenCreateRequest
  { sandboxProcessorTokenCreateRequestClientId = Nothing
  , sandboxProcessorTokenCreateRequestSecret = Nothing
  , sandboxProcessorTokenCreateRequestInstitutionId
  , sandboxProcessorTokenCreateRequestOptions = Nothing
  }

-- ** SandboxProcessorTokenCreateRequestOptions
-- | SandboxProcessorTokenCreateRequestOptions
-- An optional set of options to be used when configuring the Item. If specified, must not be `null`.
data SandboxProcessorTokenCreateRequestOptions = SandboxProcessorTokenCreateRequestOptions
  { sandboxProcessorTokenCreateRequestOptionsOverrideUsername :: !(Maybe Text) -- ^ "override_username" - Test username to use for the creation of the Sandbox Item. Default value is &#x60;user_good&#x60;.
  , sandboxProcessorTokenCreateRequestOptionsOverridePassword :: !(Maybe Text) -- ^ "override_password" - Test password to use for the creation of the Sandbox Item. Default value is &#x60;pass_good&#x60;.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SandboxProcessorTokenCreateRequestOptions
instance A.FromJSON SandboxProcessorTokenCreateRequestOptions where
  parseJSON = A.withObject "SandboxProcessorTokenCreateRequestOptions" $ \o ->
    SandboxProcessorTokenCreateRequestOptions
      <$> (o .:? "override_username")
      <*> (o .:? "override_password")

-- | ToJSON SandboxProcessorTokenCreateRequestOptions
instance A.ToJSON SandboxProcessorTokenCreateRequestOptions where
  toJSON SandboxProcessorTokenCreateRequestOptions {..} =
   _omitNulls
      [ "override_username" .= sandboxProcessorTokenCreateRequestOptionsOverrideUsername
      , "override_password" .= sandboxProcessorTokenCreateRequestOptionsOverridePassword
      ]


-- | Construct a value of type 'SandboxProcessorTokenCreateRequestOptions' (by applying it's required fields, if any)
mkSandboxProcessorTokenCreateRequestOptions
  :: SandboxProcessorTokenCreateRequestOptions
mkSandboxProcessorTokenCreateRequestOptions =
  SandboxProcessorTokenCreateRequestOptions
  { sandboxProcessorTokenCreateRequestOptionsOverrideUsername = Nothing
  , sandboxProcessorTokenCreateRequestOptionsOverridePassword = Nothing
  }

-- ** SandboxProcessorTokenCreateResponse
-- | SandboxProcessorTokenCreateResponse
data SandboxProcessorTokenCreateResponse = SandboxProcessorTokenCreateResponse
  { sandboxProcessorTokenCreateResponseProcessorToken :: !(Text) -- ^ /Required/ "processor_token" - A processor token that can be used to call the &#x60;/processor/&#x60; endpoints.
  , sandboxProcessorTokenCreateResponseRequestId :: !(Text) -- ^ /Required/ "request_id" - A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SandboxProcessorTokenCreateResponse
instance A.FromJSON SandboxProcessorTokenCreateResponse where
  parseJSON = A.withObject "SandboxProcessorTokenCreateResponse" $ \o ->
    SandboxProcessorTokenCreateResponse
      <$> (o .:  "processor_token")
      <*> (o .:  "request_id")

-- | ToJSON SandboxProcessorTokenCreateResponse
instance A.ToJSON SandboxProcessorTokenCreateResponse where
  toJSON SandboxProcessorTokenCreateResponse {..} =
   _omitNulls
      [ "processor_token" .= sandboxProcessorTokenCreateResponseProcessorToken
      , "request_id" .= sandboxProcessorTokenCreateResponseRequestId
      ]


-- | Construct a value of type 'SandboxProcessorTokenCreateResponse' (by applying it's required fields, if any)
mkSandboxProcessorTokenCreateResponse
  :: Text -- ^ 'sandboxProcessorTokenCreateResponseProcessorToken': A processor token that can be used to call the `/processor/` endpoints.
  -> Text -- ^ 'sandboxProcessorTokenCreateResponseRequestId': A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  -> SandboxProcessorTokenCreateResponse
mkSandboxProcessorTokenCreateResponse sandboxProcessorTokenCreateResponseProcessorToken sandboxProcessorTokenCreateResponseRequestId =
  SandboxProcessorTokenCreateResponse
  { sandboxProcessorTokenCreateResponseProcessorToken
  , sandboxProcessorTokenCreateResponseRequestId
  }

-- ** SandboxPublicTokenCreateRequest
-- | SandboxPublicTokenCreateRequest
-- SandboxPublicTokenCreateRequest defines the request schema for `/sandbox/public_token/create`
data SandboxPublicTokenCreateRequest = SandboxPublicTokenCreateRequest
  { sandboxPublicTokenCreateRequestClientId :: !(Maybe Text) -- ^ "client_id" - Your Plaid API &#x60;client_id&#x60;.
  , sandboxPublicTokenCreateRequestSecret :: !(Maybe Text) -- ^ "secret" - Your Plaid API &#x60;secret&#x60;.
  , sandboxPublicTokenCreateRequestInstitutionId :: !(Text) -- ^ /Required/ "institution_id" - The ID of the institution the Item will be associated with
  , sandboxPublicTokenCreateRequestInitialProducts :: !([Products]) -- ^ /Required/ "initial_products" - The products to initially pull for the Item. May be any products that the specified &#x60;institution_id&#x60;  supports. This array may not be empty.
  , sandboxPublicTokenCreateRequestOptions :: !(Maybe SandboxPublicTokenCreateRequestOptions) -- ^ "options"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SandboxPublicTokenCreateRequest
instance A.FromJSON SandboxPublicTokenCreateRequest where
  parseJSON = A.withObject "SandboxPublicTokenCreateRequest" $ \o ->
    SandboxPublicTokenCreateRequest
      <$> (o .:? "client_id")
      <*> (o .:? "secret")
      <*> (o .:  "institution_id")
      <*> (o .:  "initial_products")
      <*> (o .:? "options")

-- | ToJSON SandboxPublicTokenCreateRequest
instance A.ToJSON SandboxPublicTokenCreateRequest where
  toJSON SandboxPublicTokenCreateRequest {..} =
   _omitNulls
      [ "client_id" .= sandboxPublicTokenCreateRequestClientId
      , "secret" .= sandboxPublicTokenCreateRequestSecret
      , "institution_id" .= sandboxPublicTokenCreateRequestInstitutionId
      , "initial_products" .= sandboxPublicTokenCreateRequestInitialProducts
      , "options" .= sandboxPublicTokenCreateRequestOptions
      ]


-- | Construct a value of type 'SandboxPublicTokenCreateRequest' (by applying it's required fields, if any)
mkSandboxPublicTokenCreateRequest
  :: Text -- ^ 'sandboxPublicTokenCreateRequestInstitutionId': The ID of the institution the Item will be associated with
  -> [Products] -- ^ 'sandboxPublicTokenCreateRequestInitialProducts': The products to initially pull for the Item. May be any products that the specified `institution_id`  supports. This array may not be empty.
  -> SandboxPublicTokenCreateRequest
mkSandboxPublicTokenCreateRequest sandboxPublicTokenCreateRequestInstitutionId sandboxPublicTokenCreateRequestInitialProducts =
  SandboxPublicTokenCreateRequest
  { sandboxPublicTokenCreateRequestClientId = Nothing
  , sandboxPublicTokenCreateRequestSecret = Nothing
  , sandboxPublicTokenCreateRequestInstitutionId
  , sandboxPublicTokenCreateRequestInitialProducts
  , sandboxPublicTokenCreateRequestOptions = Nothing
  }

-- ** SandboxPublicTokenCreateRequestOptions
-- | SandboxPublicTokenCreateRequestOptions
-- An optional set of options to be used when configuring the Item. If specified, must not be `null`.
data SandboxPublicTokenCreateRequestOptions = SandboxPublicTokenCreateRequestOptions
  { sandboxPublicTokenCreateRequestOptionsWebhook :: !(Maybe Text) -- ^ "webhook" - Specify a webhook to associate with the new Item.
  , sandboxPublicTokenCreateRequestOptionsOverrideUsername :: !(Maybe Text) -- ^ "override_username" - Test username to use for the creation of the Sandbox Item. Default value is &#x60;user_good&#x60;.
  , sandboxPublicTokenCreateRequestOptionsOverridePassword :: !(Maybe Text) -- ^ "override_password" - Test password to use for the creation of the Sandbox Item. Default value is &#x60;pass_good&#x60;.
  , sandboxPublicTokenCreateRequestOptionsTransactions :: !(Maybe SandboxPublicTokenCreateRequestOptionsTransactions) -- ^ "transactions"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SandboxPublicTokenCreateRequestOptions
instance A.FromJSON SandboxPublicTokenCreateRequestOptions where
  parseJSON = A.withObject "SandboxPublicTokenCreateRequestOptions" $ \o ->
    SandboxPublicTokenCreateRequestOptions
      <$> (o .:? "webhook")
      <*> (o .:? "override_username")
      <*> (o .:? "override_password")
      <*> (o .:? "transactions")

-- | ToJSON SandboxPublicTokenCreateRequestOptions
instance A.ToJSON SandboxPublicTokenCreateRequestOptions where
  toJSON SandboxPublicTokenCreateRequestOptions {..} =
   _omitNulls
      [ "webhook" .= sandboxPublicTokenCreateRequestOptionsWebhook
      , "override_username" .= sandboxPublicTokenCreateRequestOptionsOverrideUsername
      , "override_password" .= sandboxPublicTokenCreateRequestOptionsOverridePassword
      , "transactions" .= sandboxPublicTokenCreateRequestOptionsTransactions
      ]


-- | Construct a value of type 'SandboxPublicTokenCreateRequestOptions' (by applying it's required fields, if any)
mkSandboxPublicTokenCreateRequestOptions
  :: SandboxPublicTokenCreateRequestOptions
mkSandboxPublicTokenCreateRequestOptions =
  SandboxPublicTokenCreateRequestOptions
  { sandboxPublicTokenCreateRequestOptionsWebhook = Nothing
  , sandboxPublicTokenCreateRequestOptionsOverrideUsername = Nothing
  , sandboxPublicTokenCreateRequestOptionsOverridePassword = Nothing
  , sandboxPublicTokenCreateRequestOptionsTransactions = Nothing
  }

-- ** SandboxPublicTokenCreateRequestOptionsTransactions
-- | SandboxPublicTokenCreateRequestOptionsTransactions
-- SandboxPublicTokenCreateRequestOptionsTransactions is an optional set of corresponding to transactions options.
data SandboxPublicTokenCreateRequestOptionsTransactions = SandboxPublicTokenCreateRequestOptionsTransactions
  { sandboxPublicTokenCreateRequestOptionsTransactionsStartDate :: !(Maybe Text) -- ^ "start_date" - The earliest date for which to fetch transaction history. Dates should be formatted as YYYY-MM-DD.
  , sandboxPublicTokenCreateRequestOptionsTransactionsEndDate :: !(Maybe Text) -- ^ "end_date" - The most recent date for which to fetch transaction history. Dates should be formatted as YYYY-MM-DD.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SandboxPublicTokenCreateRequestOptionsTransactions
instance A.FromJSON SandboxPublicTokenCreateRequestOptionsTransactions where
  parseJSON = A.withObject "SandboxPublicTokenCreateRequestOptionsTransactions" $ \o ->
    SandboxPublicTokenCreateRequestOptionsTransactions
      <$> (o .:? "start_date")
      <*> (o .:? "end_date")

-- | ToJSON SandboxPublicTokenCreateRequestOptionsTransactions
instance A.ToJSON SandboxPublicTokenCreateRequestOptionsTransactions where
  toJSON SandboxPublicTokenCreateRequestOptionsTransactions {..} =
   _omitNulls
      [ "start_date" .= sandboxPublicTokenCreateRequestOptionsTransactionsStartDate
      , "end_date" .= sandboxPublicTokenCreateRequestOptionsTransactionsEndDate
      ]


-- | Construct a value of type 'SandboxPublicTokenCreateRequestOptionsTransactions' (by applying it's required fields, if any)
mkSandboxPublicTokenCreateRequestOptionsTransactions
  :: SandboxPublicTokenCreateRequestOptionsTransactions
mkSandboxPublicTokenCreateRequestOptionsTransactions =
  SandboxPublicTokenCreateRequestOptionsTransactions
  { sandboxPublicTokenCreateRequestOptionsTransactionsStartDate = Nothing
  , sandboxPublicTokenCreateRequestOptionsTransactionsEndDate = Nothing
  }

-- ** SandboxPublicTokenCreateResponse
-- | SandboxPublicTokenCreateResponse
-- SandboxPublicTokenCreateResponse defines the response schema for `/sandbox/public_token/create`
data SandboxPublicTokenCreateResponse = SandboxPublicTokenCreateResponse
  { sandboxPublicTokenCreateResponsePublicToken :: !(Text) -- ^ /Required/ "public_token" - A public token that can be exchanged for an access token using &#x60;/item/public_token/exchange&#x60;
  , sandboxPublicTokenCreateResponseRequestId :: !(Text) -- ^ /Required/ "request_id" - A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SandboxPublicTokenCreateResponse
instance A.FromJSON SandboxPublicTokenCreateResponse where
  parseJSON = A.withObject "SandboxPublicTokenCreateResponse" $ \o ->
    SandboxPublicTokenCreateResponse
      <$> (o .:  "public_token")
      <*> (o .:  "request_id")

-- | ToJSON SandboxPublicTokenCreateResponse
instance A.ToJSON SandboxPublicTokenCreateResponse where
  toJSON SandboxPublicTokenCreateResponse {..} =
   _omitNulls
      [ "public_token" .= sandboxPublicTokenCreateResponsePublicToken
      , "request_id" .= sandboxPublicTokenCreateResponseRequestId
      ]


-- | Construct a value of type 'SandboxPublicTokenCreateResponse' (by applying it's required fields, if any)
mkSandboxPublicTokenCreateResponse
  :: Text -- ^ 'sandboxPublicTokenCreateResponsePublicToken': A public token that can be exchanged for an access token using `/item/public_token/exchange`
  -> Text -- ^ 'sandboxPublicTokenCreateResponseRequestId': A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  -> SandboxPublicTokenCreateResponse
mkSandboxPublicTokenCreateResponse sandboxPublicTokenCreateResponsePublicToken sandboxPublicTokenCreateResponseRequestId =
  SandboxPublicTokenCreateResponse
  { sandboxPublicTokenCreateResponsePublicToken
  , sandboxPublicTokenCreateResponseRequestId
  }

-- ** Security
-- | Security
-- Security
-- 
-- Contains details about a security
data Security = Security
  { securitySecurityId :: !(Text) -- ^ /Required/ "security_id" - A unique, Plaid-specific identifier for the security, used to associate securities with holdings. Like all Plaid identifiers, the &#x60;security_id&#x60; is case sensitive.
  , securityIsin :: !(Maybe Text) -- ^ "isin" - 12-character ISIN, a globally unique securities identifier.
  , securityCusip :: !(Maybe Text) -- ^ "cusip" - 9-character CUSIP, an identifier assigned to North American securities.
  , securitySedol :: !(Maybe Text) -- ^ "sedol" - 7-character SEDOL, an identifier assigned to securities in the UK.
  , securityInstitutionSecurityId :: !(Maybe Text) -- ^ "institution_security_id" - An identifier given to the security by the institution
  , securityInstitutionId :: !(Maybe Text) -- ^ "institution_id" - If &#x60;institution_security_id&#x60; is present, this field indicates the Plaid &#x60;institution_id&#x60; of the institution to whom the identifier belongs.
  , securityProxySecurityId :: !(Maybe Text) -- ^ "proxy_security_id" - In certain cases, Plaid will provide the ID of another security whose performance resembles this security, typically when the original security has low volume, or when a private security can be modeled with a publicly traded security.
  , securityName :: !(Maybe Text) -- ^ "name" - A descriptive name for the security, suitable for display.
  , securityTickerSymbol :: !(Maybe Text) -- ^ "ticker_symbol" - The security’s trading symbol for publicly traded securities, and otherwise a short identifier if available.
  , securityIsCashEquivalent :: !(Maybe Bool) -- ^ "is_cash_equivalent" - Indicates that a security is a highly liquid asset and can be treated like cash.
  , securityType :: !(Text) -- ^ /Required/ "type" - The security type of the holding. Valid security types are:  &#x60;cash&#x60;: Cash, currency, and money market funds  &#x60;derivative&#x60;: Options, warrants, and other derivative instruments  &#x60;equity&#x60;: Domestic and foreign equities  &#x60;etf&#x60;: Multi-asset exchange-traded investment funds  &#x60;fixed income&#x60;: Bonds and certificates of deposit (CDs)  &#x60;loan&#x60;: Loans and loan receivables.  &#x60;mutual fund&#x60;: Open- and closed-end vehicles pooling funds of multiple investors.  &#x60;other&#x60;: Unknown or other investment types
  , securityClosePrice :: !(Maybe Double) -- ^ "close_price" - Price of the security at the close of the previous trading session. &#x60;null&#x60; for non-public securities.
  , securityClosePriceAsOf :: !(Maybe Text) -- ^ "close_price_as_of" - Date for which &#x60;close_price&#x60; is accurate. Always &#x60;null&#x60; if &#x60;close_price&#x60; is &#x60;null&#x60;.
  , securityIsoCurrencyCode :: !(Maybe Text) -- ^ "iso_currency_code" - The ISO-4217 currency code of the price given. Always &#x60;null&#x60; if &#x60;unofficial_currency_code&#x60; is non-&#x60;null&#x60;.
  , securityUnofficialCurrencyCode :: !(Maybe Text) -- ^ "unofficial_currency_code" - The unofficial currency code associated with the security. Always &#x60;null&#x60; if &#x60;iso_currency_code&#x60; is non-&#x60;null&#x60;. Unofficial currency codes are used for currencies that do not have official ISO currency codes, such as cryptocurrencies and the currencies of certain countries.  See the [currency code schema](/docs/api/accounts#currency-code-schema) for a full listing of supported &#x60;iso_currency_code&#x60;s.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Security
instance A.FromJSON Security where
  parseJSON = A.withObject "Security" $ \o ->
    Security
      <$> (o .:  "security_id")
      <*> (o .:? "isin")
      <*> (o .:? "cusip")
      <*> (o .:? "sedol")
      <*> (o .:? "institution_security_id")
      <*> (o .:? "institution_id")
      <*> (o .:? "proxy_security_id")
      <*> (o .:? "name")
      <*> (o .:? "ticker_symbol")
      <*> (o .:? "is_cash_equivalent")
      <*> (o .:  "type")
      <*> (o .:? "close_price")
      <*> (o .:? "close_price_as_of")
      <*> (o .:? "iso_currency_code")
      <*> (o .:? "unofficial_currency_code")

-- | ToJSON Security
instance A.ToJSON Security where
  toJSON Security {..} =
   _omitNulls
      [ "security_id" .= securitySecurityId
      , "isin" .= securityIsin
      , "cusip" .= securityCusip
      , "sedol" .= securitySedol
      , "institution_security_id" .= securityInstitutionSecurityId
      , "institution_id" .= securityInstitutionId
      , "proxy_security_id" .= securityProxySecurityId
      , "name" .= securityName
      , "ticker_symbol" .= securityTickerSymbol
      , "is_cash_equivalent" .= securityIsCashEquivalent
      , "type" .= securityType
      , "close_price" .= securityClosePrice
      , "close_price_as_of" .= securityClosePriceAsOf
      , "iso_currency_code" .= securityIsoCurrencyCode
      , "unofficial_currency_code" .= securityUnofficialCurrencyCode
      ]


-- | Construct a value of type 'Security' (by applying it's required fields, if any)
mkSecurity
  :: Text -- ^ 'securitySecurityId': A unique, Plaid-specific identifier for the security, used to associate securities with holdings. Like all Plaid identifiers, the `security_id` is case sensitive.
  -> Text -- ^ 'securityType': The security type of the holding. Valid security types are:  `cash`: Cash, currency, and money market funds  `derivative`: Options, warrants, and other derivative instruments  `equity`: Domestic and foreign equities  `etf`: Multi-asset exchange-traded investment funds  `fixed income`: Bonds and certificates of deposit (CDs)  `loan`: Loans and loan receivables.  `mutual fund`: Open- and closed-end vehicles pooling funds of multiple investors.  `other`: Unknown or other investment types
  -> Security
mkSecurity securitySecurityId securityType =
  Security
  { securitySecurityId
  , securityIsin = Nothing
  , securityCusip = Nothing
  , securitySedol = Nothing
  , securityInstitutionSecurityId = Nothing
  , securityInstitutionId = Nothing
  , securityProxySecurityId = Nothing
  , securityName = Nothing
  , securityTickerSymbol = Nothing
  , securityIsCashEquivalent = Nothing
  , securityType
  , securityClosePrice = Nothing
  , securityClosePriceAsOf = Nothing
  , securityIsoCurrencyCode = Nothing
  , securityUnofficialCurrencyCode = Nothing
  }

-- ** ServicerAddressData
-- | ServicerAddressData
-- ServicerAddressData
-- 
-- The address of the student loan servicer. This is generally the remittance address to which payments should be sent.
data ServicerAddressData = ServicerAddressData
  { servicerAddressDataCity :: !(Maybe Text) -- ^ "city" - The full city name
  , servicerAddressDataRegion :: !(Maybe Text) -- ^ "region" - The region or state Example: &#x60;\&quot;NC\&quot;&#x60;
  , servicerAddressDataStreet :: !(Maybe Text) -- ^ "street" - The full street address Example: &#x60;\&quot;564 Main Street, APT 15\&quot;&#x60;
  , servicerAddressDataPostalCode :: !(Maybe Text) -- ^ "postal_code" - The postal code
  , servicerAddressDataCountry :: !(Maybe Text) -- ^ "country" - The ISO 3166-1 alpha-2 country code
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ServicerAddressData
instance A.FromJSON ServicerAddressData where
  parseJSON = A.withObject "ServicerAddressData" $ \o ->
    ServicerAddressData
      <$> (o .:? "city")
      <*> (o .:? "region")
      <*> (o .:? "street")
      <*> (o .:? "postal_code")
      <*> (o .:? "country")

-- | ToJSON ServicerAddressData
instance A.ToJSON ServicerAddressData where
  toJSON ServicerAddressData {..} =
   _omitNulls
      [ "city" .= servicerAddressDataCity
      , "region" .= servicerAddressDataRegion
      , "street" .= servicerAddressDataStreet
      , "postal_code" .= servicerAddressDataPostalCode
      , "country" .= servicerAddressDataCountry
      ]


-- | Construct a value of type 'ServicerAddressData' (by applying it's required fields, if any)
mkServicerAddressData
  :: ServicerAddressData
mkServicerAddressData =
  ServicerAddressData
  { servicerAddressDataCity = Nothing
  , servicerAddressDataRegion = Nothing
  , servicerAddressDataStreet = Nothing
  , servicerAddressDataPostalCode = Nothing
  , servicerAddressDataCountry = Nothing
  }

-- ** StandaloneAccountType
-- | StandaloneAccountType
-- StandaloneAccountType
-- 
-- The schema below describes the various `types` and corresponding `subtypes` that Plaid recognizes and reports for financial institution accounts.
data StandaloneAccountType = StandaloneAccountType
  { standaloneAccountTypeDepository :: !(Text) -- ^ /Required/ "depository" - An account type holding cash, in which funds are deposited. Supported products for &#x60;depository&#x60; accounts are: Auth, Balance, Transactions, Identity, Payment Initiation, and Assets.
  , standaloneAccountTypeCredit :: !(Text) -- ^ /Required/ "credit" - A credit card type account. Supported products for &#x60;credit&#x60; accounts are: Balance, Transactions, Identity, and Liabilities.
  , standaloneAccountTypeLoan :: !(Text) -- ^ /Required/ "loan" - A loan type account. Supported products for &#x60;loan&#x60; accounts are: Balance, Liabilities, and Transactions.
  , standaloneAccountTypeInvestment :: !(Text) -- ^ /Required/ "investment" - An investment account. Supported products for &#x60;investment&#x60; accounts are: Balance and Investments.
  , standaloneAccountTypeOther :: !(Text) -- ^ /Required/ "other" - Other or unknown account type. Supported products for &#x60;other&#x60; accounts are: Balance, Transactions, Identity, and Assets.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON StandaloneAccountType
instance A.FromJSON StandaloneAccountType where
  parseJSON = A.withObject "StandaloneAccountType" $ \o ->
    StandaloneAccountType
      <$> (o .:  "depository")
      <*> (o .:  "credit")
      <*> (o .:  "loan")
      <*> (o .:  "investment")
      <*> (o .:  "other")

-- | ToJSON StandaloneAccountType
instance A.ToJSON StandaloneAccountType where
  toJSON StandaloneAccountType {..} =
   _omitNulls
      [ "depository" .= standaloneAccountTypeDepository
      , "credit" .= standaloneAccountTypeCredit
      , "loan" .= standaloneAccountTypeLoan
      , "investment" .= standaloneAccountTypeInvestment
      , "other" .= standaloneAccountTypeOther
      ]


-- | Construct a value of type 'StandaloneAccountType' (by applying it's required fields, if any)
mkStandaloneAccountType
  :: Text -- ^ 'standaloneAccountTypeDepository': An account type holding cash, in which funds are deposited. Supported products for `depository` accounts are: Auth, Balance, Transactions, Identity, Payment Initiation, and Assets.
  -> Text -- ^ 'standaloneAccountTypeCredit': A credit card type account. Supported products for `credit` accounts are: Balance, Transactions, Identity, and Liabilities.
  -> Text -- ^ 'standaloneAccountTypeLoan': A loan type account. Supported products for `loan` accounts are: Balance, Liabilities, and Transactions.
  -> Text -- ^ 'standaloneAccountTypeInvestment': An investment account. Supported products for `investment` accounts are: Balance and Investments.
  -> Text -- ^ 'standaloneAccountTypeOther': Other or unknown account type. Supported products for `other` accounts are: Balance, Transactions, Identity, and Assets.
  -> StandaloneAccountType
mkStandaloneAccountType standaloneAccountTypeDepository standaloneAccountTypeCredit standaloneAccountTypeLoan standaloneAccountTypeInvestment standaloneAccountTypeOther =
  StandaloneAccountType
  { standaloneAccountTypeDepository
  , standaloneAccountTypeCredit
  , standaloneAccountTypeLoan
  , standaloneAccountTypeInvestment
  , standaloneAccountTypeOther
  }

-- ** StandaloneCurrencyCodeList
-- | StandaloneCurrencyCodeList
-- StandaloneCurrencyCodeList
-- 
-- The following currency codes are supported by Plaid.
data StandaloneCurrencyCodeList = StandaloneCurrencyCodeList
  { standaloneCurrencyCodeListIsoCurrencyCode :: !(Text) -- ^ /Required/ "iso_currency_code" - Plaid supports all ISO 4217 currency codes.
  , standaloneCurrencyCodeListUnofficialCurrencyCode :: !(Text) -- ^ /Required/ "unofficial_currency_code" - List of unofficial currency codes
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON StandaloneCurrencyCodeList
instance A.FromJSON StandaloneCurrencyCodeList where
  parseJSON = A.withObject "StandaloneCurrencyCodeList" $ \o ->
    StandaloneCurrencyCodeList
      <$> (o .:  "iso_currency_code")
      <*> (o .:  "unofficial_currency_code")

-- | ToJSON StandaloneCurrencyCodeList
instance A.ToJSON StandaloneCurrencyCodeList where
  toJSON StandaloneCurrencyCodeList {..} =
   _omitNulls
      [ "iso_currency_code" .= standaloneCurrencyCodeListIsoCurrencyCode
      , "unofficial_currency_code" .= standaloneCurrencyCodeListUnofficialCurrencyCode
      ]


-- | Construct a value of type 'StandaloneCurrencyCodeList' (by applying it's required fields, if any)
mkStandaloneCurrencyCodeList
  :: Text -- ^ 'standaloneCurrencyCodeListIsoCurrencyCode': Plaid supports all ISO 4217 currency codes.
  -> Text -- ^ 'standaloneCurrencyCodeListUnofficialCurrencyCode': List of unofficial currency codes
  -> StandaloneCurrencyCodeList
mkStandaloneCurrencyCodeList standaloneCurrencyCodeListIsoCurrencyCode standaloneCurrencyCodeListUnofficialCurrencyCode =
  StandaloneCurrencyCodeList
  { standaloneCurrencyCodeListIsoCurrencyCode
  , standaloneCurrencyCodeListUnofficialCurrencyCode
  }

-- ** StandaloneInvestmentTransactionSubtype
-- | StandaloneInvestmentTransactionSubtype
-- StandaloneInvestmentTransactionSubtype
-- 
-- Valid subtypes for Investment transaction subtypes. Note that transactions representing inflow of cash will appear as negative amounts, outflow of cash will appear as positive amounts.
data StandaloneInvestmentTransactionSubtype = StandaloneInvestmentTransactionSubtype
  { standaloneInvestmentTransactionSubtypeAccountFee :: !(Maybe Text) -- ^ "account fee" - Fees paid for account maintenance
  , standaloneInvestmentTransactionSubtypeAssignment :: !(Maybe Text) -- ^ "assignment" - Assignment of short option holding
  , standaloneInvestmentTransactionSubtypeBuy :: !(Maybe Text) -- ^ "buy" - Purchase to open or increase a position
  , standaloneInvestmentTransactionSubtypeBuyToCover :: !(Maybe Text) -- ^ "buy to cover" - Purchase to close a short position
  , standaloneInvestmentTransactionSubtypeContribution :: !(Maybe Text) -- ^ "contribution" - Inflow of assets into a tax-advantaged account
  , standaloneInvestmentTransactionSubtypeDeposit :: !(Maybe Text) -- ^ "deposit" - Inflow of cash into an account
  , standaloneInvestmentTransactionSubtypeDistribution :: !(Maybe Text) -- ^ "distribution" - Outflow of assets from a tax-advantaged account
  , standaloneInvestmentTransactionSubtypeDividend :: !(Maybe Text) -- ^ "dividend" - Inflow of cash from a dividend
  , standaloneInvestmentTransactionSubtypeDividendReinvestment :: !(Maybe Text) -- ^ "dividend reinvestment" - Purchase using proceeds from a cash dividend
  , standaloneInvestmentTransactionSubtypeExercise :: !(Maybe Text) -- ^ "exercise" - Exercise of an option or warrant contract
  , standaloneInvestmentTransactionSubtypeExpire :: !(Maybe Text) -- ^ "expire" - Expiration of an option or warrant contract 
  , standaloneInvestmentTransactionSubtypeFundFee :: !(Maybe Text) -- ^ "fund fee" - Fees paid for administration of a mutual fund or other pooled investment vehicle
  , standaloneInvestmentTransactionSubtypeInterest :: !(Maybe Text) -- ^ "interest" - Inflow of cash from interest
  , standaloneInvestmentTransactionSubtypeInterestReceivable :: !(Maybe Text) -- ^ "interest receivable" - Inflow of cash from interest receivable
  , standaloneInvestmentTransactionSubtypeInterestReinvestment :: !(Maybe Text) -- ^ "interest reinvestment" - Purchase using proceeds from a cash interest payment
  , standaloneInvestmentTransactionSubtypeLegalFee :: !(Maybe Text) -- ^ "legal fee" - Fees paid for legal charges or services
  , standaloneInvestmentTransactionSubtypeLoanPayment :: !(Maybe Text) -- ^ "loan payment" - Inflow of cash related to payment on a loan
  , standaloneInvestmentTransactionSubtypeLongTermCapitalGain :: !(Maybe Text) -- ^ "long-term capital gain" - Long-term capital gain received as cash
  , standaloneInvestmentTransactionSubtypeLongTermCapitalGainReinvestment :: !(Maybe Text) -- ^ "long-term capital gain reinvestment" - Purchase using long-term capital gain cash proceeds
  , standaloneInvestmentTransactionSubtypeManagementFee :: !(Maybe Text) -- ^ "management fee" - Fees paid for investment management of a mutual fund or other pooled investment vehicle
  , standaloneInvestmentTransactionSubtypeMarginExpense :: !(Maybe Text) -- ^ "margin expense" - Fees paid for maintaining margin debt
  , standaloneInvestmentTransactionSubtypeMerger :: !(Maybe Text) -- ^ "merger" - Stock exchanged at a pre-defined ratio as part of a merger between companies
  , standaloneInvestmentTransactionSubtypeMiscellaneousFee :: !(Maybe Text) -- ^ "miscellaneous fee" - Fee associated with various account or holding actions
  , standaloneInvestmentTransactionSubtypeNonQualifiedDividend :: !(Maybe Text) -- ^ "non-qualified dividend" - Inflow of cash from a non-qualified dividend
  , standaloneInvestmentTransactionSubtypeNonResidentTax :: !(Maybe Text) -- ^ "non-resident tax" - Taxes paid on behalf of the investor for non-residency in investment jurisdiction
  , standaloneInvestmentTransactionSubtypePendingCredit :: !(Maybe Text) -- ^ "pending credit" - Pending inflow of cash
  , standaloneInvestmentTransactionSubtypePendingDebit :: !(Maybe Text) -- ^ "pending debit" - Pending outflow of cash
  , standaloneInvestmentTransactionSubtypeQualifiedDividend :: !(Maybe Text) -- ^ "qualified dividend" - Inflow of cash from a qualified dividend
  , standaloneInvestmentTransactionSubtypeRebalance :: !(Maybe Text) -- ^ "rebalance" - Rebalancing transaction (buy or sell) with no net impact to value in the account
  , standaloneInvestmentTransactionSubtypeReturnOfPrincipal :: !(Maybe Text) -- ^ "return of principal" - Repayment of loan principal
  , standaloneInvestmentTransactionSubtypeSell :: !(Maybe Text) -- ^ "sell" - Sell to close or decrease an existing holding
  , standaloneInvestmentTransactionSubtypeSellShort :: !(Maybe Text) -- ^ "sell short" - Sell to open a short position
  , standaloneInvestmentTransactionSubtypeShortTermCapitalGain :: !(Maybe Text) -- ^ "short-term capital gain" - Short-term capital gain received as cash
  , standaloneInvestmentTransactionSubtypeShortTermCapitalGainReinvestment :: !(Maybe Text) -- ^ "short-term capital gain reinvestment" - Purchase using short-term capital gain cash proceeds
  , standaloneInvestmentTransactionSubtypeSpinOff :: !(Maybe Text) -- ^ "spin off" - Inflow of stock from spin-off transaction of an existing holding
  , standaloneInvestmentTransactionSubtypeSplit :: !(Maybe Text) -- ^ "split" - Inflow of stock from a forward split of an existing holding
  , standaloneInvestmentTransactionSubtypeStockDistribution :: !(Maybe Text) -- ^ "stock distribution" - Inflow of stock from a distribution
  , standaloneInvestmentTransactionSubtypeTax :: !(Maybe Text) -- ^ "tax" - Taxes paid on behalf of the investor
  , standaloneInvestmentTransactionSubtypeTaxWithheld :: !(Maybe Text) -- ^ "tax withheld" - Taxes withheld on behalf of the customer
  , standaloneInvestmentTransactionSubtypeTransfer :: !(Maybe Text) -- ^ "transfer" - Movement of assets into or out of an account
  , standaloneInvestmentTransactionSubtypeTransferFee :: !(Maybe Text) -- ^ "transfer fee" - Fees incurred for transfer of a holding or account
  , standaloneInvestmentTransactionSubtypeTrustFee :: !(Maybe Text) -- ^ "trust fee" - Fees related to adminstration of a trust account
  , standaloneInvestmentTransactionSubtypeUnqualifiedGain :: !(Maybe Text) -- ^ "unqualified gain" - Unqualified capital gain received as cash
  , standaloneInvestmentTransactionSubtypeWithdrawal :: !(Maybe Text) -- ^ "withdrawal" - Outflow of cash from an account
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON StandaloneInvestmentTransactionSubtype
instance A.FromJSON StandaloneInvestmentTransactionSubtype where
  parseJSON = A.withObject "StandaloneInvestmentTransactionSubtype" $ \o ->
    StandaloneInvestmentTransactionSubtype
      <$> (o .:? "account fee")
      <*> (o .:? "assignment")
      <*> (o .:? "buy")
      <*> (o .:? "buy to cover")
      <*> (o .:? "contribution")
      <*> (o .:? "deposit")
      <*> (o .:? "distribution")
      <*> (o .:? "dividend")
      <*> (o .:? "dividend reinvestment")
      <*> (o .:? "exercise")
      <*> (o .:? "expire")
      <*> (o .:? "fund fee")
      <*> (o .:? "interest")
      <*> (o .:? "interest receivable")
      <*> (o .:? "interest reinvestment")
      <*> (o .:? "legal fee")
      <*> (o .:? "loan payment")
      <*> (o .:? "long-term capital gain")
      <*> (o .:? "long-term capital gain reinvestment")
      <*> (o .:? "management fee")
      <*> (o .:? "margin expense")
      <*> (o .:? "merger")
      <*> (o .:? "miscellaneous fee")
      <*> (o .:? "non-qualified dividend")
      <*> (o .:? "non-resident tax")
      <*> (o .:? "pending credit")
      <*> (o .:? "pending debit")
      <*> (o .:? "qualified dividend")
      <*> (o .:? "rebalance")
      <*> (o .:? "return of principal")
      <*> (o .:? "sell")
      <*> (o .:? "sell short")
      <*> (o .:? "short-term capital gain")
      <*> (o .:? "short-term capital gain reinvestment")
      <*> (o .:? "spin off")
      <*> (o .:? "split")
      <*> (o .:? "stock distribution")
      <*> (o .:? "tax")
      <*> (o .:? "tax withheld")
      <*> (o .:? "transfer")
      <*> (o .:? "transfer fee")
      <*> (o .:? "trust fee")
      <*> (o .:? "unqualified gain")
      <*> (o .:? "withdrawal")

-- | ToJSON StandaloneInvestmentTransactionSubtype
instance A.ToJSON StandaloneInvestmentTransactionSubtype where
  toJSON StandaloneInvestmentTransactionSubtype {..} =
   _omitNulls
      [ "account fee" .= standaloneInvestmentTransactionSubtypeAccountFee
      , "assignment" .= standaloneInvestmentTransactionSubtypeAssignment
      , "buy" .= standaloneInvestmentTransactionSubtypeBuy
      , "buy to cover" .= standaloneInvestmentTransactionSubtypeBuyToCover
      , "contribution" .= standaloneInvestmentTransactionSubtypeContribution
      , "deposit" .= standaloneInvestmentTransactionSubtypeDeposit
      , "distribution" .= standaloneInvestmentTransactionSubtypeDistribution
      , "dividend" .= standaloneInvestmentTransactionSubtypeDividend
      , "dividend reinvestment" .= standaloneInvestmentTransactionSubtypeDividendReinvestment
      , "exercise" .= standaloneInvestmentTransactionSubtypeExercise
      , "expire" .= standaloneInvestmentTransactionSubtypeExpire
      , "fund fee" .= standaloneInvestmentTransactionSubtypeFundFee
      , "interest" .= standaloneInvestmentTransactionSubtypeInterest
      , "interest receivable" .= standaloneInvestmentTransactionSubtypeInterestReceivable
      , "interest reinvestment" .= standaloneInvestmentTransactionSubtypeInterestReinvestment
      , "legal fee" .= standaloneInvestmentTransactionSubtypeLegalFee
      , "loan payment" .= standaloneInvestmentTransactionSubtypeLoanPayment
      , "long-term capital gain" .= standaloneInvestmentTransactionSubtypeLongTermCapitalGain
      , "long-term capital gain reinvestment" .= standaloneInvestmentTransactionSubtypeLongTermCapitalGainReinvestment
      , "management fee" .= standaloneInvestmentTransactionSubtypeManagementFee
      , "margin expense" .= standaloneInvestmentTransactionSubtypeMarginExpense
      , "merger" .= standaloneInvestmentTransactionSubtypeMerger
      , "miscellaneous fee" .= standaloneInvestmentTransactionSubtypeMiscellaneousFee
      , "non-qualified dividend" .= standaloneInvestmentTransactionSubtypeNonQualifiedDividend
      , "non-resident tax" .= standaloneInvestmentTransactionSubtypeNonResidentTax
      , "pending credit" .= standaloneInvestmentTransactionSubtypePendingCredit
      , "pending debit" .= standaloneInvestmentTransactionSubtypePendingDebit
      , "qualified dividend" .= standaloneInvestmentTransactionSubtypeQualifiedDividend
      , "rebalance" .= standaloneInvestmentTransactionSubtypeRebalance
      , "return of principal" .= standaloneInvestmentTransactionSubtypeReturnOfPrincipal
      , "sell" .= standaloneInvestmentTransactionSubtypeSell
      , "sell short" .= standaloneInvestmentTransactionSubtypeSellShort
      , "short-term capital gain" .= standaloneInvestmentTransactionSubtypeShortTermCapitalGain
      , "short-term capital gain reinvestment" .= standaloneInvestmentTransactionSubtypeShortTermCapitalGainReinvestment
      , "spin off" .= standaloneInvestmentTransactionSubtypeSpinOff
      , "split" .= standaloneInvestmentTransactionSubtypeSplit
      , "stock distribution" .= standaloneInvestmentTransactionSubtypeStockDistribution
      , "tax" .= standaloneInvestmentTransactionSubtypeTax
      , "tax withheld" .= standaloneInvestmentTransactionSubtypeTaxWithheld
      , "transfer" .= standaloneInvestmentTransactionSubtypeTransfer
      , "transfer fee" .= standaloneInvestmentTransactionSubtypeTransferFee
      , "trust fee" .= standaloneInvestmentTransactionSubtypeTrustFee
      , "unqualified gain" .= standaloneInvestmentTransactionSubtypeUnqualifiedGain
      , "withdrawal" .= standaloneInvestmentTransactionSubtypeWithdrawal
      ]


-- | Construct a value of type 'StandaloneInvestmentTransactionSubtype' (by applying it's required fields, if any)
mkStandaloneInvestmentTransactionSubtype
  :: StandaloneInvestmentTransactionSubtype
mkStandaloneInvestmentTransactionSubtype =
  StandaloneInvestmentTransactionSubtype
  { standaloneInvestmentTransactionSubtypeAccountFee = Nothing
  , standaloneInvestmentTransactionSubtypeAssignment = Nothing
  , standaloneInvestmentTransactionSubtypeBuy = Nothing
  , standaloneInvestmentTransactionSubtypeBuyToCover = Nothing
  , standaloneInvestmentTransactionSubtypeContribution = Nothing
  , standaloneInvestmentTransactionSubtypeDeposit = Nothing
  , standaloneInvestmentTransactionSubtypeDistribution = Nothing
  , standaloneInvestmentTransactionSubtypeDividend = Nothing
  , standaloneInvestmentTransactionSubtypeDividendReinvestment = Nothing
  , standaloneInvestmentTransactionSubtypeExercise = Nothing
  , standaloneInvestmentTransactionSubtypeExpire = Nothing
  , standaloneInvestmentTransactionSubtypeFundFee = Nothing
  , standaloneInvestmentTransactionSubtypeInterest = Nothing
  , standaloneInvestmentTransactionSubtypeInterestReceivable = Nothing
  , standaloneInvestmentTransactionSubtypeInterestReinvestment = Nothing
  , standaloneInvestmentTransactionSubtypeLegalFee = Nothing
  , standaloneInvestmentTransactionSubtypeLoanPayment = Nothing
  , standaloneInvestmentTransactionSubtypeLongTermCapitalGain = Nothing
  , standaloneInvestmentTransactionSubtypeLongTermCapitalGainReinvestment = Nothing
  , standaloneInvestmentTransactionSubtypeManagementFee = Nothing
  , standaloneInvestmentTransactionSubtypeMarginExpense = Nothing
  , standaloneInvestmentTransactionSubtypeMerger = Nothing
  , standaloneInvestmentTransactionSubtypeMiscellaneousFee = Nothing
  , standaloneInvestmentTransactionSubtypeNonQualifiedDividend = Nothing
  , standaloneInvestmentTransactionSubtypeNonResidentTax = Nothing
  , standaloneInvestmentTransactionSubtypePendingCredit = Nothing
  , standaloneInvestmentTransactionSubtypePendingDebit = Nothing
  , standaloneInvestmentTransactionSubtypeQualifiedDividend = Nothing
  , standaloneInvestmentTransactionSubtypeRebalance = Nothing
  , standaloneInvestmentTransactionSubtypeReturnOfPrincipal = Nothing
  , standaloneInvestmentTransactionSubtypeSell = Nothing
  , standaloneInvestmentTransactionSubtypeSellShort = Nothing
  , standaloneInvestmentTransactionSubtypeShortTermCapitalGain = Nothing
  , standaloneInvestmentTransactionSubtypeShortTermCapitalGainReinvestment = Nothing
  , standaloneInvestmentTransactionSubtypeSpinOff = Nothing
  , standaloneInvestmentTransactionSubtypeSplit = Nothing
  , standaloneInvestmentTransactionSubtypeStockDistribution = Nothing
  , standaloneInvestmentTransactionSubtypeTax = Nothing
  , standaloneInvestmentTransactionSubtypeTaxWithheld = Nothing
  , standaloneInvestmentTransactionSubtypeTransfer = Nothing
  , standaloneInvestmentTransactionSubtypeTransferFee = Nothing
  , standaloneInvestmentTransactionSubtypeTrustFee = Nothing
  , standaloneInvestmentTransactionSubtypeUnqualifiedGain = Nothing
  , standaloneInvestmentTransactionSubtypeWithdrawal = Nothing
  }

-- ** StandaloneInvestmentTransactionType
-- | StandaloneInvestmentTransactionType
-- StandaloneInvestmentTransactionType
-- 
-- Valid values for investment transaction types
data StandaloneInvestmentTransactionType = StandaloneInvestmentTransactionType
  { standaloneInvestmentTransactionTypeBuy :: !(Text) -- ^ /Required/ "buy" - Buying an investment
  , standaloneInvestmentTransactionTypeSell :: !(Text) -- ^ /Required/ "sell" - Selling an investment
  , standaloneInvestmentTransactionTypeCancel :: !(Text) -- ^ /Required/ "cancel" - A cancellation of a pending transaction
  , standaloneInvestmentTransactionTypeCash :: !(Text) -- ^ /Required/ "cash" - Activity that modifies a cash position
  , standaloneInvestmentTransactionTypeFee :: !(Text) -- ^ /Required/ "fee" - Fees on the account, e.g. commission, bookkeeping, options-related.
  , standaloneInvestmentTransactionTypeTransfer :: !(Text) -- ^ /Required/ "transfer" - Activity which modifies a position, but not through buy/sell activity e.g. options exercise, portfolio transfer
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON StandaloneInvestmentTransactionType
instance A.FromJSON StandaloneInvestmentTransactionType where
  parseJSON = A.withObject "StandaloneInvestmentTransactionType" $ \o ->
    StandaloneInvestmentTransactionType
      <$> (o .:  "buy")
      <*> (o .:  "sell")
      <*> (o .:  "cancel")
      <*> (o .:  "cash")
      <*> (o .:  "fee")
      <*> (o .:  "transfer")

-- | ToJSON StandaloneInvestmentTransactionType
instance A.ToJSON StandaloneInvestmentTransactionType where
  toJSON StandaloneInvestmentTransactionType {..} =
   _omitNulls
      [ "buy" .= standaloneInvestmentTransactionTypeBuy
      , "sell" .= standaloneInvestmentTransactionTypeSell
      , "cancel" .= standaloneInvestmentTransactionTypeCancel
      , "cash" .= standaloneInvestmentTransactionTypeCash
      , "fee" .= standaloneInvestmentTransactionTypeFee
      , "transfer" .= standaloneInvestmentTransactionTypeTransfer
      ]


-- | Construct a value of type 'StandaloneInvestmentTransactionType' (by applying it's required fields, if any)
mkStandaloneInvestmentTransactionType
  :: Text -- ^ 'standaloneInvestmentTransactionTypeBuy': Buying an investment
  -> Text -- ^ 'standaloneInvestmentTransactionTypeSell': Selling an investment
  -> Text -- ^ 'standaloneInvestmentTransactionTypeCancel': A cancellation of a pending transaction
  -> Text -- ^ 'standaloneInvestmentTransactionTypeCash': Activity that modifies a cash position
  -> Text -- ^ 'standaloneInvestmentTransactionTypeFee': Fees on the account, e.g. commission, bookkeeping, options-related.
  -> Text -- ^ 'standaloneInvestmentTransactionTypeTransfer': Activity which modifies a position, but not through buy/sell activity e.g. options exercise, portfolio transfer
  -> StandaloneInvestmentTransactionType
mkStandaloneInvestmentTransactionType standaloneInvestmentTransactionTypeBuy standaloneInvestmentTransactionTypeSell standaloneInvestmentTransactionTypeCancel standaloneInvestmentTransactionTypeCash standaloneInvestmentTransactionTypeFee standaloneInvestmentTransactionTypeTransfer =
  StandaloneInvestmentTransactionType
  { standaloneInvestmentTransactionTypeBuy
  , standaloneInvestmentTransactionTypeSell
  , standaloneInvestmentTransactionTypeCancel
  , standaloneInvestmentTransactionTypeCash
  , standaloneInvestmentTransactionTypeFee
  , standaloneInvestmentTransactionTypeTransfer
  }

-- ** StudentLoan
-- | StudentLoan
-- StudentLoan
-- 
-- Contains details about a student loan account
data StudentLoan = StudentLoan
  { studentLoanAccountId :: !(Maybe Text) -- ^ "account_id" - The ID of the account that this liability belongs to.
  , studentLoanAccountNumber :: !(Maybe Text) -- ^ "account_number" - The account number of the loan.
  , studentLoanDisbursementDates :: !(Maybe [Text]) -- ^ "disbursement_dates" - The dates on which loaned funds were disbursed or will be disbursed. These are often in the past. Dates are returned in an ISO 8601 format (YYYY-MM-DD).
  , studentLoanExpectedPayoffDate :: !(Maybe Text) -- ^ "expected_payoff_date" - The date when the student loan is expected to be paid off. Availability for this field is limited. Dates are returned in an ISO 8601 format (YYYY-MM-DD).
  , studentLoanGuarantor :: !(Maybe Text) -- ^ "guarantor" - The guarantor of the student loan.
  , studentLoanInterestRatePercentage :: !(Double) -- ^ /Required/ "interest_rate_percentage" - The interest rate on the loan as a percentage.
  , studentLoanIsOverdue :: !(Maybe Bool) -- ^ "is_overdue" - &#x60;true&#x60; if a payment is currently overdue. Availability for this field is limited.
  , studentLoanLastPaymentAmount :: !(Maybe Double) -- ^ "last_payment_amount" - The amount of the last payment.
  , studentLoanLastPaymentDate :: !(Maybe Text) -- ^ "last_payment_date" - The date of the last payment. Dates are returned in an ISO 8601 format (YYYY-MM-DD).
  , studentLoanLastStatementBalance :: !(Maybe Double) -- ^ "last_statement_balance" - The outstanding balance on the last statement. This field could also be interpreted as the next payment due. Availability for this field is limited. 
  , studentLoanLastStatementIssueDate :: !(Maybe Text) -- ^ "last_statement_issue_date" - The date of the last statement. Dates are returned in an ISO 8601 format (YYYY-MM-DD).
  , studentLoanLoanName :: !(Maybe Text) -- ^ "loan_name" - The type of loan, e.g., \&quot;Consolidation Loans\&quot;.
  , studentLoanLoanStatus :: !(Maybe StudentLoanStatus) -- ^ "loan_status"
  , studentLoanMinimumPaymentAmount :: !(Maybe Double) -- ^ "minimum_payment_amount" - The minimum payment due for the next billing cycle. There are some exceptions: Some institutions require a minimum payment across all loans associated with an account number. Our API presents that same minimum payment amount on each loan. The institutions that do this are: Great Lakes ( &#x60;ins_116861&#x60;), Firstmark (&#x60;ins_116295&#x60;), Commonbond Firstmark Services (&#x60;ins_116950&#x60;), Nelnet (&#x60;ins_116528&#x60;), EdFinancial Services (&#x60;ins_116304&#x60;), Granite State (&#x60;ins_116308&#x60;), and Oklahoma Student Loan Authority (&#x60;ins_116945&#x60;). Firstmark (&#x60;ins_116295&#x60; ) will display as $0 if there is an autopay program in effect.
  , studentLoanNextPaymentDueDate :: !(Maybe Text) -- ^ "next_payment_due_date" - The due date for the next payment. The due date is &#x60;null&#x60; if a payment is not expected. A payment is not expected if &#x60;loan_status.type&#x60; is &#x60;deferment&#x60;, &#x60;in_school&#x60;, &#x60;consolidated&#x60;, &#x60;paid in full&#x60;, or &#x60;transferred&#x60;. Dates are returned in an ISO 8601 format (YYYY-MM-DD).
  , studentLoanOriginationDate :: !(Maybe Text) -- ^ "origination_date" - The date on which the loan was initially lent. Dates are returned in an ISO 8601 format (YYYY-MM-DD). 
  , studentLoanOriginationPrincipalAmount :: !(Maybe Double) -- ^ "origination_principal_amount" - The original principal balance of the loan.
  , studentLoanOutstandingInterestAmount :: !(Maybe Double) -- ^ "outstanding_interest_amount" - The total dollar amount of the accrued interest balance. For Sallie Mae ( &#x60;ins_116944&#x60;), this amount is included in the current balance of the loan, so this field will return as &#x60;null&#x60;.
  , studentLoanPaymentReferenceNumber :: !(Maybe Text) -- ^ "payment_reference_number" - The relevant account number that should be used to reference this loan for payments. In the majority of cases, &#x60;payment_reference_number&#x60; will match a&#x60;ccount_number,&#x60; but in some institutions, such as Great Lakes (&#x60;ins_116861&#x60;), it will be different.
  , studentLoanPslfStatus :: !(Maybe PSLFStatus) -- ^ "pslf_status"
  , studentLoanRepaymentPlan :: !(Maybe StudentRepaymentPlan) -- ^ "repayment_plan"
  , studentLoanSequenceNumber :: !(Maybe Text) -- ^ "sequence_number" - The sequence number of the student loan. Heartland ECSI (&#x60;ins_116948&#x60;) does not make this field available.
  , studentLoanServicerAddress :: !(Maybe ServicerAddressData) -- ^ "servicer_address"
  , studentLoanYtdInterestPaid :: !(Maybe Double) -- ^ "ytd_interest_paid" - The year to date (YTD) interest paid. Availability for this field is limited.
  , studentLoanYtdPrincipalPaid :: !(Maybe Double) -- ^ "ytd_principal_paid" - The year to date (YTD) principal paid. Availability for this field is limited.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON StudentLoan
instance A.FromJSON StudentLoan where
  parseJSON = A.withObject "StudentLoan" $ \o ->
    StudentLoan
      <$> (o .:? "account_id")
      <*> (o .:? "account_number")
      <*> (o .:? "disbursement_dates")
      <*> (o .:? "expected_payoff_date")
      <*> (o .:? "guarantor")
      <*> (o .:  "interest_rate_percentage")
      <*> (o .:? "is_overdue")
      <*> (o .:? "last_payment_amount")
      <*> (o .:? "last_payment_date")
      <*> (o .:? "last_statement_balance")
      <*> (o .:? "last_statement_issue_date")
      <*> (o .:? "loan_name")
      <*> (o .:? "loan_status")
      <*> (o .:? "minimum_payment_amount")
      <*> (o .:? "next_payment_due_date")
      <*> (o .:? "origination_date")
      <*> (o .:? "origination_principal_amount")
      <*> (o .:? "outstanding_interest_amount")
      <*> (o .:? "payment_reference_number")
      <*> (o .:? "pslf_status")
      <*> (o .:? "repayment_plan")
      <*> (o .:? "sequence_number")
      <*> (o .:? "servicer_address")
      <*> (o .:? "ytd_interest_paid")
      <*> (o .:? "ytd_principal_paid")

-- | ToJSON StudentLoan
instance A.ToJSON StudentLoan where
  toJSON StudentLoan {..} =
   _omitNulls
      [ "account_id" .= studentLoanAccountId
      , "account_number" .= studentLoanAccountNumber
      , "disbursement_dates" .= studentLoanDisbursementDates
      , "expected_payoff_date" .= studentLoanExpectedPayoffDate
      , "guarantor" .= studentLoanGuarantor
      , "interest_rate_percentage" .= studentLoanInterestRatePercentage
      , "is_overdue" .= studentLoanIsOverdue
      , "last_payment_amount" .= studentLoanLastPaymentAmount
      , "last_payment_date" .= studentLoanLastPaymentDate
      , "last_statement_balance" .= studentLoanLastStatementBalance
      , "last_statement_issue_date" .= studentLoanLastStatementIssueDate
      , "loan_name" .= studentLoanLoanName
      , "loan_status" .= studentLoanLoanStatus
      , "minimum_payment_amount" .= studentLoanMinimumPaymentAmount
      , "next_payment_due_date" .= studentLoanNextPaymentDueDate
      , "origination_date" .= studentLoanOriginationDate
      , "origination_principal_amount" .= studentLoanOriginationPrincipalAmount
      , "outstanding_interest_amount" .= studentLoanOutstandingInterestAmount
      , "payment_reference_number" .= studentLoanPaymentReferenceNumber
      , "pslf_status" .= studentLoanPslfStatus
      , "repayment_plan" .= studentLoanRepaymentPlan
      , "sequence_number" .= studentLoanSequenceNumber
      , "servicer_address" .= studentLoanServicerAddress
      , "ytd_interest_paid" .= studentLoanYtdInterestPaid
      , "ytd_principal_paid" .= studentLoanYtdPrincipalPaid
      ]


-- | Construct a value of type 'StudentLoan' (by applying it's required fields, if any)
mkStudentLoan
  :: Double -- ^ 'studentLoanInterestRatePercentage': The interest rate on the loan as a percentage.
  -> StudentLoan
mkStudentLoan studentLoanInterestRatePercentage =
  StudentLoan
  { studentLoanAccountId = Nothing
  , studentLoanAccountNumber = Nothing
  , studentLoanDisbursementDates = Nothing
  , studentLoanExpectedPayoffDate = Nothing
  , studentLoanGuarantor = Nothing
  , studentLoanInterestRatePercentage
  , studentLoanIsOverdue = Nothing
  , studentLoanLastPaymentAmount = Nothing
  , studentLoanLastPaymentDate = Nothing
  , studentLoanLastStatementBalance = Nothing
  , studentLoanLastStatementIssueDate = Nothing
  , studentLoanLoanName = Nothing
  , studentLoanLoanStatus = Nothing
  , studentLoanMinimumPaymentAmount = Nothing
  , studentLoanNextPaymentDueDate = Nothing
  , studentLoanOriginationDate = Nothing
  , studentLoanOriginationPrincipalAmount = Nothing
  , studentLoanOutstandingInterestAmount = Nothing
  , studentLoanPaymentReferenceNumber = Nothing
  , studentLoanPslfStatus = Nothing
  , studentLoanRepaymentPlan = Nothing
  , studentLoanSequenceNumber = Nothing
  , studentLoanServicerAddress = Nothing
  , studentLoanYtdInterestPaid = Nothing
  , studentLoanYtdPrincipalPaid = Nothing
  }

-- ** StudentLoanRepaymentModel
-- | StudentLoanRepaymentModel
-- StudentLoanRepaymentModel
-- 
-- Student loan repayment information used to configure Sandbox test data for the Liabilities product
data StudentLoanRepaymentModel = StudentLoanRepaymentModel
  { studentLoanRepaymentModelType :: !(Text) -- ^ /Required/ "type" - The only currently supported value for this field is &#x60;standard&#x60;.
  , studentLoanRepaymentModelNonRepaymentMonths :: !(Double) -- ^ /Required/ "non_repayment_months" - Configures the number of months before repayment starts.
  , studentLoanRepaymentModelRepaymentMonths :: !(Double) -- ^ /Required/ "repayment_months" - Configures the number of months of repayments before the loan is paid off.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON StudentLoanRepaymentModel
instance A.FromJSON StudentLoanRepaymentModel where
  parseJSON = A.withObject "StudentLoanRepaymentModel" $ \o ->
    StudentLoanRepaymentModel
      <$> (o .:  "type")
      <*> (o .:  "non_repayment_months")
      <*> (o .:  "repayment_months")

-- | ToJSON StudentLoanRepaymentModel
instance A.ToJSON StudentLoanRepaymentModel where
  toJSON StudentLoanRepaymentModel {..} =
   _omitNulls
      [ "type" .= studentLoanRepaymentModelType
      , "non_repayment_months" .= studentLoanRepaymentModelNonRepaymentMonths
      , "repayment_months" .= studentLoanRepaymentModelRepaymentMonths
      ]


-- | Construct a value of type 'StudentLoanRepaymentModel' (by applying it's required fields, if any)
mkStudentLoanRepaymentModel
  :: Text -- ^ 'studentLoanRepaymentModelType': The only currently supported value for this field is `standard`.
  -> Double -- ^ 'studentLoanRepaymentModelNonRepaymentMonths': Configures the number of months before repayment starts.
  -> Double -- ^ 'studentLoanRepaymentModelRepaymentMonths': Configures the number of months of repayments before the loan is paid off.
  -> StudentLoanRepaymentModel
mkStudentLoanRepaymentModel studentLoanRepaymentModelType studentLoanRepaymentModelNonRepaymentMonths studentLoanRepaymentModelRepaymentMonths =
  StudentLoanRepaymentModel
  { studentLoanRepaymentModelType
  , studentLoanRepaymentModelNonRepaymentMonths
  , studentLoanRepaymentModelRepaymentMonths
  }

-- ** StudentLoanStatus
-- | StudentLoanStatus
-- StudentLoanStatus
-- 
-- An object representing the status of the student loan
data StudentLoanStatus = StudentLoanStatus
  { studentLoanStatusEndDate :: !(Maybe Text) -- ^ "end_date" - The date until which the loan will be in its current status. Dates are returned in an ISO 8601 format (YYYY-MM-DD). 
  , studentLoanStatusType :: !(Maybe E'Type3) -- ^ "type" - The status type of the student loan
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON StudentLoanStatus
instance A.FromJSON StudentLoanStatus where
  parseJSON = A.withObject "StudentLoanStatus" $ \o ->
    StudentLoanStatus
      <$> (o .:? "end_date")
      <*> (o .:? "type")

-- | ToJSON StudentLoanStatus
instance A.ToJSON StudentLoanStatus where
  toJSON StudentLoanStatus {..} =
   _omitNulls
      [ "end_date" .= studentLoanStatusEndDate
      , "type" .= studentLoanStatusType
      ]


-- | Construct a value of type 'StudentLoanStatus' (by applying it's required fields, if any)
mkStudentLoanStatus
  :: StudentLoanStatus
mkStudentLoanStatus =
  StudentLoanStatus
  { studentLoanStatusEndDate = Nothing
  , studentLoanStatusType = Nothing
  }

-- ** StudentRepaymentPlan
-- | StudentRepaymentPlan
-- StudentRepaymentPlan
-- 
-- An object representing the repayment plan for the student loan
data StudentRepaymentPlan = StudentRepaymentPlan
  { studentRepaymentPlanDescription :: !(Maybe Text) -- ^ "description" - The description of the repayment plan as provided by the servicer.
  , studentRepaymentPlanType :: !(Maybe E'Type4) -- ^ "type" - The type of the repayment plan.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON StudentRepaymentPlan
instance A.FromJSON StudentRepaymentPlan where
  parseJSON = A.withObject "StudentRepaymentPlan" $ \o ->
    StudentRepaymentPlan
      <$> (o .:? "description")
      <*> (o .:? "type")

-- | ToJSON StudentRepaymentPlan
instance A.ToJSON StudentRepaymentPlan where
  toJSON StudentRepaymentPlan {..} =
   _omitNulls
      [ "description" .= studentRepaymentPlanDescription
      , "type" .= studentRepaymentPlanType
      ]


-- | Construct a value of type 'StudentRepaymentPlan' (by applying it's required fields, if any)
mkStudentRepaymentPlan
  :: StudentRepaymentPlan
mkStudentRepaymentPlan =
  StudentRepaymentPlan
  { studentRepaymentPlanDescription = Nothing
  , studentRepaymentPlanType = Nothing
  }



-- ** SyncUpdatesAvailableWebhook
-- | SyncUpdatesAvailableWebhook
-- SyncUpdatesAvailableWebhook
-- 
-- Fired when an Item's transactions change. This can be due to any event resulting in new changes, such as an initial 30-day transactions fetch upon the initialization of an Item with transactions, the backfill of historical transactions that occurs shortly after, or when changes are populated from a regularly-scheduled transactions update job. It is recommended to listen for the `SYNC_UPDATES_AVAILABLE` webhook when using the `/transactions/sync` endpoint. Note that when using `/transactions/sync` the older webhooks `INITIAL_UPDATE`, `HISTORICAL_UPDATE`, `DEFAULT_UPDATE`, and `TRANSACTIONS_REMOVED`, which are intended for use with `/transactions/get`, will also continue to be sent in order to maintain backwards compatibility. It is not necessary to listen for and respond to those webhooks when using `/transactions/sync`.  After receipt of this webhook, the new changes can be fetched for the Item from `/transactions/sync`.  Note that to receive this webhook for an Item, `/transactions/sync` must have been called at least once on that Item.
data SyncUpdatesAvailableWebhook = SyncUpdatesAvailableWebhook
  { syncUpdatesAvailableWebhookWebhookType :: !(Text) -- ^ /Required/ "webhook_type" - &#x60;TRANSACTIONS&#x60;
  , syncUpdatesAvailableWebhookWebhookCode :: !(Text) -- ^ /Required/ "webhook_code" - &#x60;SYNC_UPDATES_AVAILABLE&#x60;
  , syncUpdatesAvailableWebhookItemId :: !(ItemId) -- ^ /Required/ "item_id" - The &#x60;item_id&#x60; of the Item associated with this webhook, warning, or error
  , syncUpdatesAvailableWebhookInitialUpdateComplete :: !(Bool) -- ^ /Required/ "initial_update_complete" - Indicates if initial pull information is available.
  , syncUpdatesAvailableWebhookHistoricalUpdateComplete :: !(Bool) -- ^ /Required/ "historical_update_complete" - Indicates if historical pull information is available.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SyncUpdatesAvailableWebhook
instance A.FromJSON SyncUpdatesAvailableWebhook where
  parseJSON = A.withObject "SyncUpdatesAvailableWebhook" $ \o ->
    SyncUpdatesAvailableWebhook
      <$> (o .:  "webhook_type")
      <*> (o .:  "webhook_code")
      <*> (o .:  "item_id")
      <*> (o .:  "initial_update_complete")
      <*> (o .:  "historical_update_complete")

-- | ToJSON SyncUpdatesAvailableWebhook
instance A.ToJSON SyncUpdatesAvailableWebhook where
  toJSON SyncUpdatesAvailableWebhook {..} =
   _omitNulls
      [ "webhook_type" .= syncUpdatesAvailableWebhookWebhookType
      , "webhook_code" .= syncUpdatesAvailableWebhookWebhookCode
      , "item_id" .= syncUpdatesAvailableWebhookItemId
      , "initial_update_complete" .= syncUpdatesAvailableWebhookInitialUpdateComplete
      , "historical_update_complete" .= syncUpdatesAvailableWebhookHistoricalUpdateComplete
      ]


-- | Construct a value of type 'SyncUpdatesAvailableWebhook' (by applying it's required fields, if any)
mkSyncUpdatesAvailableWebhook
  :: Text -- ^ 'syncUpdatesAvailableWebhookWebhookType': `TRANSACTIONS`
  -> Text -- ^ 'syncUpdatesAvailableWebhookWebhookCode': `SYNC_UPDATES_AVAILABLE`
  -> ItemId -- ^ 'syncUpdatesAvailableWebhookItemId': The `item_id` of the Item associated with this webhook, warning, or error
  -> Bool -- ^ 'syncUpdatesAvailableWebhookInitialUpdateComplete': Indicates if initial pull information is available.
  -> Bool -- ^ 'syncUpdatesAvailableWebhookHistoricalUpdateComplete': Indicates if historical pull information is available.
  -> SyncUpdatesAvailableWebhook
mkSyncUpdatesAvailableWebhook syncUpdatesAvailableWebhookWebhookType syncUpdatesAvailableWebhookWebhookCode syncUpdatesAvailableWebhookItemId syncUpdatesAvailableWebhookInitialUpdateComplete syncUpdatesAvailableWebhookHistoricalUpdateComplete =
  SyncUpdatesAvailableWebhook
  { syncUpdatesAvailableWebhookWebhookType
  , syncUpdatesAvailableWebhookWebhookCode
  , syncUpdatesAvailableWebhookItemId
  , syncUpdatesAvailableWebhookInitialUpdateComplete
  , syncUpdatesAvailableWebhookHistoricalUpdateComplete
  }



-- ** Transaction
-- | Transaction
-- Transaction
-- 
-- A representation of a transaction
data Transaction = Transaction
  { transactionTransactionType :: !(Maybe E'TransactionType) -- ^ "transaction_type" - Please use the &#x60;payment_channel&#x60; field, &#x60;transaction_type&#x60; will be deprecated in the future.  &#x60;digital:&#x60; transactions that took place online.  &#x60;place:&#x60; transactions that were made at a physical location.  &#x60;special:&#x60; transactions that relate to banks, e.g. fees or deposits.  &#x60;unresolved:&#x60; transactions that do not fit into the other three types. 
  , transactionTransactionId :: !(Text) -- ^ /Required/ "transaction_id" - The unique ID of the transaction. Like all Plaid identifiers, the &#x60;transaction_id&#x60; is case sensitive.
  , transactionAccountOwner :: !(Maybe Text) -- ^ "account_owner" - The name of the account owner. This field is not typically populated and only relevant when dealing with sub-accounts.
  , transactionPendingTransactionId :: !(Maybe Text) -- ^ "pending_transaction_id" - The ID of a posted transaction&#39;s associated pending transaction, where applicable.
  , transactionPending :: !(Bool) -- ^ /Required/ "pending" - When &#x60;true&#x60;, identifies the transaction as pending or unsettled. Pending transaction details (name, type, amount, category ID) may change before they are settled.
  , transactionPaymentChannel :: !(Maybe E'PaymentChannel) -- ^ "payment_channel" - The channel used to make a payment. &#x60;online:&#x60; transactions that took place online.  &#x60;in store:&#x60; transactions that were made at a physical location.  &#x60;other:&#x60; transactions that relate to banks, e.g. fees or deposits.  This field replaces the &#x60;transaction_type&#x60; field. 
  , transactionPaymentMeta :: !(Maybe PaymentMeta) -- ^ "payment_meta"
  , transactionName :: !(Maybe Text) -- ^ "name" - The merchant name or transaction description.  If the &#x60;transaction&#x60; object was returned by a Transactions endpoint such as &#x60;/transactions/get&#x60;, this field will always appear. If the &#x60;transaction&#x60; object was returned by an Assets endpoint such as &#x60;/asset_report/get/&#x60; or &#x60;/asset_report/pdf/get&#x60;, this field will only appear in an Asset Report with Insights.
  , transactionMerchantName :: !(Maybe Text) -- ^ "merchant_name" - The merchant name, as extracted by Plaid from the &#x60;name&#x60; field.
  , transactionLocation :: !(Maybe Location) -- ^ "location"
  , transactionAuthorizedDate :: !(Maybe Text) -- ^ "authorized_date" - The date that the transaction was authorized. Dates are returned in an ISO 8601 format ( &#x60;YYYY-MM-DD&#x60; ).
  , transactionAuthorizedDatetime :: !(Maybe Text) -- ^ "authorized_datetime" - Date and time when a transaction was authorized in ISO 8601 format ( &#x60;YYYY-MM-DDTHH:mm:ssZ&#x60; ).  This field is only populated for UK institutions. For institutions in other countries, will be &#x60;null&#x60;.
  , transactionDate :: !(Text) -- ^ /Required/ "date" - For pending transactions, the date that the transaction occurred; for posted transactions, the date that the transaction posted. Both dates are returned in an ISO 8601 format ( &#x60;YYYY-MM-DD&#x60; ).
  , transactionDatetime :: !(Maybe Text) -- ^ "datetime" - Date and time when a transaction was posted in ISO 8601 format ( &#x60;YYYY-MM-DDTHH:mm:ssZ&#x60; ).  This field is only populated for UK institutions. For institutions in other countries, will be &#x60;null&#x60;.
  , transactionCategoryId :: !(Maybe Text) -- ^ "category_id" - The ID of the category to which this transaction belongs. See [Categories](https://plaid.com/docs/#category-overview).  If the &#x60;transaction&#x60; object was returned by an Assets endpoint such as &#x60;/asset_report/get/&#x60; or &#x60;/asset_report/pdf/get&#x60;, this field will only appear in an Asset Report with Insights.
  , transactionPersonalFinanceCategory :: !(Maybe PersonalFinanceCategory)
  , transactionCategory :: !(Maybe [Text]) -- ^ "category" - A hierarchical array of the categories to which this transaction belongs. See [Categories](https://plaid.com/docs/#category-overview).  If the &#x60;transaction&#x60; object was returned by an Assets endpoint such as &#x60;/asset_report/get/&#x60; or &#x60;/asset_report/pdf/get&#x60;, this field will only appear in an Asset Report with Insights.
  , transactionUnofficialCurrencyCode :: !(Maybe Text) -- ^ "unofficial_currency_code" - The unofficial currency code associated with the transaction. Always &#x60;null&#x60; if &#x60;iso_currency_code&#x60; is non-&#x60;null&#x60;. Unofficial currency codes are used for currencies that do not have official ISO currency codes, such as cryptocurrencies and the currencies of certain countries.  See the [currency code schema](/docs/api/accounts#currency-code-schema) for a full listing of supported &#x60;iso_currency_code&#x60;s.
  , transactionIsoCurrencyCode :: !(Maybe Text) -- ^ "iso_currency_code" - The ISO-4217 currency code of the transaction. Always &#x60;null&#x60; if &#x60;unofficial_currency_code&#x60; is non-null.
  , transactionAmount :: !(Double) -- ^ /Required/ "amount" - The settled value of the transaction, denominated in the account&#39;s currency, as stated in &#x60;iso_currency_code&#x60; or &#x60;unofficial_currency_code&#x60;. Positive values when money moves out of the account; negative values when money moves in. For example, debit card purchases are positive; credit card payments, direct deposits, and refunds are negative.
  , transactionAccountId :: !(Text) -- ^ /Required/ "account_id" - The ID of the account in which this transaction occurred.
  , transactionTransactionCode :: !(Maybe TransactionCode) -- ^ "transaction_code"
  } deriving (P.Show, P.Eq, P.Typeable)

data PersonalFinanceCategory = PersonalFinanceCategory
  { personalFinanceCategoryPrimary :: !T.Text
  , personalFinanceCategoryDetailed :: !T.Text
  } deriving (P.Show, P.Eq, P.Typeable)


instance A.FromJSON PersonalFinanceCategory where
  parseJSON = A.withObject "PersonalFinanceCategory" $ \o -> do
    PersonalFinanceCategory
      <$> (o .: "primary")
      <*> (o .: "detailed")

-- | ToJSON PersonalFinanceCategory
instance A.ToJSON PersonalFinanceCategory where
  toJSON PersonalFinanceCategory {..} =
   _omitNulls
      [ "primary" .= personalFinanceCategoryPrimary
      , "detailed" .= personalFinanceCategoryDetailed
      ]


-- | FromJSON Transaction
instance A.FromJSON Transaction where
  parseJSON = A.withObject "Transaction" $ \o ->
    Transaction
      <$> (o .:? "transaction_type")
      <*> (o .:  "transaction_id")
      <*> (o .:? "account_owner")
      <*> (o .:? "pending_transaction_id")
      <*> (o .:  "pending")
      <*> (o .:? "payment_channel")
      <*> (o .:? "payment_meta")
      <*> (o .:? "name")
      <*> (o .:? "merchant_name")
      <*> (o .:? "location")
      <*> (o .:? "authorized_date")
      <*> (o .:? "authorized_datetime")
      <*> (o .:  "date")
      <*> (o .:? "datetime")
      <*> (o .:? "category_id")
      <*> (o .:? "personal_finance_category")
      <*> (o .:? "category")
      <*> (o .:? "unofficial_currency_code")
      <*> (o .:? "iso_currency_code")
      <*> (o .:  "amount")
      <*> (o .:  "account_id")
      <*> (o .:? "transaction_code")

-- | ToJSON Transaction
instance A.ToJSON Transaction where
  toJSON Transaction {..} =
   _omitNulls
      [ "transaction_type" .= transactionTransactionType
      , "transaction_id" .= transactionTransactionId
      , "account_owner" .= transactionAccountOwner
      , "pending_transaction_id" .= transactionPendingTransactionId
      , "pending" .= transactionPending
      , "payment_channel" .= transactionPaymentChannel
      , "payment_meta" .= transactionPaymentMeta
      , "name" .= transactionName
      , "merchant_name" .= transactionMerchantName
      , "location" .= transactionLocation
      , "authorized_date" .= transactionAuthorizedDate
      , "authorized_datetime" .= transactionAuthorizedDatetime
      , "date" .= transactionDate
      , "datetime" .= transactionDatetime
      , "category_id" .= transactionCategoryId
      , "category" .= transactionCategory
      , "unofficial_currency_code" .= transactionUnofficialCurrencyCode
      , "iso_currency_code" .= transactionIsoCurrencyCode
      , "amount" .= transactionAmount
      , "account_id" .= transactionAccountId
      , "transaction_code" .= transactionTransactionCode
      , "personal_finance_category" .= transactionPersonalFinanceCategory
      ]


-- | Construct a value of type 'Transaction' (by applying it's required fields, if any)
mkTransaction
  :: Text -- ^ 'transactionTransactionId': The unique ID of the transaction. Like all Plaid identifiers, the `transaction_id` is case sensitive.
  -> Bool -- ^ 'transactionPending': When `true`, identifies the transaction as pending or unsettled. Pending transaction details (name, type, amount, category ID) may change before they are settled.
  -> Text -- ^ 'transactionDate': For pending transactions, the date that the transaction occurred; for posted transactions, the date that the transaction posted. Both dates are returned in an ISO 8601 format ( `YYYY-MM-DD` ).
  -> Double -- ^ 'transactionAmount': The settled value of the transaction, denominated in the account's currency, as stated in `iso_currency_code` or `unofficial_currency_code`. Positive values when money moves out of the account; negative values when money moves in. For example, debit card purchases are positive; credit card payments, direct deposits, and refunds are negative.
  -> Text -- ^ 'transactionAccountId': The ID of the account in which this transaction occurred.
  -> Transaction
mkTransaction transactionTransactionId transactionPending transactionDate transactionAmount transactionAccountId =
  Transaction
  { transactionTransactionType = Nothing
  , transactionTransactionId
  , transactionAccountOwner = Nothing
  , transactionPendingTransactionId = Nothing
  , transactionPending
  , transactionPaymentChannel = Nothing
  , transactionPaymentMeta = Nothing
  , transactionName = Nothing
  , transactionMerchantName = Nothing
  , transactionLocation = Nothing
  , transactionAuthorizedDate = Nothing
  , transactionAuthorizedDatetime = Nothing
  , transactionDate
  , transactionDatetime = Nothing
  , transactionCategoryId = Nothing
  , transactionPersonalFinanceCategory = Nothing
  , transactionCategory = Nothing
  , transactionUnofficialCurrencyCode = Nothing
  , transactionIsoCurrencyCode = Nothing
  , transactionAmount
  , transactionAccountId
  , transactionTransactionCode = Nothing
  }

-- ** TransactionData
-- | TransactionData
-- TransactionData
-- 
-- Information about the matched direct deposit transaction used to verify a user's payroll information.
data TransactionData = TransactionData
  { transactionDataDescription :: !(Text) -- ^ /Required/ "description" - The description of the transaction.
  , transactionDataAmount :: !(Double) -- ^ /Required/ "amount" - The amount of the transaction.
  , transactionDataDate :: !(Text) -- ^ /Required/ "date" - The date of the transaction, in ISO 8601 format (\&quot;yyyy-mm-dd\&quot;).
  , transactionDataAccountId :: !(Text) -- ^ /Required/ "account_id" - A unique identifier for the end user&#39;s account.
  , transactionDataTransactionId :: !(Text) -- ^ /Required/ "transaction_id" - A unique identifier for the transaction.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TransactionData
instance A.FromJSON TransactionData where
  parseJSON = A.withObject "TransactionData" $ \o ->
    TransactionData
      <$> (o .:  "description")
      <*> (o .:  "amount")
      <*> (o .:  "date")
      <*> (o .:  "account_id")
      <*> (o .:  "transaction_id")

-- | ToJSON TransactionData
instance A.ToJSON TransactionData where
  toJSON TransactionData {..} =
   _omitNulls
      [ "description" .= transactionDataDescription
      , "amount" .= transactionDataAmount
      , "date" .= transactionDataDate
      , "account_id" .= transactionDataAccountId
      , "transaction_id" .= transactionDataTransactionId
      ]


-- | Construct a value of type 'TransactionData' (by applying it's required fields, if any)
mkTransactionData
  :: Text -- ^ 'transactionDataDescription': The description of the transaction.
  -> Double -- ^ 'transactionDataAmount': The amount of the transaction.
  -> Text -- ^ 'transactionDataDate': The date of the transaction, in ISO 8601 format (\"yyyy-mm-dd\").
  -> Text -- ^ 'transactionDataAccountId': A unique identifier for the end user's account.
  -> Text -- ^ 'transactionDataTransactionId': A unique identifier for the transaction.
  -> TransactionData
mkTransactionData transactionDataDescription transactionDataAmount transactionDataDate transactionDataAccountId transactionDataTransactionId =
  TransactionData
  { transactionDataDescription
  , transactionDataAmount
  , transactionDataDate
  , transactionDataAccountId
  , transactionDataTransactionId
  }

-- ** TransactionOverride
-- | TransactionOverride
-- TransactionOverride
-- 
-- Data to populate as test transaction data. If not specified, random transactions will be generated instead.
data TransactionOverride = TransactionOverride
  { transactionOverrideTransactionDate :: !(Text) -- ^ /Required/ "transaction_date" - The date of the transaction, in ISO8601 (YYYY-MM-DD) format. Transaction dates in the past or present will result in posted transactions; transaction dates in the future will result in pending transactions. Transactions in Sandbox will move from pending to posted once their transaction date has been reached.
  , transactionOverridePostedDate :: !(Text) -- ^ /Required/ "posted_date" - The date the transaction posted, in ISO8601 (YYYY-MM-DD) format
  , transactionOverrideAmount :: !(Double) -- ^ /Required/ "amount" - The transaction amount. Can be negative.
  , transactionOverrideDescription :: !(Text) -- ^ /Required/ "description" - The transaction description.
  , transactionOverrideCurrency :: !(Maybe Text) -- ^ "currency" - The ISO-4217 format currency code for the transaction.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TransactionOverride
instance A.FromJSON TransactionOverride where
  parseJSON = A.withObject "TransactionOverride" $ \o ->
    TransactionOverride
      <$> (o .:  "transaction_date")
      <*> (o .:  "posted_date")
      <*> (o .:  "amount")
      <*> (o .:  "description")
      <*> (o .:? "currency")

-- | ToJSON TransactionOverride
instance A.ToJSON TransactionOverride where
  toJSON TransactionOverride {..} =
   _omitNulls
      [ "transaction_date" .= transactionOverrideTransactionDate
      , "posted_date" .= transactionOverridePostedDate
      , "amount" .= transactionOverrideAmount
      , "description" .= transactionOverrideDescription
      , "currency" .= transactionOverrideCurrency
      ]


-- | Construct a value of type 'TransactionOverride' (by applying it's required fields, if any)
mkTransactionOverride
  :: Text -- ^ 'transactionOverrideTransactionDate': The date of the transaction, in ISO8601 (YYYY-MM-DD) format. Transaction dates in the past or present will result in posted transactions; transaction dates in the future will result in pending transactions. Transactions in Sandbox will move from pending to posted once their transaction date has been reached.
  -> Text -- ^ 'transactionOverridePostedDate': The date the transaction posted, in ISO8601 (YYYY-MM-DD) format
  -> Double -- ^ 'transactionOverrideAmount': The transaction amount. Can be negative.
  -> Text -- ^ 'transactionOverrideDescription': The transaction description.
  -> TransactionOverride
mkTransactionOverride transactionOverrideTransactionDate transactionOverridePostedDate transactionOverrideAmount transactionOverrideDescription =
  TransactionOverride
  { transactionOverrideTransactionDate
  , transactionOverridePostedDate
  , transactionOverrideAmount
  , transactionOverrideDescription
  , transactionOverrideCurrency = Nothing
  }

-- ** TransactionsGetRequest
-- | TransactionsGetRequest
-- TransactionsGetRequest defines the request schema for `/transactions/get`
data TransactionsGetRequest = TransactionsGetRequest
  { transactionsGetRequestClientId :: !(Maybe Text) -- ^ "client_id" - Your Plaid API &#x60;client_id&#x60;.
  , transactionsGetRequestOptions :: !(Maybe TransactionsGetRequestOptions) -- ^ "options"
  , transactionsGetRequestAccessToken :: !(AccessToken) -- ^ /Required/ "access_token" - The access token associated with the Item data is being requested for.
  , transactionsGetRequestSecret :: !(Maybe Text) -- ^ "secret" - Your Plaid API &#x60;secret&#x60;.
  , transactionsGetRequestStartDate :: !(Date) -- ^ /Required/ "start_date" - The earliest date for which data should be returned. Dates should be formatted as YYYY-MM-DD.
  , transactionsGetRequestEndDate :: !(Date) -- ^ /Required/ "end_date" - The latest date for which data should be returned. Dates should be formatted as YYYY-MM-DD.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TransactionsGetRequest
instance A.FromJSON TransactionsGetRequest where
  parseJSON = A.withObject "TransactionsGetRequest" $ \o ->
    TransactionsGetRequest
      <$> (o .:? "client_id")
      <*> (o .:? "options")
      <*> (o .:  "access_token")
      <*> (o .:? "secret")
      <*> (o .:  "start_date")
      <*> (o .:  "end_date")

-- | ToJSON TransactionsGetRequest
instance A.ToJSON TransactionsGetRequest where
  toJSON TransactionsGetRequest {..} =
   _omitNulls
      [ "client_id" .= transactionsGetRequestClientId
      , "options" .= transactionsGetRequestOptions
      , "access_token" .= transactionsGetRequestAccessToken
      , "secret" .= transactionsGetRequestSecret
      , "start_date" .= transactionsGetRequestStartDate
      , "end_date" .= transactionsGetRequestEndDate
      ]


-- | Construct a value of type 'TransactionsGetRequest' (by applying it's required fields, if any)
mkTransactionsGetRequest
  :: AccessToken -- ^ 'transactionsGetRequestAccessToken': The access token associated with the Item data is being requested for.
  -> Date -- ^ 'transactionsGetRequestStartDate': The earliest date for which data should be returned. Dates should be formatted as YYYY-MM-DD.
  -> Date -- ^ 'transactionsGetRequestEndDate': The latest date for which data should be returned. Dates should be formatted as YYYY-MM-DD.
  -> TransactionsGetRequest
mkTransactionsGetRequest transactionsGetRequestAccessToken transactionsGetRequestStartDate transactionsGetRequestEndDate =
  TransactionsGetRequest
  { transactionsGetRequestClientId = Nothing
  , transactionsGetRequestOptions = Nothing
  , transactionsGetRequestAccessToken
  , transactionsGetRequestSecret = Nothing
  , transactionsGetRequestStartDate
  , transactionsGetRequestEndDate
  }

-- ** TransactionsGetRequestOptions
-- | TransactionsGetRequestOptions
-- An optional object to be used with the request. If specified, `options` must not be `null`.
data TransactionsGetRequestOptions = TransactionsGetRequestOptions
  { transactionsGetRequestOptionsAccountIds :: !(Maybe [Text]) -- ^ "account_ids" - A list of &#x60;account_ids&#x60; to retrieve for the Item  Note: An error will be returned if a provided &#x60;account_id&#x60; is not associated with the Item.
  , transactionsGetRequestOptionsCount :: !(Maybe Int) -- ^ "count" - The number of transactions to fetch.
  , transactionsGetRequestOptionsOffset :: !(Maybe Int) -- ^ "offset" - The number of transactions to skip. The default value is 0.
  , transactionsGetRequestOptionsIncludePersonalFinanceCategory :: !Bool
  , transactionsGetRequestOptionsDaysRequested :: !(Maybe Int)
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TransactionsGetRequestOptions
instance A.FromJSON TransactionsGetRequestOptions where
  parseJSON = A.withObject "TransactionsGetRequestOptions" $ \o ->
    TransactionsGetRequestOptions
      <$> (o .:? "account_ids")
      <*> (o .:? "count")
      <*> (o .:? "offset")
      <*> (o .: "include_personal_finance_category")
      <*> (o .:? "days_requested")

-- | ToJSON TransactionsGetRequestOptions
instance A.ToJSON TransactionsGetRequestOptions where
  toJSON TransactionsGetRequestOptions {..} =
   _omitNulls
      [ "account_ids" .= transactionsGetRequestOptionsAccountIds
      , "count" .= transactionsGetRequestOptionsCount
      , "offset" .= transactionsGetRequestOptionsOffset
      , "include_personal_finance_category" .= transactionsGetRequestOptionsIncludePersonalFinanceCategory
      , "days_requested" .= transactionsGetRequestOptionsDaysRequested
      ]


-- | Construct a value of type 'TransactionsGetRequestOptions' (by applying it's required fields, if any)
mkTransactionsGetRequestOptions
  :: TransactionsGetRequestOptions
mkTransactionsGetRequestOptions =
  TransactionsGetRequestOptions
  { transactionsGetRequestOptionsAccountIds = Nothing
  , transactionsGetRequestOptionsCount = Nothing
  , transactionsGetRequestOptionsOffset = Nothing
  , transactionsGetRequestOptionsIncludePersonalFinanceCategory = False
  , transactionsGetRequestOptionsDaysRequested = Nothing
  }

-- ** TransactionsGetResponse
-- | TransactionsGetResponse
-- TransactionsGetResponse defines the response schema for `/transactions/get`
data TransactionsGetResponse = TransactionsGetResponse
  { transactionsGetResponseAccounts :: !([AccountBase]) -- ^ /Required/ "accounts" - An array containing the &#x60;accounts&#x60; associated with the Item for which transactions are being returned. Each transaction can be mapped to its corresponding account via the &#x60;account_id&#x60; field.
  , transactionsGetResponseTransactions :: !([Transaction]) -- ^ /Required/ "transactions" - An array containing transactions from the account. Transactions are returned in reverse chronological order, with the most recent at the beginning of the array. The maximum number of transactions returned is determined by the &#x60;count&#x60; parameter.
  , transactionsGetResponseTotalTransactions :: !(Int) -- ^ /Required/ "total_transactions" - The total number of transactions available within the date range specified. If &#x60;total_transactions&#x60; is larger than the size of the &#x60;transactions&#x60; array, more transactions are available and can be fetched via manipulating the &#x60;offset&#x60; parameter.
  , transactionsGetResponseItem :: !(Item) -- ^ /Required/ "item"
  , transactionsGetResponseRequestId :: !(Text) -- ^ /Required/ "request_id" - A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TransactionsGetResponse
instance A.FromJSON TransactionsGetResponse where
  parseJSON = A.withObject "TransactionsGetResponse" $ \o ->
    TransactionsGetResponse
      <$> (o .:  "accounts")
      <*> (o .:  "transactions")
      <*> (o .:  "total_transactions")
      <*> (o .:  "item")
      <*> (o .:  "request_id")

-- | ToJSON TransactionsGetResponse
instance A.ToJSON TransactionsGetResponse where
  toJSON TransactionsGetResponse {..} =
   _omitNulls
      [ "accounts" .= transactionsGetResponseAccounts
      , "transactions" .= transactionsGetResponseTransactions
      , "total_transactions" .= transactionsGetResponseTotalTransactions
      , "item" .= transactionsGetResponseItem
      , "request_id" .= transactionsGetResponseRequestId
      ]


-- | Construct a value of type 'TransactionsGetResponse' (by applying it's required fields, if any)
mkTransactionsGetResponse
  :: [AccountBase] -- ^ 'transactionsGetResponseAccounts': An array containing the `accounts` associated with the Item for which transactions are being returned. Each transaction can be mapped to its corresponding account via the `account_id` field.
  -> [Transaction] -- ^ 'transactionsGetResponseTransactions': An array containing transactions from the account. Transactions are returned in reverse chronological order, with the most recent at the beginning of the array. The maximum number of transactions returned is determined by the `count` parameter.
  -> Int -- ^ 'transactionsGetResponseTotalTransactions': The total number of transactions available within the date range specified. If `total_transactions` is larger than the size of the `transactions` array, more transactions are available and can be fetched via manipulating the `offset` parameter.
  -> Item -- ^ 'transactionsGetResponseItem' 
  -> Text -- ^ 'transactionsGetResponseRequestId': A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  -> TransactionsGetResponse
mkTransactionsGetResponse transactionsGetResponseAccounts transactionsGetResponseTransactions transactionsGetResponseTotalTransactions transactionsGetResponseItem transactionsGetResponseRequestId =
  TransactionsGetResponse
  { transactionsGetResponseAccounts
  , transactionsGetResponseTransactions
  , transactionsGetResponseTotalTransactions
  , transactionsGetResponseItem
  , transactionsGetResponseRequestId
  }

-- ** TransactionsRefreshRequest
-- | TransactionsRefreshRequest
-- TransactionsRefreshRequest defines the request schema for `/transactions/refresh`
data TransactionsRefreshRequest = TransactionsRefreshRequest
  { transactionsRefreshRequestClientId :: !(Maybe Text) -- ^ "client_id" - Your Plaid API &#x60;client_id&#x60;.
  , transactionsRefreshRequestAccessToken :: !(AccessToken) -- ^ /Required/ "access_token" - The access token associated with the Item data is being requested for.
  , transactionsRefreshRequestSecret :: !(Maybe Text) -- ^ "secret" - Your Plaid API &#x60;secret&#x60;.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TransactionsRefreshRequest
instance A.FromJSON TransactionsRefreshRequest where
  parseJSON = A.withObject "TransactionsRefreshRequest" $ \o ->
    TransactionsRefreshRequest
      <$> (o .:? "client_id")
      <*> (o .:  "access_token")
      <*> (o .:? "secret")

-- | ToJSON TransactionsRefreshRequest
instance A.ToJSON TransactionsRefreshRequest where
  toJSON TransactionsRefreshRequest {..} =
   _omitNulls
      [ "client_id" .= transactionsRefreshRequestClientId
      , "access_token" .= transactionsRefreshRequestAccessToken
      , "secret" .= transactionsRefreshRequestSecret
      ]


-- | Construct a value of type 'TransactionsRefreshRequest' (by applying it's required fields, if any)
mkTransactionsRefreshRequest
  :: AccessToken -- ^ 'transactionsRefreshRequestAccessToken': The access token associated with the Item data is being requested for.
  -> TransactionsRefreshRequest
mkTransactionsRefreshRequest transactionsRefreshRequestAccessToken =
  TransactionsRefreshRequest
  { transactionsRefreshRequestClientId = Nothing
  , transactionsRefreshRequestAccessToken
  , transactionsRefreshRequestSecret = Nothing
  }

-- ** TransactionsRefreshResponse
-- | TransactionsRefreshResponse
-- TransactionsRefreshResponse defines the response schema for `/transactions/refresh`
data TransactionsRefreshResponse = TransactionsRefreshResponse
  { transactionsRefreshResponseRequestId :: !(Text) -- ^ /Required/ "request_id" - A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TransactionsRefreshResponse
instance A.FromJSON TransactionsRefreshResponse where
  parseJSON = A.withObject "TransactionsRefreshResponse" $ \o ->
    TransactionsRefreshResponse
      <$> (o .:  "request_id")

-- | ToJSON TransactionsRefreshResponse
instance A.ToJSON TransactionsRefreshResponse where
  toJSON TransactionsRefreshResponse {..} =
   _omitNulls
      [ "request_id" .= transactionsRefreshResponseRequestId
      ]


-- | Construct a value of type 'TransactionsRefreshResponse' (by applying it's required fields, if any)
mkTransactionsRefreshResponse
  :: Text -- ^ 'transactionsRefreshResponseRequestId': A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  -> TransactionsRefreshResponse
mkTransactionsRefreshResponse transactionsRefreshResponseRequestId =
  TransactionsRefreshResponse
  { transactionsRefreshResponseRequestId
  }

-- ** TransactionsRemovedWebhook
-- | TransactionsRemovedWebhook
-- TransactionsRemovedWebhook
-- 
-- Fired when transaction(s) for an Item are deleted. The deleted transaction IDs are included in the webhook payload. Plaid will typically check for deleted transaction data several times a day.
data TransactionsRemovedWebhook = TransactionsRemovedWebhook
  { transactionsRemovedWebhookWebhookType :: !(Text) -- ^ /Required/ "webhook_type" - &#x60;TRANSACTIONS&#x60;
  , transactionsRemovedWebhookWebhookCode :: !(Text) -- ^ /Required/ "webhook_code" - &#x60;TRANSACTIONS_REMOVED&#x60;
  , transactionsRemovedWebhookError :: !(Maybe Error) -- ^ "error"
  , transactionsRemovedWebhookRemovedTransactions :: !([Text]) -- ^ /Required/ "removed_transactions" - An array of &#x60;transaction_ids&#x60; corresponding to the removed transactions
  , transactionsRemovedWebhookItemId :: !(ItemId) -- ^ /Required/ "item_id" - The &#x60;item_id&#x60; of the Item associated with this webhook, warning, or error
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TransactionsRemovedWebhook
instance A.FromJSON TransactionsRemovedWebhook where
  parseJSON = A.withObject "TransactionsRemovedWebhook" $ \o ->
    TransactionsRemovedWebhook
      <$> (o .:  "webhook_type")
      <*> (o .:  "webhook_code")
      <*> (o .:? "error")
      <*> (o .:  "removed_transactions")
      <*> (o .:  "item_id")

-- | ToJSON TransactionsRemovedWebhook
instance A.ToJSON TransactionsRemovedWebhook where
  toJSON TransactionsRemovedWebhook {..} =
   _omitNulls
      [ "webhook_type" .= transactionsRemovedWebhookWebhookType
      , "webhook_code" .= transactionsRemovedWebhookWebhookCode
      , "error" .= transactionsRemovedWebhookError
      , "removed_transactions" .= transactionsRemovedWebhookRemovedTransactions
      , "item_id" .= transactionsRemovedWebhookItemId
      ]


-- | Construct a value of type 'TransactionsRemovedWebhook' (by applying it's required fields, if any)
mkTransactionsRemovedWebhook
  :: Text -- ^ 'transactionsRemovedWebhookWebhookType': `TRANSACTIONS`
  -> Text -- ^ 'transactionsRemovedWebhookWebhookCode': `TRANSACTIONS_REMOVED`
  -> [Text] -- ^ 'transactionsRemovedWebhookRemovedTransactions': An array of `transaction_ids` corresponding to the removed transactions
  -> ItemId -- ^ 'transactionsRemovedWebhookItemId': The `item_id` of the Item associated with this webhook, warning, or error
  -> TransactionsRemovedWebhook
mkTransactionsRemovedWebhook transactionsRemovedWebhookWebhookType transactionsRemovedWebhookWebhookCode transactionsRemovedWebhookRemovedTransactions transactionsRemovedWebhookItemId =
  TransactionsRemovedWebhook
  { transactionsRemovedWebhookWebhookType
  , transactionsRemovedWebhookWebhookCode
  , transactionsRemovedWebhookError = Nothing
  , transactionsRemovedWebhookRemovedTransactions
  , transactionsRemovedWebhookItemId
  }

-- ** TransactionsSyncRequest
-- | TransactionsSyncRequest
-- TransactionsSyncRequest defines the request schema for `/transactions/sync`
data TransactionsSyncRequest = TransactionsSyncRequest
  { transactionsSyncRequestClientId :: !(Maybe Text) -- ^ "client_id" - Your Plaid API &#x60;client_id&#x60;.
  , transactionsSyncRequestAccessToken :: !(AccessToken) -- ^ /Required/ "access_token" - The access token associated with the Item data is being requested for.
  , transactionsSyncRequestSecret :: !(Maybe Text) -- ^ "secret" - Your Plaid API &#x60;secret&#x60;.
  , transactionsSyncRequestCursor :: !(Maybe Cursor) -- ^ "cursor" - The cursor value represents the last update requested. Providing it will cause the response to only return changes after this update. If omitted, the entire history of updates will be returned, starting with the first-added transactions on the item. Note: The upper-bound length of this cursor is 256 characters of base64.
  , transactionsSyncRequestCount :: !(Maybe Int) -- ^ "count" - The number of transaction updates to fetch.
  , transactionsSyncRequestOptions :: !(Maybe TransactionsSyncRequestOptions) -- ^ "options"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TransactionsSyncRequest
instance A.FromJSON TransactionsSyncRequest where
  parseJSON = A.withObject "TransactionsSyncRequest" $ \o ->
    TransactionsSyncRequest
      <$> (o .:? "client_id")
      <*> (o .:  "access_token")
      <*> (o .:? "secret")
      <*> (o .:? "cursor")
      <*> (o .:? "count")
      <*> (o .:? "options")

-- | ToJSON TransactionsSyncRequest
instance A.ToJSON TransactionsSyncRequest where
  toJSON TransactionsSyncRequest {..} =
   _omitNulls
      [ "client_id" .= transactionsSyncRequestClientId
      , "access_token" .= transactionsSyncRequestAccessToken
      , "secret" .= transactionsSyncRequestSecret
      , "cursor" .= transactionsSyncRequestCursor
      , "count" .= transactionsSyncRequestCount
      , "options" .= transactionsSyncRequestOptions
      ]


-- | Construct a value of type 'TransactionsSyncRequest' (by applying it's required fields, if any)
mkTransactionsSyncRequest
  :: AccessToken -- ^ 'transactionsSyncRequestAccessToken': The access token associated with the Item data is being requested for.
  -> TransactionsSyncRequest
mkTransactionsSyncRequest transactionsSyncRequestAccessToken =
  TransactionsSyncRequest
  { transactionsSyncRequestClientId = Nothing
  , transactionsSyncRequestAccessToken
  , transactionsSyncRequestSecret = Nothing
  , transactionsSyncRequestCursor = Nothing
  , transactionsSyncRequestCount = Nothing
  , transactionsSyncRequestOptions = Nothing
  }

-- ** TransactionsSyncRequestOptions
-- | TransactionsSyncRequestOptions
-- An optional object to be used with the request. If specified, `options` must not be `null`.
data TransactionsSyncRequestOptions = TransactionsSyncRequestOptions
  { transactionsSyncRequestOptionsIncludeOriginalDescription :: !(Maybe Bool) -- ^ "include_original_description" - Include the raw unparsed transaction description from the financial institution. This field is disabled by default. If you need this information in addition to the parsed data provided, contact your Plaid Account Manager.
  , transactionsSyncRequestOptionsIncludePersonalFinanceCategory :: !(Maybe Bool) -- ^ "include_personal_finance_category" - Include the [&#x60;personal_finance_category&#x60;](https://plaid.com/docs/api/products/transactions/#transactions-sync-response-added-personal-finance-category) object in the response.  See the [&#x60;taxonomy csv file&#x60;](https://plaid.com/documents/transactions-personal-finance-category-taxonomy.csv) for a full list of personal finance categories.  We’re introducing Category Rules - a new beta endpoint that will enable you to change the &#x60;personal_finance_category&#x60; for a transaction based on your users’ needs. When rules are set, the selected category will override the Plaid provided category. To learn more, send a note to transactions-feedback@plaid.com.
  , transactionsSyncRequestOptionsDaysRequested :: !(Maybe Int)
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TransactionsSyncRequestOptions
instance A.FromJSON TransactionsSyncRequestOptions where
  parseJSON = A.withObject "TransactionsSyncRequestOptions" $ \o ->
    TransactionsSyncRequestOptions
      <$> (o .:? "include_original_description")
      <*> (o .:? "include_personal_finance_category")
      <*> (o .:? "days_requested")

-- | ToJSON TransactionsSyncRequestOptions
instance A.ToJSON TransactionsSyncRequestOptions where
  toJSON TransactionsSyncRequestOptions {..} =
   _omitNulls
      [ "include_original_description" .= transactionsSyncRequestOptionsIncludeOriginalDescription
      , "include_personal_finance_category" .= transactionsSyncRequestOptionsIncludePersonalFinanceCategory
      , "days_requested" .= transactionsSyncRequestOptionsDaysRequested
      ]


-- | Construct a value of type 'TransactionsSyncRequestOptions' (by applying it's required fields, if any)
mkTransactionsSyncRequestOptions
  :: TransactionsSyncRequestOptions
mkTransactionsSyncRequestOptions =
  TransactionsSyncRequestOptions
  { transactionsSyncRequestOptionsIncludeOriginalDescription = Nothing
  , transactionsSyncRequestOptionsIncludePersonalFinanceCategory = Nothing
  , transactionsSyncRequestOptionsDaysRequested = Nothing
  }

-- ** TransactionsSyncResponse
-- | TransactionsSyncResponse
-- TransactionsSyncResponse defines the response schema for `/transactions/sync`
data TransactionsSyncResponse = TransactionsSyncResponse
  { transactionsSyncResponseAdded :: !([Transaction]) -- ^ /Required/ "added" - Transactions that have been added to the item since &#x60;cursor&#x60; ordered by ascending last modified time.
  , transactionsSyncResponseModified :: !([Transaction]) -- ^ /Required/ "modified" - Transactions that have been modified on the item since &#x60;cursor&#x60; ordered by ascending last modified time.
  , transactionsSyncResponseRemoved :: !([RemovedTransaction]) -- ^ /Required/ "removed" - Transactions that have been removed from the item since &#x60;cursor&#x60; ordered by ascending last modified time.
  , transactionsSyncResponseNextCursor :: !(Cursor) -- ^ /Required/ "next_cursor" - Cursor used for fetching any future updates after the latest update provided in this response.
  , transactionsSyncResponseHasMore :: !(Bool) -- ^ /Required/ "has_more" - Represents if more than requested count of transaction updates exist. If true, the additional updates can be fetched by making an additional request with &#x60;cursor&#x60; set to &#x60;next_cursor&#x60;.
  , transactionsSyncResponseRequestId :: !(Text) -- ^ /Required/ "request_id" - A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TransactionsSyncResponse
instance A.FromJSON TransactionsSyncResponse where
  parseJSON = A.withObject "TransactionsSyncResponse" $ \o ->
    TransactionsSyncResponse
      <$> (o .:  "added")
      <*> (o .:  "modified")
      <*> (o .:  "removed")
      <*> (o .:  "next_cursor")
      <*> (o .:  "has_more")
      <*> (o .:  "request_id")

-- | ToJSON TransactionsSyncResponse
instance A.ToJSON TransactionsSyncResponse where
  toJSON TransactionsSyncResponse {..} =
   _omitNulls
      [ "added" .= transactionsSyncResponseAdded
      , "modified" .= transactionsSyncResponseModified
      , "removed" .= transactionsSyncResponseRemoved
      , "next_cursor" .= transactionsSyncResponseNextCursor
      , "has_more" .= transactionsSyncResponseHasMore
      , "request_id" .= transactionsSyncResponseRequestId
      ]


-- | Construct a value of type 'TransactionsSyncResponse' (by applying it's required fields, if any)
mkTransactionsSyncResponse
  :: [Transaction] -- ^ 'transactionsSyncResponseAdded': Transactions that have been added to the item since `cursor` ordered by ascending last modified time.
  -> [Transaction] -- ^ 'transactionsSyncResponseModified': Transactions that have been modified on the item since `cursor` ordered by ascending last modified time.
  -> [RemovedTransaction] -- ^ 'transactionsSyncResponseRemoved': Transactions that have been removed from the item since `cursor` ordered by ascending last modified time.
  -> Cursor -- ^ 'transactionsSyncResponseNextCursor': Cursor used for fetching any future updates after the latest update provided in this response.
  -> Bool -- ^ 'transactionsSyncResponseHasMore': Represents if more than requested count of transaction updates exist. If true, the additional updates can be fetched by making an additional request with `cursor` set to `next_cursor`.
  -> Text -- ^ 'transactionsSyncResponseRequestId': A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  -> TransactionsSyncResponse
mkTransactionsSyncResponse transactionsSyncResponseAdded transactionsSyncResponseModified transactionsSyncResponseRemoved transactionsSyncResponseNextCursor transactionsSyncResponseHasMore transactionsSyncResponseRequestId =
  TransactionsSyncResponse
  { transactionsSyncResponseAdded
  , transactionsSyncResponseModified
  , transactionsSyncResponseRemoved
  , transactionsSyncResponseNextCursor
  , transactionsSyncResponseHasMore
  , transactionsSyncResponseRequestId
  }

-- ** UserCustomPassword
-- | UserCustomPassword
-- UserCustomPassword
-- 
-- Custom test accounts are configured with a JSON configuration object formulated according to the schema below. All fields are optional. Sending an empty object as a configuration will result in an account configured with random balances and transaction history.
data UserCustomPassword = UserCustomPassword
  { userCustomPasswordVersion :: !(Maybe Text) -- ^ "version" - The version of the password schema to use, possible values are 1 or 2. The default value is 2. You should only specify 1 if you know it is necessary for your test suite.
  , userCustomPasswordSeed :: !(Text) -- ^ /Required/ "seed" - A seed, in the form of a string, that will be used to randomly generate account and transaction data, if this data is not specified using the &#x60;override_accounts&#x60; argument. If no seed is specified, the randomly generated data will be different each time.  Note that transactions data is generated relative to the Item&#39;s creation date. Different Items created on different dates with the same seed for transactions data will have different dates for the transactions. The number of days between each transaction and the Item creation will remain constant. For example, an Item created on December 15 might show a transaction on December 14. An Item created on December 20, using the same seed, would show that same transaction occurring on December 19.
  , userCustomPasswordOverrideAccounts :: !([OverrideAccounts]) -- ^ /Required/ "override_accounts" - An array of account overrides to configure the accounts for the Item. By default, if no override is specified, transactions and account data will be randomly generated based on the account type and subtype, and other products will have fixed or empty data.
  , userCustomPasswordMfa :: !(MFA) -- ^ /Required/ "mfa"
  , userCustomPasswordRecaptcha :: !(Text) -- ^ /Required/ "recaptcha" - You may trigger a reCAPTCHA in Plaid Link in the Sandbox environment by using the recaptcha field. Possible values are &#x60;good&#x60; or &#x60;bad&#x60;. A value of &#x60;good&#x60; will result in successful Item creation and &#x60;bad&#x60; will result in a &#x60;RECAPTCHA_BAD&#x60; error to simulate a failed reCAPTCHA. Both values require the reCAPTCHA to be manually solved within Plaid Link.
  , userCustomPasswordForceError :: !(Text) -- ^ /Required/ "force_error" - An error code to force on Item creation. Possible values are:  &#x60;\&quot;INSTITUTION_NOT_RESPONDING\&quot;&#x60; &#x60;\&quot;INSTITUTION_NO_LONGER_SUPPORTED\&quot;&#x60; &#x60;\&quot;INVALID_CREDENTIALS\&quot;&#x60; &#x60;\&quot;INVALID_MFA\&quot;&#x60; &#x60;\&quot;ITEM_LOCKED\&quot;&#x60; &#x60;\&quot;ITEM_LOGIN_REQUIRED\&quot;&#x60; &#x60;\&quot;ITEM_NOT_SUPPORTED\&quot;&#x60; &#x60;\&quot;INVALID_LINK_TOKEN\&quot;&#x60; &#x60;\&quot;MFA_NOT_SUPPORTED\&quot;&#x60; &#x60;\&quot;NO_ACCOUNTS\&quot;&#x60; &#x60;\&quot;PLAID_ERROR\&quot;&#x60; &#x60;\&quot;PRODUCTS_NOT_SUPPORTED\&quot;&#x60; &#x60;\&quot;USER_SETUP_REQUIRED\&quot;&#x60;
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserCustomPassword
instance A.FromJSON UserCustomPassword where
  parseJSON = A.withObject "UserCustomPassword" $ \o ->
    UserCustomPassword
      <$> (o .:? "version")
      <*> (o .:  "seed")
      <*> (o .:  "override_accounts")
      <*> (o .:  "mfa")
      <*> (o .:  "recaptcha")
      <*> (o .:  "force_error")

-- | ToJSON UserCustomPassword
instance A.ToJSON UserCustomPassword where
  toJSON UserCustomPassword {..} =
   _omitNulls
      [ "version" .= userCustomPasswordVersion
      , "seed" .= userCustomPasswordSeed
      , "override_accounts" .= userCustomPasswordOverrideAccounts
      , "mfa" .= userCustomPasswordMfa
      , "recaptcha" .= userCustomPasswordRecaptcha
      , "force_error" .= userCustomPasswordForceError
      ]


-- | Construct a value of type 'UserCustomPassword' (by applying it's required fields, if any)
mkUserCustomPassword
  :: Text -- ^ 'userCustomPasswordSeed': A seed, in the form of a string, that will be used to randomly generate account and transaction data, if this data is not specified using the `override_accounts` argument. If no seed is specified, the randomly generated data will be different each time.  Note that transactions data is generated relative to the Item's creation date. Different Items created on different dates with the same seed for transactions data will have different dates for the transactions. The number of days between each transaction and the Item creation will remain constant. For example, an Item created on December 15 might show a transaction on December 14. An Item created on December 20, using the same seed, would show that same transaction occurring on December 19.
  -> [OverrideAccounts] -- ^ 'userCustomPasswordOverrideAccounts': An array of account overrides to configure the accounts for the Item. By default, if no override is specified, transactions and account data will be randomly generated based on the account type and subtype, and other products will have fixed or empty data.
  -> MFA -- ^ 'userCustomPasswordMfa' 
  -> Text -- ^ 'userCustomPasswordRecaptcha': You may trigger a reCAPTCHA in Plaid Link in the Sandbox environment by using the recaptcha field. Possible values are `good` or `bad`. A value of `good` will result in successful Item creation and `bad` will result in a `RECAPTCHA_BAD` error to simulate a failed reCAPTCHA. Both values require the reCAPTCHA to be manually solved within Plaid Link.
  -> Text -- ^ 'userCustomPasswordForceError': An error code to force on Item creation. Possible values are:  `\"INSTITUTION_NOT_RESPONDING\"` `\"INSTITUTION_NO_LONGER_SUPPORTED\"` `\"INVALID_CREDENTIALS\"` `\"INVALID_MFA\"` `\"ITEM_LOCKED\"` `\"ITEM_LOGIN_REQUIRED\"` `\"ITEM_NOT_SUPPORTED\"` `\"INVALID_LINK_TOKEN\"` `\"MFA_NOT_SUPPORTED\"` `\"NO_ACCOUNTS\"` `\"PLAID_ERROR\"` `\"PRODUCTS_NOT_SUPPORTED\"` `\"USER_SETUP_REQUIRED\"`
  -> UserCustomPassword
mkUserCustomPassword userCustomPasswordSeed userCustomPasswordOverrideAccounts userCustomPasswordMfa userCustomPasswordRecaptcha userCustomPasswordForceError =
  UserCustomPassword
  { userCustomPasswordVersion = Nothing
  , userCustomPasswordSeed
  , userCustomPasswordOverrideAccounts
  , userCustomPasswordMfa
  , userCustomPasswordRecaptcha
  , userCustomPasswordForceError
  }

-- ** UserPermissionRevokedWebhook
-- | UserPermissionRevokedWebhook
-- UserPermissionRevokedWebhook
-- 
-- The `USER_PERMISSION_REVOKED` webhook is fired to when an end user has used the [my.plaid.com portal](https://my.plaid.com) to revoke the permission that they previously granted to access an Item. Once access to an Item has been revoked, it cannot be restored. If the user subsequently returns to your application, a new Item must be created for the user.
data UserPermissionRevokedWebhook = UserPermissionRevokedWebhook
  { userPermissionRevokedWebhookWebhookType :: !(Text) -- ^ /Required/ "webhook_type" - &#x60;ITEM&#x60;
  , userPermissionRevokedWebhookWebhookCode :: !(Text) -- ^ /Required/ "webhook_code" - &#x60;USER_PERMISSION_REVOKED&#x60;
  , userPermissionRevokedWebhookItemId :: !(ItemId) -- ^ /Required/ "item_id" - The &#x60;item_id&#x60; of the Item associated with this webhook, warning, or error
  , userPermissionRevokedWebhookError :: !(Maybe Error) -- ^ "error"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserPermissionRevokedWebhook
instance A.FromJSON UserPermissionRevokedWebhook where
  parseJSON = A.withObject "UserPermissionRevokedWebhook" $ \o ->
    UserPermissionRevokedWebhook
      <$> (o .:  "webhook_type")
      <*> (o .:  "webhook_code")
      <*> (o .:  "item_id")
      <*> (o .:? "error")

-- | ToJSON UserPermissionRevokedWebhook
instance A.ToJSON UserPermissionRevokedWebhook where
  toJSON UserPermissionRevokedWebhook {..} =
   _omitNulls
      [ "webhook_type" .= userPermissionRevokedWebhookWebhookType
      , "webhook_code" .= userPermissionRevokedWebhookWebhookCode
      , "item_id" .= userPermissionRevokedWebhookItemId
      , "error" .= userPermissionRevokedWebhookError
      ]


-- | Construct a value of type 'UserPermissionRevokedWebhook' (by applying it's required fields, if any)
mkUserPermissionRevokedWebhook
  :: Text -- ^ 'userPermissionRevokedWebhookWebhookType': `ITEM`
  -> Text -- ^ 'userPermissionRevokedWebhookWebhookCode': `USER_PERMISSION_REVOKED`
  -> ItemId -- ^ 'userPermissionRevokedWebhookItemId': The `item_id` of the Item associated with this webhook, warning, or error
  -> UserPermissionRevokedWebhook
mkUserPermissionRevokedWebhook userPermissionRevokedWebhookWebhookType userPermissionRevokedWebhookWebhookCode userPermissionRevokedWebhookItemId =
  UserPermissionRevokedWebhook
  { userPermissionRevokedWebhookWebhookType
  , userPermissionRevokedWebhookWebhookCode
  , userPermissionRevokedWebhookItemId
  , userPermissionRevokedWebhookError = Nothing
  }

-- ** VerificationExpiredWebhook
-- | VerificationExpiredWebhook
-- VerificationExpiredWebhook
-- 
-- Fired when an Item was not verified via micro-deposits after ten days since the micro-deposit was made.
data VerificationExpiredWebhook = VerificationExpiredWebhook
  { verificationExpiredWebhookWebhookType :: !(Text) -- ^ /Required/ "webhook_type" - &#x60;AUTH&#x60;
  , verificationExpiredWebhookWebhookCode :: !(Text) -- ^ /Required/ "webhook_code" - &#x60;VERIFICATION_EXPIRED&#x60;
  , verificationExpiredWebhookItemId :: !(ItemId) -- ^ /Required/ "item_id" - The &#x60;item_id&#x60; of the Item associated with this webhook, warning, or error
  , verificationExpiredWebhookAccountId :: !(Text) -- ^ /Required/ "account_id" - The &#x60;account_id&#x60; of the account associated with the webhook
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON VerificationExpiredWebhook
instance A.FromJSON VerificationExpiredWebhook where
  parseJSON = A.withObject "VerificationExpiredWebhook" $ \o ->
    VerificationExpiredWebhook
      <$> (o .:  "webhook_type")
      <*> (o .:  "webhook_code")
      <*> (o .:  "item_id")
      <*> (o .:  "account_id")

-- | ToJSON VerificationExpiredWebhook
instance A.ToJSON VerificationExpiredWebhook where
  toJSON VerificationExpiredWebhook {..} =
   _omitNulls
      [ "webhook_type" .= verificationExpiredWebhookWebhookType
      , "webhook_code" .= verificationExpiredWebhookWebhookCode
      , "item_id" .= verificationExpiredWebhookItemId
      , "account_id" .= verificationExpiredWebhookAccountId
      ]


-- | Construct a value of type 'VerificationExpiredWebhook' (by applying it's required fields, if any)
mkVerificationExpiredWebhook
  :: Text -- ^ 'verificationExpiredWebhookWebhookType': `AUTH`
  -> Text -- ^ 'verificationExpiredWebhookWebhookCode': `VERIFICATION_EXPIRED`
  -> ItemId -- ^ 'verificationExpiredWebhookItemId': The `item_id` of the Item associated with this webhook, warning, or error
  -> Text -- ^ 'verificationExpiredWebhookAccountId': The `account_id` of the account associated with the webhook
  -> VerificationExpiredWebhook
mkVerificationExpiredWebhook verificationExpiredWebhookWebhookType verificationExpiredWebhookWebhookCode verificationExpiredWebhookItemId verificationExpiredWebhookAccountId =
  VerificationExpiredWebhook
  { verificationExpiredWebhookWebhookType
  , verificationExpiredWebhookWebhookCode
  , verificationExpiredWebhookItemId
  , verificationExpiredWebhookAccountId
  }

-- ** Warning
-- | Warning
-- Warning
-- 
-- It is possible for an Asset Report to be returned with missing account owner information. In such cases, the Asset Report will contain warning data in the response, indicating why obtaining the owner information failed.
data Warning = Warning
  { warningWarningType :: !(Text) -- ^ /Required/ "warning_type" - The warning type, which will always be &#x60;ASSET_REPORT_WARNING&#x60;
  , warningWarningCode :: !(Text) -- ^ /Required/ "warning_code" - The warning code identifies a specific kind of warning. Currently, the only possible warning code is &#x60;OWNERS_UNAVAILABLE&#x60;, which indicates that account-owner information is not available.
  , warningCause :: !(Cause) -- ^ /Required/ "cause"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Warning
instance A.FromJSON Warning where
  parseJSON = A.withObject "Warning" $ \o ->
    Warning
      <$> (o .:  "warning_type")
      <*> (o .:  "warning_code")
      <*> (o .:  "cause")

-- | ToJSON Warning
instance A.ToJSON Warning where
  toJSON Warning {..} =
   _omitNulls
      [ "warning_type" .= warningWarningType
      , "warning_code" .= warningWarningCode
      , "cause" .= warningCause
      ]


-- | Construct a value of type 'Warning' (by applying it's required fields, if any)
mkWarning
  :: Text -- ^ 'warningWarningType': The warning type, which will always be `ASSET_REPORT_WARNING`
  -> Text -- ^ 'warningWarningCode': The warning code identifies a specific kind of warning. Currently, the only possible warning code is `OWNERS_UNAVAILABLE`, which indicates that account-owner information is not available.
  -> Cause -- ^ 'warningCause' 
  -> Warning
mkWarning warningWarningType warningWarningCode warningCause =
  Warning
  { warningWarningType
  , warningWarningCode
  , warningCause
  }

-- ** WebhookUpdateAcknowledgedWebhook
-- | WebhookUpdateAcknowledgedWebhook
-- WebhookUpdateAcknowledgedWebhook
-- 
-- Fired when an Item's webhook is updated. This will be sent to the newly specified webhook.
data WebhookUpdateAcknowledgedWebhook = WebhookUpdateAcknowledgedWebhook
  { webhookUpdateAcknowledgedWebhookWebhookType :: !(Text) -- ^ /Required/ "webhook_type" - &#x60;ITEM&#x60;
  , webhookUpdateAcknowledgedWebhookWebhookCode :: !(Text) -- ^ /Required/ "webhook_code" - &#x60;WEBHOOK_UPDATE_ACKNOWLEDGED&#x60;
  , webhookUpdateAcknowledgedWebhookItemId :: !(ItemId) -- ^ /Required/ "item_id" - The &#x60;item_id&#x60; of the Item associated with this webhook, warning, or error
  , webhookUpdateAcknowledgedWebhookNewWebhookUrl :: !(Text) -- ^ /Required/ "new_webhook_url" - The new webhook URL
  , webhookUpdateAcknowledgedWebhookError :: !(Maybe Error) -- ^ "error"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON WebhookUpdateAcknowledgedWebhook
instance A.FromJSON WebhookUpdateAcknowledgedWebhook where
  parseJSON = A.withObject "WebhookUpdateAcknowledgedWebhook" $ \o ->
    WebhookUpdateAcknowledgedWebhook
      <$> (o .:  "webhook_type")
      <*> (o .:  "webhook_code")
      <*> (o .:  "item_id")
      <*> (o .:  "new_webhook_url")
      <*> (o .:? "error")

-- | ToJSON WebhookUpdateAcknowledgedWebhook
instance A.ToJSON WebhookUpdateAcknowledgedWebhook where
  toJSON WebhookUpdateAcknowledgedWebhook {..} =
   _omitNulls
      [ "webhook_type" .= webhookUpdateAcknowledgedWebhookWebhookType
      , "webhook_code" .= webhookUpdateAcknowledgedWebhookWebhookCode
      , "item_id" .= webhookUpdateAcknowledgedWebhookItemId
      , "new_webhook_url" .= webhookUpdateAcknowledgedWebhookNewWebhookUrl
      , "error" .= webhookUpdateAcknowledgedWebhookError
      ]


-- | Construct a value of type 'WebhookUpdateAcknowledgedWebhook' (by applying it's required fields, if any)
mkWebhookUpdateAcknowledgedWebhook
  :: Text -- ^ 'webhookUpdateAcknowledgedWebhookWebhookType': `ITEM`
  -> Text -- ^ 'webhookUpdateAcknowledgedWebhookWebhookCode': `WEBHOOK_UPDATE_ACKNOWLEDGED`
  -> ItemId -- ^ 'webhookUpdateAcknowledgedWebhookItemId': The `item_id` of the Item associated with this webhook, warning, or error
  -> Text -- ^ 'webhookUpdateAcknowledgedWebhookNewWebhookUrl': The new webhook URL
  -> WebhookUpdateAcknowledgedWebhook
mkWebhookUpdateAcknowledgedWebhook webhookUpdateAcknowledgedWebhookWebhookType webhookUpdateAcknowledgedWebhookWebhookCode webhookUpdateAcknowledgedWebhookItemId webhookUpdateAcknowledgedWebhookNewWebhookUrl =
  WebhookUpdateAcknowledgedWebhook
  { webhookUpdateAcknowledgedWebhookWebhookType
  , webhookUpdateAcknowledgedWebhookWebhookCode
  , webhookUpdateAcknowledgedWebhookItemId
  , webhookUpdateAcknowledgedWebhookNewWebhookUrl
  , webhookUpdateAcknowledgedWebhookError = Nothing
  }

-- ** WebhookVerificationKeyGetRequest
-- | WebhookVerificationKeyGetRequest
-- WebhookVerificationKeyGetRequest defines the request schema for `/webhook_verification_key/get`
data WebhookVerificationKeyGetRequest = WebhookVerificationKeyGetRequest
  { webhookVerificationKeyGetRequestClientId :: !(Maybe Text) -- ^ "client_id" - Your Plaid API &#x60;client_id&#x60;.
  , webhookVerificationKeyGetRequestSecret :: !(Maybe Text) -- ^ "secret" - Your Plaid API &#x60;secret&#x60;.
  , webhookVerificationKeyGetRequestKeyId :: !(Text) -- ^ /Required/ "key_id" - The key ID ( &#x60;kid&#x60; ) from the JWT header.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON WebhookVerificationKeyGetRequest
instance A.FromJSON WebhookVerificationKeyGetRequest where
  parseJSON = A.withObject "WebhookVerificationKeyGetRequest" $ \o ->
    WebhookVerificationKeyGetRequest
      <$> (o .:? "client_id")
      <*> (o .:? "secret")
      <*> (o .:  "key_id")

-- | ToJSON WebhookVerificationKeyGetRequest
instance A.ToJSON WebhookVerificationKeyGetRequest where
  toJSON WebhookVerificationKeyGetRequest {..} =
   _omitNulls
      [ "client_id" .= webhookVerificationKeyGetRequestClientId
      , "secret" .= webhookVerificationKeyGetRequestSecret
      , "key_id" .= webhookVerificationKeyGetRequestKeyId
      ]


-- | Construct a value of type 'WebhookVerificationKeyGetRequest' (by applying it's required fields, if any)
mkWebhookVerificationKeyGetRequest
  :: Text -- ^ 'webhookVerificationKeyGetRequestKeyId': The key ID ( `kid` ) from the JWT header.
  -> WebhookVerificationKeyGetRequest
mkWebhookVerificationKeyGetRequest webhookVerificationKeyGetRequestKeyId =
  WebhookVerificationKeyGetRequest
  { webhookVerificationKeyGetRequestClientId = Nothing
  , webhookVerificationKeyGetRequestSecret = Nothing
  , webhookVerificationKeyGetRequestKeyId
  }

-- ** WebhookVerificationKeyGetResponse
-- | WebhookVerificationKeyGetResponse
-- WebhookVerificationKeyGetResponse defines the response schema for `/webhook_verification_key/get`
data WebhookVerificationKeyGetResponse = WebhookVerificationKeyGetResponse
  { webhookVerificationKeyGetResponseKey :: !(JWKPublicKey) -- ^ /Required/ "key"
  , webhookVerificationKeyGetResponseRequestId :: !(Text) -- ^ /Required/ "request_id" - A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON WebhookVerificationKeyGetResponse
instance A.FromJSON WebhookVerificationKeyGetResponse where
  parseJSON = A.withObject "WebhookVerificationKeyGetResponse" $ \o ->
    WebhookVerificationKeyGetResponse
      <$> (o .:  "key")
      <*> (o .:  "request_id")

-- | ToJSON WebhookVerificationKeyGetResponse
instance A.ToJSON WebhookVerificationKeyGetResponse where
  toJSON WebhookVerificationKeyGetResponse {..} =
   _omitNulls
      [ "key" .= webhookVerificationKeyGetResponseKey
      , "request_id" .= webhookVerificationKeyGetResponseRequestId
      ]


-- | Construct a value of type 'WebhookVerificationKeyGetResponse' (by applying it's required fields, if any)
mkWebhookVerificationKeyGetResponse
  :: JWKPublicKey -- ^ 'webhookVerificationKeyGetResponseKey' 
  -> Text -- ^ 'webhookVerificationKeyGetResponseRequestId': A unique identifier for the request, which can be used for troubleshooting. This identifier, like all Plaid identifiers, is case sensitive.
  -> WebhookVerificationKeyGetResponse
mkWebhookVerificationKeyGetResponse webhookVerificationKeyGetResponseKey webhookVerificationKeyGetResponseRequestId =
  WebhookVerificationKeyGetResponse
  { webhookVerificationKeyGetResponseKey
  , webhookVerificationKeyGetResponseRequestId
  }

-- ** YTDGrossIncomeSummaryFieldNumber
-- | YTDGrossIncomeSummaryFieldNumber
data YTDGrossIncomeSummaryFieldNumber = YTDGrossIncomeSummaryFieldNumber
  { yTDGrossIncomeSummaryFieldNumberValue :: !(Double) -- ^ /Required/ "value" - The value of the field.
  , yTDGrossIncomeSummaryFieldNumberVerificationStatus :: !(VerificationStatus) -- ^ /Required/ "verification_status"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON YTDGrossIncomeSummaryFieldNumber
instance A.FromJSON YTDGrossIncomeSummaryFieldNumber where
  parseJSON = A.withObject "YTDGrossIncomeSummaryFieldNumber" $ \o ->
    YTDGrossIncomeSummaryFieldNumber
      <$> (o .:  "value")
      <*> (o .:  "verification_status")

-- | ToJSON YTDGrossIncomeSummaryFieldNumber
instance A.ToJSON YTDGrossIncomeSummaryFieldNumber where
  toJSON YTDGrossIncomeSummaryFieldNumber {..} =
   _omitNulls
      [ "value" .= yTDGrossIncomeSummaryFieldNumberValue
      , "verification_status" .= yTDGrossIncomeSummaryFieldNumberVerificationStatus
      ]


-- | Construct a value of type 'YTDGrossIncomeSummaryFieldNumber' (by applying it's required fields, if any)
mkYTDGrossIncomeSummaryFieldNumber
  :: Double -- ^ 'yTDGrossIncomeSummaryFieldNumberValue': The value of the field.
  -> VerificationStatus -- ^ 'yTDGrossIncomeSummaryFieldNumberVerificationStatus' 
  -> YTDGrossIncomeSummaryFieldNumber
mkYTDGrossIncomeSummaryFieldNumber yTDGrossIncomeSummaryFieldNumberValue yTDGrossIncomeSummaryFieldNumberVerificationStatus =
  YTDGrossIncomeSummaryFieldNumber
  { yTDGrossIncomeSummaryFieldNumberValue
  , yTDGrossIncomeSummaryFieldNumberVerificationStatus
  }

-- ** YTDNetIncomeSummaryFieldNumber
-- | YTDNetIncomeSummaryFieldNumber
data YTDNetIncomeSummaryFieldNumber = YTDNetIncomeSummaryFieldNumber
  { yTDNetIncomeSummaryFieldNumberValue :: !(Double) -- ^ /Required/ "value" - The value of the field.
  , yTDNetIncomeSummaryFieldNumberVerificationStatus :: !(VerificationStatus) -- ^ /Required/ "verification_status"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON YTDNetIncomeSummaryFieldNumber
instance A.FromJSON YTDNetIncomeSummaryFieldNumber where
  parseJSON = A.withObject "YTDNetIncomeSummaryFieldNumber" $ \o ->
    YTDNetIncomeSummaryFieldNumber
      <$> (o .:  "value")
      <*> (o .:  "verification_status")

-- | ToJSON YTDNetIncomeSummaryFieldNumber
instance A.ToJSON YTDNetIncomeSummaryFieldNumber where
  toJSON YTDNetIncomeSummaryFieldNumber {..} =
   _omitNulls
      [ "value" .= yTDNetIncomeSummaryFieldNumberValue
      , "verification_status" .= yTDNetIncomeSummaryFieldNumberVerificationStatus
      ]


-- | Construct a value of type 'YTDNetIncomeSummaryFieldNumber' (by applying it's required fields, if any)
mkYTDNetIncomeSummaryFieldNumber
  :: Double -- ^ 'yTDNetIncomeSummaryFieldNumberValue': The value of the field.
  -> VerificationStatus -- ^ 'yTDNetIncomeSummaryFieldNumberVerificationStatus' 
  -> YTDNetIncomeSummaryFieldNumber
mkYTDNetIncomeSummaryFieldNumber yTDNetIncomeSummaryFieldNumberValue yTDNetIncomeSummaryFieldNumberVerificationStatus =
  YTDNetIncomeSummaryFieldNumber
  { yTDNetIncomeSummaryFieldNumberValue
  , yTDNetIncomeSummaryFieldNumberVerificationStatus
  }


-- * Enums


-- ** ACHClass

-- | Enum of 'Text' .
-- Specifies the use case of the transfer.  Required for transfers on an ACH network.  `\"arc\"` - Accounts Receivable Entry  `\"cbr`\" - Cross Border Entry  `\"ccd\"` - Corporate Credit or Debit - fund transfer between two corporate bank accounts  `\"cie\"` - Customer Initiated Entry  `\"cor\"` - Automated Notification of Change  `\"ctx\"` - Corporate Trade Exchange  `\"iat\"` - International  `\"mte\"` - Machine Transfer Entry  `\"pbr\"` - Cross Border Entry  `\"pop`\" - Point-of-Purchase Entry  `\"pos\"` - Point-of-Sale Entry  `\"ppd\"` - Prearranged Payment or Deposit - the transfer is part of a pre-existing relationship with a consumer, eg. bill payment  `\"rck\"` - Re-presented Check Entry  `\"tel\"` - Telephone-Initiated Entry  `\"web\"` - Internet-Initiated Entry - debits from a consumer’s account where their authorization is obtained over the Internet
data ACHClass
  = ACHClass'Arc -- ^ @"arc"@
  | ACHClass'Cbr -- ^ @"cbr"@
  | ACHClass'Ccd -- ^ @"ccd"@
  | ACHClass'Cie -- ^ @"cie"@
  | ACHClass'Cor -- ^ @"cor"@
  | ACHClass'Ctx -- ^ @"ctx"@
  | ACHClass'Iat -- ^ @"iat"@
  | ACHClass'Mte -- ^ @"mte"@
  | ACHClass'Pbr -- ^ @"pbr"@
  | ACHClass'Pop -- ^ @"pop"@
  | ACHClass'Pos -- ^ @"pos"@
  | ACHClass'Ppd -- ^ @"ppd"@
  | ACHClass'Rck -- ^ @"rck"@
  | ACHClass'Tel -- ^ @"tel"@
  | ACHClass'Web -- ^ @"web"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON ACHClass where toJSON = A.toJSON . fromACHClass
instance A.FromJSON ACHClass where parseJSON o = P.either P.fail (pure . P.id) . toACHClass =<< A.parseJSON o
instance WH.ToHttpApiData ACHClass where toQueryParam = WH.toQueryParam . fromACHClass
instance WH.FromHttpApiData ACHClass where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toACHClass
instance MimeRender MimeMultipartFormData ACHClass where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'ACHClass' enum
fromACHClass :: ACHClass -> Text
fromACHClass = \case
  ACHClass'Arc -> "arc"
  ACHClass'Cbr -> "cbr"
  ACHClass'Ccd -> "ccd"
  ACHClass'Cie -> "cie"
  ACHClass'Cor -> "cor"
  ACHClass'Ctx -> "ctx"
  ACHClass'Iat -> "iat"
  ACHClass'Mte -> "mte"
  ACHClass'Pbr -> "pbr"
  ACHClass'Pop -> "pop"
  ACHClass'Pos -> "pos"
  ACHClass'Ppd -> "ppd"
  ACHClass'Rck -> "rck"
  ACHClass'Tel -> "tel"
  ACHClass'Web -> "web"

-- | parse 'ACHClass' enum
toACHClass :: Text -> P.Either String ACHClass
toACHClass = \case
  "arc" -> P.Right ACHClass'Arc
  "cbr" -> P.Right ACHClass'Cbr
  "ccd" -> P.Right ACHClass'Ccd
  "cie" -> P.Right ACHClass'Cie
  "cor" -> P.Right ACHClass'Cor
  "ctx" -> P.Right ACHClass'Ctx
  "iat" -> P.Right ACHClass'Iat
  "mte" -> P.Right ACHClass'Mte
  "pbr" -> P.Right ACHClass'Pbr
  "pop" -> P.Right ACHClass'Pop
  "pos" -> P.Right ACHClass'Pos
  "ppd" -> P.Right ACHClass'Ppd
  "rck" -> P.Right ACHClass'Rck
  "tel" -> P.Right ACHClass'Tel
  "web" -> P.Right ACHClass'Web
  s -> P.Left $ "toACHClass: enum parse failure: " P.++ P.show s


-- ** AccountSubtype

-- | Enum of 'Text' .
-- See the [Account type schema](/docs/api/accounts/#account-type-schema) for a full listing of account types and corresponding subtypes.
data AccountSubtype
  = AccountSubtype'401a -- ^ @"401a"@
  | AccountSubtype'401k -- ^ @"401k"@
  | AccountSubtype'403B -- ^ @"403B"@
  | AccountSubtype'457b -- ^ @"457b"@
  | AccountSubtype'529 -- ^ @"529"@
  | AccountSubtype'Brokerage -- ^ @"brokerage"@
  | AccountSubtype'Cash_isa -- ^ @"cash isa"@
  | AccountSubtype'Education_savings_account -- ^ @"education savings account"@
  | AccountSubtype'Gic -- ^ @"gic"@
  | AccountSubtype'Health_reimbursement_arrangement -- ^ @"health reimbursement arrangement"@
  | AccountSubtype'Hsa -- ^ @"hsa"@
  | AccountSubtype'Isa -- ^ @"isa"@
  | AccountSubtype'Ira -- ^ @"ira"@
  | AccountSubtype'Lif -- ^ @"lif"@
  | AccountSubtype'Lira -- ^ @"lira"@
  | AccountSubtype'Lrif -- ^ @"lrif"@
  | AccountSubtype'Lrsp -- ^ @"lrsp"@
  | AccountSubtype'Non_taxable_brokerage_account -- ^ @"non-taxable brokerage account"@
  | AccountSubtype'Other -- ^ @"other"@
  | AccountSubtype'Prif -- ^ @"prif"@
  | AccountSubtype'Rdsp -- ^ @"rdsp"@
  | AccountSubtype'Resp -- ^ @"resp"@
  | AccountSubtype'Rlif -- ^ @"rlif"@
  | AccountSubtype'Rrif -- ^ @"rrif"@
  | AccountSubtype'Pension -- ^ @"pension"@
  | AccountSubtype'Profit_sharing_plan -- ^ @"profit sharing plan"@
  | AccountSubtype'Retirement -- ^ @"retirement"@
  | AccountSubtype'Roth -- ^ @"roth"@
  | AccountSubtype'Roth_401k -- ^ @"roth 401k"@
  | AccountSubtype'Rrsp -- ^ @"rrsp"@
  | AccountSubtype'Sep_ira -- ^ @"sep ira"@
  | AccountSubtype'Simple_ira -- ^ @"simple ira"@
  | AccountSubtype'Sipp -- ^ @"sipp"@
  | AccountSubtype'Stock_plan -- ^ @"stock plan"@
  | AccountSubtype'Thrift_savings_plan -- ^ @"thrift savings plan"@
  | AccountSubtype'Tfsa -- ^ @"tfsa"@
  | AccountSubtype'Trust -- ^ @"trust"@
  | AccountSubtype'Ugma -- ^ @"ugma"@
  | AccountSubtype'Utma -- ^ @"utma"@
  | AccountSubtype'Variable_annuity -- ^ @"variable annuity"@
  | AccountSubtype'Credit_card -- ^ @"credit card"@
  | AccountSubtype'Paypal -- ^ @"paypal"@
  | AccountSubtype'Cd -- ^ @"cd"@
  | AccountSubtype'Checking -- ^ @"checking"@
  | AccountSubtype'Savings -- ^ @"savings"@
  | AccountSubtype'Money_market -- ^ @"money market"@
  | AccountSubtype'Prepaid -- ^ @"prepaid"@
  | AccountSubtype'Auto -- ^ @"auto"@
  | AccountSubtype'Commercial -- ^ @"commercial"@
  | AccountSubtype'Construction -- ^ @"construction"@
  | AccountSubtype'Consumer -- ^ @"consumer"@
  | AccountSubtype'Home -- ^ @"home"@
  | AccountSubtype'Home_equity -- ^ @"home equity"@
  | AccountSubtype'Loan -- ^ @"loan"@
  | AccountSubtype'Mortgage -- ^ @"mortgage"@
  | AccountSubtype'Overdraft -- ^ @"overdraft"@
  | AccountSubtype'Line_of_credit -- ^ @"line of credit"@
  | AccountSubtype'Student -- ^ @"student"@
  | AccountSubtype'Cash_management -- ^ @"cash management"@
  | AccountSubtype'Keogh -- ^ @"keogh"@
  | AccountSubtype'Mutual_fund -- ^ @"mutual fund"@
  | AccountSubtype'Recurring -- ^ @"recurring"@
  | AccountSubtype'Rewards -- ^ @"rewards"@
  | AccountSubtype'Safe_deposit -- ^ @"safe deposit"@
  | AccountSubtype'Sarsep -- ^ @"sarsep"@
  | AccountSubtype'Null -- ^ @"null"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum, Generic)

instance A.ToJSON AccountSubtype where toJSON = A.toJSON . fromAccountSubtype
instance A.FromJSON AccountSubtype where parseJSON o = P.either P.fail (pure . P.id) . toAccountSubtype =<< A.parseJSON o
instance WH.ToHttpApiData AccountSubtype where toQueryParam = WH.toQueryParam . fromAccountSubtype
instance WH.FromHttpApiData AccountSubtype where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toAccountSubtype
instance MimeRender MimeMultipartFormData AccountSubtype where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'AccountSubtype' enum
fromAccountSubtype :: AccountSubtype -> Text
fromAccountSubtype = \case
  AccountSubtype'401a -> "401a"
  AccountSubtype'401k -> "401k"
  AccountSubtype'403B -> "403B"
  AccountSubtype'457b -> "457b"
  AccountSubtype'529 -> "529"
  AccountSubtype'Brokerage -> "brokerage"
  AccountSubtype'Cash_isa -> "cash isa"
  AccountSubtype'Education_savings_account -> "education savings account"
  AccountSubtype'Gic -> "gic"
  AccountSubtype'Health_reimbursement_arrangement -> "health reimbursement arrangement"
  AccountSubtype'Hsa -> "hsa"
  AccountSubtype'Isa -> "isa"
  AccountSubtype'Ira -> "ira"
  AccountSubtype'Lif -> "lif"
  AccountSubtype'Lira -> "lira"
  AccountSubtype'Lrif -> "lrif"
  AccountSubtype'Lrsp -> "lrsp"
  AccountSubtype'Non_taxable_brokerage_account -> "non-taxable brokerage account"
  AccountSubtype'Other -> "other"
  AccountSubtype'Prif -> "prif"
  AccountSubtype'Rdsp -> "rdsp"
  AccountSubtype'Resp -> "resp"
  AccountSubtype'Rlif -> "rlif"
  AccountSubtype'Rrif -> "rrif"
  AccountSubtype'Pension -> "pension"
  AccountSubtype'Profit_sharing_plan -> "profit sharing plan"
  AccountSubtype'Retirement -> "retirement"
  AccountSubtype'Roth -> "roth"
  AccountSubtype'Roth_401k -> "roth 401k"
  AccountSubtype'Rrsp -> "rrsp"
  AccountSubtype'Sep_ira -> "sep ira"
  AccountSubtype'Simple_ira -> "simple ira"
  AccountSubtype'Sipp -> "sipp"
  AccountSubtype'Stock_plan -> "stock plan"
  AccountSubtype'Thrift_savings_plan -> "thrift savings plan"
  AccountSubtype'Tfsa -> "tfsa"
  AccountSubtype'Trust -> "trust"
  AccountSubtype'Ugma -> "ugma"
  AccountSubtype'Utma -> "utma"
  AccountSubtype'Variable_annuity -> "variable annuity"
  AccountSubtype'Credit_card -> "credit card"
  AccountSubtype'Paypal -> "paypal"
  AccountSubtype'Cd -> "cd"
  AccountSubtype'Checking -> "checking"
  AccountSubtype'Savings -> "savings"
  AccountSubtype'Money_market -> "money market"
  AccountSubtype'Prepaid -> "prepaid"
  AccountSubtype'Auto -> "auto"
  AccountSubtype'Commercial -> "commercial"
  AccountSubtype'Construction -> "construction"
  AccountSubtype'Consumer -> "consumer"
  AccountSubtype'Home -> "home"
  AccountSubtype'Home_equity -> "home equity"
  AccountSubtype'Loan -> "loan"
  AccountSubtype'Mortgage -> "mortgage"
  AccountSubtype'Overdraft -> "overdraft"
  AccountSubtype'Line_of_credit -> "line of credit"
  AccountSubtype'Student -> "student"
  AccountSubtype'Cash_management -> "cash management"
  AccountSubtype'Keogh -> "keogh"
  AccountSubtype'Mutual_fund -> "mutual fund"
  AccountSubtype'Recurring -> "recurring"
  AccountSubtype'Rewards -> "rewards"
  AccountSubtype'Safe_deposit -> "safe deposit"
  AccountSubtype'Sarsep -> "sarsep"
  AccountSubtype'Null -> "null"

-- | parse 'AccountSubtype' enum
toAccountSubtype :: Text -> P.Either String AccountSubtype
toAccountSubtype = \case
  "401a" -> P.Right AccountSubtype'401a
  "401k" -> P.Right AccountSubtype'401k
  "403B" -> P.Right AccountSubtype'403B
  "457b" -> P.Right AccountSubtype'457b
  "529" -> P.Right AccountSubtype'529
  "brokerage" -> P.Right AccountSubtype'Brokerage
  "cash isa" -> P.Right AccountSubtype'Cash_isa
  "education savings account" -> P.Right AccountSubtype'Education_savings_account
  "gic" -> P.Right AccountSubtype'Gic
  "health reimbursement arrangement" -> P.Right AccountSubtype'Health_reimbursement_arrangement
  "hsa" -> P.Right AccountSubtype'Hsa
  "isa" -> P.Right AccountSubtype'Isa
  "ira" -> P.Right AccountSubtype'Ira
  "lif" -> P.Right AccountSubtype'Lif
  "lira" -> P.Right AccountSubtype'Lira
  "lrif" -> P.Right AccountSubtype'Lrif
  "lrsp" -> P.Right AccountSubtype'Lrsp
  "non-taxable brokerage account" -> P.Right AccountSubtype'Non_taxable_brokerage_account
  "other" -> P.Right AccountSubtype'Other
  "prif" -> P.Right AccountSubtype'Prif
  "rdsp" -> P.Right AccountSubtype'Rdsp
  "resp" -> P.Right AccountSubtype'Resp
  "rlif" -> P.Right AccountSubtype'Rlif
  "rrif" -> P.Right AccountSubtype'Rrif
  "pension" -> P.Right AccountSubtype'Pension
  "profit sharing plan" -> P.Right AccountSubtype'Profit_sharing_plan
  "retirement" -> P.Right AccountSubtype'Retirement
  "roth" -> P.Right AccountSubtype'Roth
  "roth 401k" -> P.Right AccountSubtype'Roth_401k
  "rrsp" -> P.Right AccountSubtype'Rrsp
  "sep ira" -> P.Right AccountSubtype'Sep_ira
  "simple ira" -> P.Right AccountSubtype'Simple_ira
  "sipp" -> P.Right AccountSubtype'Sipp
  "stock plan" -> P.Right AccountSubtype'Stock_plan
  "thrift savings plan" -> P.Right AccountSubtype'Thrift_savings_plan
  "tfsa" -> P.Right AccountSubtype'Tfsa
  "trust" -> P.Right AccountSubtype'Trust
  "ugma" -> P.Right AccountSubtype'Ugma
  "utma" -> P.Right AccountSubtype'Utma
  "variable annuity" -> P.Right AccountSubtype'Variable_annuity
  "credit card" -> P.Right AccountSubtype'Credit_card
  "paypal" -> P.Right AccountSubtype'Paypal
  "cd" -> P.Right AccountSubtype'Cd
  "checking" -> P.Right AccountSubtype'Checking
  "savings" -> P.Right AccountSubtype'Savings
  "money market" -> P.Right AccountSubtype'Money_market
  "prepaid" -> P.Right AccountSubtype'Prepaid
  "auto" -> P.Right AccountSubtype'Auto
  "commercial" -> P.Right AccountSubtype'Commercial
  "construction" -> P.Right AccountSubtype'Construction
  "consumer" -> P.Right AccountSubtype'Consumer
  "home" -> P.Right AccountSubtype'Home
  "home equity" -> P.Right AccountSubtype'Home_equity
  "loan" -> P.Right AccountSubtype'Loan
  "mortgage" -> P.Right AccountSubtype'Mortgage
  "overdraft" -> P.Right AccountSubtype'Overdraft
  "line of credit" -> P.Right AccountSubtype'Line_of_credit
  "student" -> P.Right AccountSubtype'Student
  "cash management" -> P.Right AccountSubtype'Cash_management
  "keogh" -> P.Right AccountSubtype'Keogh
  "mutual fund" -> P.Right AccountSubtype'Mutual_fund
  "recurring" -> P.Right AccountSubtype'Recurring
  "rewards" -> P.Right AccountSubtype'Rewards
  "safe deposit" -> P.Right AccountSubtype'Safe_deposit
  "sarsep" -> P.Right AccountSubtype'Sarsep
  "null" -> P.Right AccountSubtype'Null
  s -> P.Left $ "toAccountSubtype: enum parse failure: " P.++ P.show s


-- ** AccountType

-- | Enum of 'Text' .
-- `investment:` Investment account  `credit:` Credit card  `depository:` Depository account  `loan:` Loan account  `brokerage`: An investment account. Used for `/assets/` endpoints only; other endpoints use `investment`.  `other:` Non-specified account type  See the [Account type schema](/docs/api/accounts#account-type-schema) for a full listing of account types and corresponding subtypes.
data AccountType
  = AccountType'Investment -- ^ @"investment"@
  | AccountType'Credit -- ^ @"credit"@
  | AccountType'Depository -- ^ @"depository"@
  | AccountType'Loan -- ^ @"loan"@
  | AccountType'Brokerage -- ^ @"brokerage"@
  | AccountType'Other -- ^ @"other"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON AccountType where toJSON = A.toJSON . fromAccountType
instance A.FromJSON AccountType where parseJSON o = P.either P.fail (pure . P.id) . toAccountType =<< A.parseJSON o
instance WH.ToHttpApiData AccountType where toQueryParam = WH.toQueryParam . fromAccountType
instance WH.FromHttpApiData AccountType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toAccountType
instance MimeRender MimeMultipartFormData AccountType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'AccountType' enum
fromAccountType :: AccountType -> Text
fromAccountType = \case
  AccountType'Investment -> "investment"
  AccountType'Credit -> "credit"
  AccountType'Depository -> "depository"
  AccountType'Loan -> "loan"
  AccountType'Brokerage -> "brokerage"
  AccountType'Other -> "other"

-- | parse 'AccountType' enum
toAccountType :: Text -> P.Either String AccountType
toAccountType = \case
  "investment" -> P.Right AccountType'Investment
  "credit" -> P.Right AccountType'Credit
  "depository" -> P.Right AccountType'Depository
  "loan" -> P.Right AccountType'Loan
  "brokerage" -> P.Right AccountType'Brokerage
  "other" -> P.Right AccountType'Other
  s -> P.Left $ "toAccountType: enum parse failure: " P.++ P.show s


-- ** BankTransferDirection

-- | Enum of 'Text' .
-- Indicates the direction of the transfer: `outbound` for API-initiated transfers, or `inbound` for payments received by the FBO account.
data BankTransferDirection
  = BankTransferDirection'Outbound -- ^ @"outbound"@
  | BankTransferDirection'Inbound -- ^ @"inbound"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON BankTransferDirection where toJSON = A.toJSON . fromBankTransferDirection
instance A.FromJSON BankTransferDirection where parseJSON o = P.either P.fail (pure . P.id) . toBankTransferDirection =<< A.parseJSON o
instance WH.ToHttpApiData BankTransferDirection where toQueryParam = WH.toQueryParam . fromBankTransferDirection
instance WH.FromHttpApiData BankTransferDirection where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toBankTransferDirection
instance MimeRender MimeMultipartFormData BankTransferDirection where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'BankTransferDirection' enum
fromBankTransferDirection :: BankTransferDirection -> Text
fromBankTransferDirection = \case
  BankTransferDirection'Outbound -> "outbound"
  BankTransferDirection'Inbound -> "inbound"

-- | parse 'BankTransferDirection' enum
toBankTransferDirection :: Text -> P.Either String BankTransferDirection
toBankTransferDirection = \case
  "outbound" -> P.Right BankTransferDirection'Outbound
  "inbound" -> P.Right BankTransferDirection'Inbound
  s -> P.Left $ "toBankTransferDirection: enum parse failure: " P.++ P.show s


-- ** BankTransferEventType

-- | Enum of 'Text' .
-- `pending`: A new transfer was created; it is in the pending state.  `cancelled`: The transfer was cancelled by the client.  `failed`: The transfer failed, no funds were moved.  `posted`: The transfer has been successfully submitted to the payment network.  `reversed`: A posted transfer was reversed.  `receiver_pending`: The matching transfer was found as a pending transaction in the receiver's account  `receiver_posted`: The matching transfer was found as a posted transaction in the receiver's account
data BankTransferEventType
  = BankTransferEventType'Pending -- ^ @"pending"@
  | BankTransferEventType'Cancelled -- ^ @"cancelled"@
  | BankTransferEventType'Failed -- ^ @"failed"@
  | BankTransferEventType'Posted -- ^ @"posted"@
  | BankTransferEventType'Reversed -- ^ @"reversed"@
  | BankTransferEventType'Receiver_pending -- ^ @"receiver_pending"@
  | BankTransferEventType'Receiver_posted -- ^ @"receiver_posted"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON BankTransferEventType where toJSON = A.toJSON . fromBankTransferEventType
instance A.FromJSON BankTransferEventType where parseJSON o = P.either P.fail (pure . P.id) . toBankTransferEventType =<< A.parseJSON o
instance WH.ToHttpApiData BankTransferEventType where toQueryParam = WH.toQueryParam . fromBankTransferEventType
instance WH.FromHttpApiData BankTransferEventType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toBankTransferEventType
instance MimeRender MimeMultipartFormData BankTransferEventType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'BankTransferEventType' enum
fromBankTransferEventType :: BankTransferEventType -> Text
fromBankTransferEventType = \case
  BankTransferEventType'Pending -> "pending"
  BankTransferEventType'Cancelled -> "cancelled"
  BankTransferEventType'Failed -> "failed"
  BankTransferEventType'Posted -> "posted"
  BankTransferEventType'Reversed -> "reversed"
  BankTransferEventType'Receiver_pending -> "receiver_pending"
  BankTransferEventType'Receiver_posted -> "receiver_posted"

-- | parse 'BankTransferEventType' enum
toBankTransferEventType :: Text -> P.Either String BankTransferEventType
toBankTransferEventType = \case
  "pending" -> P.Right BankTransferEventType'Pending
  "cancelled" -> P.Right BankTransferEventType'Cancelled
  "failed" -> P.Right BankTransferEventType'Failed
  "posted" -> P.Right BankTransferEventType'Posted
  "reversed" -> P.Right BankTransferEventType'Reversed
  "receiver_pending" -> P.Right BankTransferEventType'Receiver_pending
  "receiver_posted" -> P.Right BankTransferEventType'Receiver_posted
  s -> P.Left $ "toBankTransferEventType: enum parse failure: " P.++ P.show s


-- ** BankTransferNetwork

-- | Enum of 'Text' .
-- The network or rails used for the transfer. Valid options are `ach`, `same-day-ach`, or `wire`.
data BankTransferNetwork
  = BankTransferNetwork'Ach -- ^ @"ach"@
  | BankTransferNetwork'Same_day_ach -- ^ @"same-day-ach"@
  | BankTransferNetwork'Wire -- ^ @"wire"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON BankTransferNetwork where toJSON = A.toJSON . fromBankTransferNetwork
instance A.FromJSON BankTransferNetwork where parseJSON o = P.either P.fail (pure . P.id) . toBankTransferNetwork =<< A.parseJSON o
instance WH.ToHttpApiData BankTransferNetwork where toQueryParam = WH.toQueryParam . fromBankTransferNetwork
instance WH.FromHttpApiData BankTransferNetwork where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toBankTransferNetwork
instance MimeRender MimeMultipartFormData BankTransferNetwork where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'BankTransferNetwork' enum
fromBankTransferNetwork :: BankTransferNetwork -> Text
fromBankTransferNetwork = \case
  BankTransferNetwork'Ach -> "ach"
  BankTransferNetwork'Same_day_ach -> "same-day-ach"
  BankTransferNetwork'Wire -> "wire"

-- | parse 'BankTransferNetwork' enum
toBankTransferNetwork :: Text -> P.Either String BankTransferNetwork
toBankTransferNetwork = \case
  "ach" -> P.Right BankTransferNetwork'Ach
  "same-day-ach" -> P.Right BankTransferNetwork'Same_day_ach
  "wire" -> P.Right BankTransferNetwork'Wire
  s -> P.Left $ "toBankTransferNetwork: enum parse failure: " P.++ P.show s


-- ** BankTransferStatus

-- | Enum of 'Text' .
-- The status of the transfer.
data BankTransferStatus
  = BankTransferStatus'Pending -- ^ @"pending"@
  | BankTransferStatus'Posted -- ^ @"posted"@
  | BankTransferStatus'Cancelled -- ^ @"cancelled"@
  | BankTransferStatus'Failed -- ^ @"failed"@
  | BankTransferStatus'Reversed -- ^ @"reversed"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON BankTransferStatus where toJSON = A.toJSON . fromBankTransferStatus
instance A.FromJSON BankTransferStatus where parseJSON o = P.either P.fail (pure . P.id) . toBankTransferStatus =<< A.parseJSON o
instance WH.ToHttpApiData BankTransferStatus where toQueryParam = WH.toQueryParam . fromBankTransferStatus
instance WH.FromHttpApiData BankTransferStatus where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toBankTransferStatus
instance MimeRender MimeMultipartFormData BankTransferStatus where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'BankTransferStatus' enum
fromBankTransferStatus :: BankTransferStatus -> Text
fromBankTransferStatus = \case
  BankTransferStatus'Pending -> "pending"
  BankTransferStatus'Posted -> "posted"
  BankTransferStatus'Cancelled -> "cancelled"
  BankTransferStatus'Failed -> "failed"
  BankTransferStatus'Reversed -> "reversed"

-- | parse 'BankTransferStatus' enum
toBankTransferStatus :: Text -> P.Either String BankTransferStatus
toBankTransferStatus = \case
  "pending" -> P.Right BankTransferStatus'Pending
  "posted" -> P.Right BankTransferStatus'Posted
  "cancelled" -> P.Right BankTransferStatus'Cancelled
  "failed" -> P.Right BankTransferStatus'Failed
  "reversed" -> P.Right BankTransferStatus'Reversed
  s -> P.Left $ "toBankTransferStatus: enum parse failure: " P.++ P.show s


-- ** BankTransferType

-- | Enum of 'Text' .
-- The type of bank transfer. This will be either `debit` or `credit`.  A `debit` indicates a transfer of money into your origination account; a `credit` indicates a transfer of money out of your origination account.
data BankTransferType
  = BankTransferType'Debit -- ^ @"debit"@
  | BankTransferType'Credit -- ^ @"credit"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON BankTransferType where toJSON = A.toJSON . fromBankTransferType
instance A.FromJSON BankTransferType where parseJSON o = P.either P.fail (pure . P.id) . toBankTransferType =<< A.parseJSON o
instance WH.ToHttpApiData BankTransferType where toQueryParam = WH.toQueryParam . fromBankTransferType
instance WH.FromHttpApiData BankTransferType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toBankTransferType
instance MimeRender MimeMultipartFormData BankTransferType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'BankTransferType' enum
fromBankTransferType :: BankTransferType -> Text
fromBankTransferType = \case
  BankTransferType'Debit -> "debit"
  BankTransferType'Credit -> "credit"

-- | parse 'BankTransferType' enum
toBankTransferType :: Text -> P.Either String BankTransferType
toBankTransferType = \case
  "debit" -> P.Right BankTransferType'Debit
  "credit" -> P.Right BankTransferType'Credit
  s -> P.Left $ "toBankTransferType: enum parse failure: " P.++ P.show s


-- ** CountryCode

-- | Enum of 'Text' .
-- ISO-3166-1 alpha-2 country code standard.
data CountryCode
  = CountryCode'US -- ^ @"US"@
  | CountryCode'GB -- ^ @"GB"@
  | CountryCode'ES -- ^ @"ES"@
  | CountryCode'NL -- ^ @"NL"@
  | CountryCode'FR -- ^ @"FR"@
  | CountryCode'IE -- ^ @"IE"@
  | CountryCode'CA -- ^ @"CA"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON CountryCode where toJSON = A.toJSON . fromCountryCode
instance A.FromJSON CountryCode where parseJSON o = P.either P.fail (pure . P.id) . toCountryCode =<< A.parseJSON o
instance WH.ToHttpApiData CountryCode where toQueryParam = WH.toQueryParam . fromCountryCode
instance WH.FromHttpApiData CountryCode where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toCountryCode
instance MimeRender MimeMultipartFormData CountryCode where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'CountryCode' enum
fromCountryCode :: CountryCode -> Text
fromCountryCode = \case
  CountryCode'US -> "US"
  CountryCode'GB -> "GB"
  CountryCode'ES -> "ES"
  CountryCode'NL -> "NL"
  CountryCode'FR -> "FR"
  CountryCode'IE -> "IE"
  CountryCode'CA -> "CA"

-- | parse 'CountryCode' enum
toCountryCode :: Text -> P.Either String CountryCode
toCountryCode = \case
  "US" -> P.Right CountryCode'US
  "GB" -> P.Right CountryCode'GB
  "ES" -> P.Right CountryCode'ES
  "NL" -> P.Right CountryCode'NL
  "FR" -> P.Right CountryCode'FR
  "IE" -> P.Right CountryCode'IE
  "CA" -> P.Right CountryCode'CA
  s -> P.Left $ "toCountryCode: enum parse failure: " P.++ P.show s


-- ** E'AccountSubtype

-- | Enum of 'Text' .
-- The account subtype of the account, either `checking` or `savings`.
data E'AccountSubtype
  = E'AccountSubtype'Checking -- ^ @"checking"@
  | E'AccountSubtype'Savings -- ^ @"savings"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'AccountSubtype where toJSON = A.toJSON . fromE'AccountSubtype
instance A.FromJSON E'AccountSubtype where parseJSON o = P.either P.fail (pure . P.id) . toE'AccountSubtype =<< A.parseJSON o
instance WH.ToHttpApiData E'AccountSubtype where toQueryParam = WH.toQueryParam . fromE'AccountSubtype
instance WH.FromHttpApiData E'AccountSubtype where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'AccountSubtype
instance MimeRender MimeMultipartFormData E'AccountSubtype where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'AccountSubtype' enum
fromE'AccountSubtype :: E'AccountSubtype -> Text
fromE'AccountSubtype = \case
  E'AccountSubtype'Checking -> "checking"
  E'AccountSubtype'Savings -> "savings"

-- | parse 'E'AccountSubtype' enum
toE'AccountSubtype :: Text -> P.Either String E'AccountSubtype
toE'AccountSubtype = \case
  "checking" -> P.Right E'AccountSubtype'Checking
  "savings" -> P.Right E'AccountSubtype'Savings
  s -> P.Left $ "toE'AccountSubtype: enum parse failure: " P.++ P.show s


-- ** E'AprType

-- | Enum of 'Text' .
-- The type of balance to which the APR applies.
data E'AprType
  = E'AprType'Balance_transfer_apr -- ^ @"balance_transfer_apr"@
  | E'AprType'Cash_apr -- ^ @"cash_apr"@
  | E'AprType'Purchase_apr -- ^ @"purchase_apr"@
  | E'AprType'Special -- ^ @"special"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'AprType where toJSON = A.toJSON . fromE'AprType
instance A.FromJSON E'AprType where parseJSON o = P.either P.fail (pure . P.id) . toE'AprType =<< A.parseJSON o
instance WH.ToHttpApiData E'AprType where toQueryParam = WH.toQueryParam . fromE'AprType
instance WH.FromHttpApiData E'AprType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'AprType
instance MimeRender MimeMultipartFormData E'AprType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'AprType' enum
fromE'AprType :: E'AprType -> Text
fromE'AprType = \case
  E'AprType'Balance_transfer_apr -> "balance_transfer_apr"
  E'AprType'Cash_apr -> "cash_apr"
  E'AprType'Purchase_apr -> "purchase_apr"
  E'AprType'Special -> "special"

-- | parse 'E'AprType' enum
toE'AprType :: Text -> P.Either String E'AprType
toE'AprType = \case
  "balance_transfer_apr" -> P.Right E'AprType'Balance_transfer_apr
  "cash_apr" -> P.Right E'AprType'Cash_apr
  "purchase_apr" -> P.Right E'AprType'Purchase_apr
  "special" -> P.Right E'AprType'Special
  s -> P.Left $ "toE'AprType: enum parse failure: " P.++ P.show s


-- ** E'AvailableBalance

-- | Enum of 'Text' .
-- The sign of the available balance for the receiver bank account associated with the receiver event at the time the matching transaction was found. Can be `positive`, `negative`, or null if the balance was not available at the time.
data E'AvailableBalance
  = E'AvailableBalance'Positive -- ^ @"positive"@
  | E'AvailableBalance'Negative -- ^ @"negative"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'AvailableBalance where toJSON = A.toJSON . fromE'AvailableBalance
instance A.FromJSON E'AvailableBalance where parseJSON o = P.either P.fail (pure . P.id) . toE'AvailableBalance =<< A.parseJSON o
instance WH.ToHttpApiData E'AvailableBalance where toQueryParam = WH.toQueryParam . fromE'AvailableBalance
instance WH.FromHttpApiData E'AvailableBalance where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'AvailableBalance
instance MimeRender MimeMultipartFormData E'AvailableBalance where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'AvailableBalance' enum
fromE'AvailableBalance :: E'AvailableBalance -> Text
fromE'AvailableBalance = \case
  E'AvailableBalance'Positive -> "positive"
  E'AvailableBalance'Negative -> "negative"

-- | parse 'E'AvailableBalance' enum
toE'AvailableBalance :: Text -> P.Either String E'AvailableBalance
toE'AvailableBalance = \case
  "positive" -> P.Right E'AvailableBalance'Positive
  "negative" -> P.Right E'AvailableBalance'Negative
  s -> P.Left $ "toE'AvailableBalance: enum parse failure: " P.++ P.show s


-- ** E'BankTransferType

-- | Enum of 'Text' .
-- The type of bank transfer. This will be either `debit` or `credit`.  A `debit` indicates a transfer of money into your origination account; a `credit` indicates a transfer of money out of your origination account.
data E'BankTransferType
  = E'BankTransferType'Debit -- ^ @"debit"@
  | E'BankTransferType'Credit -- ^ @"credit"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'BankTransferType where toJSON = A.toJSON . fromE'BankTransferType
instance A.FromJSON E'BankTransferType where parseJSON o = P.either P.fail (pure . P.id) . toE'BankTransferType =<< A.parseJSON o
instance WH.ToHttpApiData E'BankTransferType where toQueryParam = WH.toQueryParam . fromE'BankTransferType
instance WH.FromHttpApiData E'BankTransferType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'BankTransferType
instance MimeRender MimeMultipartFormData E'BankTransferType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'BankTransferType' enum
fromE'BankTransferType :: E'BankTransferType -> Text
fromE'BankTransferType = \case
  E'BankTransferType'Debit -> "debit"
  E'BankTransferType'Credit -> "credit"

-- | parse 'E'BankTransferType' enum
toE'BankTransferType :: Text -> P.Either String E'BankTransferType
toE'BankTransferType = \case
  "debit" -> P.Right E'BankTransferType'Debit
  "credit" -> P.Right E'BankTransferType'Credit
  s -> P.Left $ "toE'BankTransferType: enum parse failure: " P.++ P.show s


-- ** E'Currency

-- | Enum of 'Text' .
-- The ISO-4217 currency code of the payment. For standing orders, `\"GBP\"` must be used.
data E'Currency
  = E'Currency'GBP -- ^ @"GBP"@
  | E'Currency'EUR -- ^ @"EUR"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Currency where toJSON = A.toJSON . fromE'Currency
instance A.FromJSON E'Currency where parseJSON o = P.either P.fail (pure . P.id) . toE'Currency =<< A.parseJSON o
instance WH.ToHttpApiData E'Currency where toQueryParam = WH.toQueryParam . fromE'Currency
instance WH.FromHttpApiData E'Currency where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Currency
instance MimeRender MimeMultipartFormData E'Currency where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Currency' enum
fromE'Currency :: E'Currency -> Text
fromE'Currency = \case
  E'Currency'GBP -> "GBP"
  E'Currency'EUR -> "EUR"

-- | parse 'E'Currency' enum
toE'Currency :: Text -> P.Either String E'Currency
toE'Currency = \case
  "GBP" -> P.Right E'Currency'GBP
  "EUR" -> P.Right E'Currency'EUR
  s -> P.Left $ "toE'Currency: enum parse failure: " P.++ P.show s


-- ** E'ErrorType

-- | Enum of 'Text' .
-- A broad categorization of the error. Safe for programatic use.
data E'ErrorType
  = E'ErrorType'INVALID_REQUEST -- ^ @"INVALID_REQUEST"@
  | E'ErrorType'INVALID_INPUT -- ^ @"INVALID_INPUT"@
  | E'ErrorType'INSTITUTION_ERROR -- ^ @"INSTITUTION_ERROR"@
  | E'ErrorType'RATE_LIMIT_EXCEEDED -- ^ @"RATE_LIMIT_EXCEEDED"@
  | E'ErrorType'API_ERROR -- ^ @"API_ERROR"@
  | E'ErrorType'ITEM_ERROR -- ^ @"ITEM_ERROR"@
  | E'ErrorType'ASSET_REPORT_ERROR -- ^ @"ASSET_REPORT_ERROR"@
  | E'ErrorType'RECAPTCHA_ERROR -- ^ @"RECAPTCHA_ERROR"@
  | E'ErrorType'OAUTH_ERROR -- ^ @"OAUTH_ERROR"@
  | E'ErrorType'PAYMENT_ERROR -- ^ @"PAYMENT_ERROR"@
  | E'ErrorType'BANK_TRANSFER_ERROR -- ^ @"BANK_TRANSFER_ERROR"@
  | E'ErrorType'INVALID_RESULT
  | E'ErrorType'TRANSACTIONS_ERROR
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'ErrorType where toJSON = A.toJSON . fromE'ErrorType
instance A.FromJSON E'ErrorType where parseJSON o = P.either P.fail (pure . P.id) . toE'ErrorType =<< A.parseJSON o
instance WH.ToHttpApiData E'ErrorType where toQueryParam = WH.toQueryParam . fromE'ErrorType
instance WH.FromHttpApiData E'ErrorType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'ErrorType
instance MimeRender MimeMultipartFormData E'ErrorType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'ErrorType' enum
fromE'ErrorType :: E'ErrorType -> Text
fromE'ErrorType = \case
  E'ErrorType'INVALID_REQUEST -> "INVALID_REQUEST"
  E'ErrorType'INVALID_INPUT -> "INVALID_INPUT"
  E'ErrorType'INSTITUTION_ERROR -> "INSTITUTION_ERROR"
  E'ErrorType'RATE_LIMIT_EXCEEDED -> "RATE_LIMIT_EXCEEDED"
  E'ErrorType'API_ERROR -> "API_ERROR"
  E'ErrorType'ITEM_ERROR -> "ITEM_ERROR"
  E'ErrorType'ASSET_REPORT_ERROR -> "ASSET_REPORT_ERROR"
  E'ErrorType'RECAPTCHA_ERROR -> "RECAPTCHA_ERROR"
  E'ErrorType'OAUTH_ERROR -> "OAUTH_ERROR"
  E'ErrorType'PAYMENT_ERROR -> "PAYMENT_ERROR"
  E'ErrorType'BANK_TRANSFER_ERROR -> "BANK_TRANSFER_ERROR"
  E'ErrorType'INVALID_RESULT -> "INVALID_RESULT"
  E'ErrorType'TRANSACTIONS_ERROR -> "TRANSACTIONS_ERROR"
-- | parse 'E'ErrorType' enum
toE'ErrorType :: Text -> P.Either String E'ErrorType
toE'ErrorType = \case
  "INVALID_REQUEST" -> P.Right E'ErrorType'INVALID_REQUEST
  "INVALID_INPUT" -> P.Right E'ErrorType'INVALID_INPUT
  "INSTITUTION_ERROR" -> P.Right E'ErrorType'INSTITUTION_ERROR
  "RATE_LIMIT_EXCEEDED" -> P.Right E'ErrorType'RATE_LIMIT_EXCEEDED
  "API_ERROR" -> P.Right E'ErrorType'API_ERROR
  "ITEM_ERROR" -> P.Right E'ErrorType'ITEM_ERROR
  "ASSET_REPORT_ERROR" -> P.Right E'ErrorType'ASSET_REPORT_ERROR
  "RECAPTCHA_ERROR" -> P.Right E'ErrorType'RECAPTCHA_ERROR
  "OAUTH_ERROR" -> P.Right E'ErrorType'OAUTH_ERROR
  "PAYMENT_ERROR" -> P.Right E'ErrorType'PAYMENT_ERROR
  "BANK_TRANSFER_ERROR" -> P.Right E'ErrorType'BANK_TRANSFER_ERROR
  "INVALID_RESULT" -> P.Right E'ErrorType'INVALID_RESULT
  "TRANSACTIONS_ERROR" -> P.Right E'ErrorType'TRANSACTIONS_ERROR
  s -> P.Left $ "toE'ErrorType: enum parse failure: " P.++ P.show s


-- ** E'PaymentChannel

-- | Enum of 'Text' .
-- The channel used to make a payment. `online:` transactions that took place online.  `in store:` transactions that were made at a physical location.  `other:` transactions that relate to banks, e.g. fees or deposits.  This field replaces the `transaction_type` field. 
data E'PaymentChannel
  = E'PaymentChannel'Online -- ^ @"online"@
  | E'PaymentChannel'In_store -- ^ @"in store"@
  | E'PaymentChannel'Other -- ^ @"other"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'PaymentChannel where toJSON = A.toJSON . fromE'PaymentChannel
instance A.FromJSON E'PaymentChannel where parseJSON o = P.either P.fail (pure . P.id) . toE'PaymentChannel =<< A.parseJSON o
instance WH.ToHttpApiData E'PaymentChannel where toQueryParam = WH.toQueryParam . fromE'PaymentChannel
instance WH.FromHttpApiData E'PaymentChannel where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'PaymentChannel
instance MimeRender MimeMultipartFormData E'PaymentChannel where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'PaymentChannel' enum
fromE'PaymentChannel :: E'PaymentChannel -> Text
fromE'PaymentChannel = \case
  E'PaymentChannel'Online -> "online"
  E'PaymentChannel'In_store -> "in store"
  E'PaymentChannel'Other -> "other"

-- | parse 'E'PaymentChannel' enum
toE'PaymentChannel :: Text -> P.Either String E'PaymentChannel
toE'PaymentChannel = \case
  "online" -> P.Right E'PaymentChannel'Online
  "in store" -> P.Right E'PaymentChannel'In_store
  "other" -> P.Right E'PaymentChannel'Other
  s -> P.Left $ "toE'PaymentChannel: enum parse failure: " P.++ P.show s


-- ** E'RefreshInterval

-- | Enum of 'Text' .
-- The `refresh_interval` may be `DELAYED` or `STOPPED` even when the success rate is high. This value is only returned for Transactions status breakdowns.
data E'RefreshInterval
  = E'RefreshInterval'NORMAL -- ^ @"NORMAL"@
  | E'RefreshInterval'DELAYED -- ^ @"DELAYED"@
  | E'RefreshInterval'STOPPED -- ^ @"STOPPED"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'RefreshInterval where toJSON = A.toJSON . fromE'RefreshInterval
instance A.FromJSON E'RefreshInterval where parseJSON o = P.either P.fail (pure . P.id) . toE'RefreshInterval =<< A.parseJSON o
instance WH.ToHttpApiData E'RefreshInterval where toQueryParam = WH.toQueryParam . fromE'RefreshInterval
instance WH.FromHttpApiData E'RefreshInterval where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'RefreshInterval
instance MimeRender MimeMultipartFormData E'RefreshInterval where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'RefreshInterval' enum
fromE'RefreshInterval :: E'RefreshInterval -> Text
fromE'RefreshInterval = \case
  E'RefreshInterval'NORMAL -> "NORMAL"
  E'RefreshInterval'DELAYED -> "DELAYED"
  E'RefreshInterval'STOPPED -> "STOPPED"

-- | parse 'E'RefreshInterval' enum
toE'RefreshInterval :: Text -> P.Either String E'RefreshInterval
toE'RefreshInterval = \case
  "NORMAL" -> P.Right E'RefreshInterval'NORMAL
  "DELAYED" -> P.Right E'RefreshInterval'DELAYED
  "STOPPED" -> P.Right E'RefreshInterval'STOPPED
  s -> P.Left $ "toE'RefreshInterval: enum parse failure: " P.++ P.show s


-- ** E'State

-- | Enum of 'Text' .
-- The state of the deposit switch.
data E'State
  = E'State'Initialized -- ^ @"initialized"@
  | E'State'Completed -- ^ @"completed"@
  | E'State'Error -- ^ @"error"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'State where toJSON = A.toJSON . fromE'State
instance A.FromJSON E'State where parseJSON o = P.either P.fail (pure . P.id) . toE'State =<< A.parseJSON o
instance WH.ToHttpApiData E'State where toQueryParam = WH.toQueryParam . fromE'State
instance WH.FromHttpApiData E'State where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'State
instance MimeRender MimeMultipartFormData E'State where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'State' enum
fromE'State :: E'State -> Text
fromE'State = \case
  E'State'Initialized -> "initialized"
  E'State'Completed -> "completed"
  E'State'Error -> "error"

-- | parse 'E'State' enum
toE'State :: Text -> P.Either String E'State
toE'State = \case
  "initialized" -> P.Right E'State'Initialized
  "completed" -> P.Right E'State'Completed
  "error" -> P.Right E'State'Error
  s -> P.Left $ "toE'State: enum parse failure: " P.++ P.show s


-- ** E'Status

-- | Enum of 'Text' .
-- The status of the payment.  `PAYMENT_STATUS_INPUT_NEEDED`: This is the initial state of all payments. It indicates that the payment is waiting on user input to continue processing. A payment may re-enter this state later on if further input is needed.  `PAYMENT_STATUS_PROCESSING`: The payment is currently being processed. The payment will automatically exit this state when processing is complete.  `PAYMENT_STATUS_INITIATED`: The payment has been successfully initiated and is considered complete.  `PAYMENT_STATUS_COMPLETED`: Indicates that the standing order has been successfully established. This state is only used for standing orders.  `PAYMENT_STATUS_INSUFFICIENT_FUNDS`: The payment has failed due to insufficient funds.  `PAYMENT_STATUS_FAILED`: The payment has failed to be initiated. This error is retryable once the root cause is resolved.  `PAYMENT_STATUS_BLOCKED`: The payment has been blocked. This is a retryable error.  `PAYMENT_STATUS_UNKNOWN`: The payment status is unknown.
data E'Status
  = E'Status'INPUT_NEEDED -- ^ @"PAYMENT_STATUS_INPUT_NEEDED"@
  | E'Status'PROCESSING -- ^ @"PAYMENT_STATUS_PROCESSING"@
  | E'Status'INITIATED -- ^ @"PAYMENT_STATUS_INITIATED"@
  | E'Status'COMPLETED -- ^ @"PAYMENT_STATUS_COMPLETED"@
  | E'Status'INSUFFICIENT_FUNDS -- ^ @"PAYMENT_STATUS_INSUFFICIENT_FUNDS"@
  | E'Status'FAILED -- ^ @"PAYMENT_STATUS_FAILED"@
  | E'Status'BLOCKED -- ^ @"PAYMENT_STATUS_BLOCKED"@
  | E'Status'UNKNOWN -- ^ @"PAYMENT_STATUS_UNKNOWN"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Status where toJSON = A.toJSON . fromE'Status
instance A.FromJSON E'Status where parseJSON o = P.either P.fail (pure . P.id) . toE'Status =<< A.parseJSON o
instance WH.ToHttpApiData E'Status where toQueryParam = WH.toQueryParam . fromE'Status
instance WH.FromHttpApiData E'Status where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Status
instance MimeRender MimeMultipartFormData E'Status where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Status' enum
fromE'Status :: E'Status -> Text
fromE'Status = \case
  E'Status'INPUT_NEEDED -> "PAYMENT_STATUS_INPUT_NEEDED"
  E'Status'PROCESSING -> "PAYMENT_STATUS_PROCESSING"
  E'Status'INITIATED -> "PAYMENT_STATUS_INITIATED"
  E'Status'COMPLETED -> "PAYMENT_STATUS_COMPLETED"
  E'Status'INSUFFICIENT_FUNDS -> "PAYMENT_STATUS_INSUFFICIENT_FUNDS"
  E'Status'FAILED -> "PAYMENT_STATUS_FAILED"
  E'Status'BLOCKED -> "PAYMENT_STATUS_BLOCKED"
  E'Status'UNKNOWN -> "PAYMENT_STATUS_UNKNOWN"

-- | parse 'E'Status' enum
toE'Status :: Text -> P.Either String E'Status
toE'Status = \case
  "PAYMENT_STATUS_INPUT_NEEDED" -> P.Right E'Status'INPUT_NEEDED
  "PAYMENT_STATUS_PROCESSING" -> P.Right E'Status'PROCESSING
  "PAYMENT_STATUS_INITIATED" -> P.Right E'Status'INITIATED
  "PAYMENT_STATUS_COMPLETED" -> P.Right E'Status'COMPLETED
  "PAYMENT_STATUS_INSUFFICIENT_FUNDS" -> P.Right E'Status'INSUFFICIENT_FUNDS
  "PAYMENT_STATUS_FAILED" -> P.Right E'Status'FAILED
  "PAYMENT_STATUS_BLOCKED" -> P.Right E'Status'BLOCKED
  "PAYMENT_STATUS_UNKNOWN" -> P.Right E'Status'UNKNOWN
  s -> P.Left $ "toE'Status: enum parse failure: " P.++ P.show s


-- ** E'Status2

-- | Enum of 'Text' .
-- `HEALTHY`: the majority of requests are successful `DEGRADED`: only some requests are successful `DOWN`: all requests are failing
data E'Status2
  = E'Status2'HEALTHY -- ^ @"HEALTHY"@
  | E'Status2'DEGRADED -- ^ @"DEGRADED"@
  | E'Status2'DOWN -- ^ @"DOWN"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Status2 where toJSON = A.toJSON . fromE'Status2
instance A.FromJSON E'Status2 where parseJSON o = P.either P.fail (pure . P.id) . toE'Status2 =<< A.parseJSON o
instance WH.ToHttpApiData E'Status2 where toQueryParam = WH.toQueryParam . fromE'Status2
instance WH.FromHttpApiData E'Status2 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Status2
instance MimeRender MimeMultipartFormData E'Status2 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Status2' enum
fromE'Status2 :: E'Status2 -> Text
fromE'Status2 = \case
  E'Status2'HEALTHY -> "HEALTHY"
  E'Status2'DEGRADED -> "DEGRADED"
  E'Status2'DOWN -> "DOWN"

-- | parse 'E'Status2' enum
toE'Status2 :: Text -> P.Either String E'Status2
toE'Status2 = \case
  "HEALTHY" -> P.Right E'Status2'HEALTHY
  "DEGRADED" -> P.Right E'Status2'DEGRADED
  "DOWN" -> P.Right E'Status2'DOWN
  s -> P.Left $ "toE'Status2: enum parse failure: " P.++ P.show s


-- ** E'Status3

-- | Enum of 'Text' .
-- The status of the incident.
data E'Status3
  = E'Status3'INVESTIGATING -- ^ @"INVESTIGATING"@
  | E'Status3'IDENTIFIED -- ^ @"IDENTIFIED"@
  | E'Status3'RESOLVED -- ^ @"RESOLVED"@
  | E'Status3'UNKNOWN -- ^ @"UNKNOWN"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Status3 where toJSON = A.toJSON . fromE'Status3
instance A.FromJSON E'Status3 where parseJSON o = P.either P.fail (pure . P.id) . toE'Status3 =<< A.parseJSON o
instance WH.ToHttpApiData E'Status3 where toQueryParam = WH.toQueryParam . fromE'Status3
instance WH.FromHttpApiData E'Status3 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Status3
instance MimeRender MimeMultipartFormData E'Status3 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Status3' enum
fromE'Status3 :: E'Status3 -> Text
fromE'Status3 = \case
  E'Status3'INVESTIGATING -> "INVESTIGATING"
  E'Status3'IDENTIFIED -> "IDENTIFIED"
  E'Status3'RESOLVED -> "RESOLVED"
  E'Status3'UNKNOWN -> "UNKNOWN"

-- | parse 'E'Status3' enum
toE'Status3 :: Text -> P.Either String E'Status3
toE'Status3 = \case
  "INVESTIGATING" -> P.Right E'Status3'INVESTIGATING
  "IDENTIFIED" -> P.Right E'Status3'IDENTIFIED
  "RESOLVED" -> P.Right E'Status3'RESOLVED
  "UNKNOWN" -> P.Right E'Status3'UNKNOWN
  s -> P.Left $ "toE'Status3: enum parse failure: " P.++ P.show s


-- ** E'Subtype

-- | Enum of 'Text' .
-- For descriptions of possible transaction subtypes, see [Investment transaction subtypes schema](/docs/api/accounts/#investment-transaction-subtypes-schema).
data E'Subtype
  = E'Subtype'Account_fee -- ^ @"account fee"@
  | E'Subtype'Assignment -- ^ @"assignment"@
  | E'Subtype'Buy -- ^ @"buy"@
  | E'Subtype'Buy_to_cover -- ^ @"buy to cover"@
  | E'Subtype'Contribution -- ^ @"contribution"@
  | E'Subtype'Deposit -- ^ @"deposit"@
  | E'Subtype'Distribution -- ^ @"distribution"@
  | E'Subtype'Dividend -- ^ @"dividend"@
  | E'Subtype'Dividend_reinvestment -- ^ @"dividend reinvestment"@
  | E'Subtype'Exercise -- ^ @"exercise"@
  | E'Subtype'Expire -- ^ @"expire"@
  | E'Subtype'Fund_fee -- ^ @"fund fee"@
  | E'Subtype'Interest -- ^ @"interest"@
  | E'Subtype'Interest_receivable -- ^ @"interest receivable"@
  | E'Subtype'Interest_reinvestment -- ^ @"interest reinvestment"@
  | E'Subtype'Legal_fee -- ^ @"legal fee"@
  | E'Subtype'Loan_payment -- ^ @"loan payment"@
  | E'Subtype'Long_term_capital_gain -- ^ @"long-term capital gain"@
  | E'Subtype'Long_term_capital_gain_reinvestment -- ^ @"long-term capital gain reinvestment"@
  | E'Subtype'Management_fee -- ^ @"management fee"@
  | E'Subtype'Margin_expense -- ^ @"margin expense"@
  | E'Subtype'Merger -- ^ @"merger"@
  | E'Subtype'Miscellaneous_fee -- ^ @"miscellaneous fee"@
  | E'Subtype'Non_qualified_dividend -- ^ @"non-qualified dividend"@
  | E'Subtype'Non_resident_tax -- ^ @"non-resident tax"@
  | E'Subtype'Pending_credit -- ^ @"pending credit"@
  | E'Subtype'Pending_debit -- ^ @"pending debit"@
  | E'Subtype'Qualified_dividend -- ^ @"qualified dividend"@
  | E'Subtype'Rebalance -- ^ @"rebalance"@
  | E'Subtype'Return_of_principal -- ^ @"return of principal"@
  | E'Subtype'Sell -- ^ @"sell"@
  | E'Subtype'Sell_short -- ^ @"sell short"@
  | E'Subtype'Short_term_capital_gain -- ^ @"short-term capital gain"@
  | E'Subtype'Short_term_capital_gain_reinvestment -- ^ @"short-term capital gain reinvestment"@
  | E'Subtype'Spin_off -- ^ @"spin off"@
  | E'Subtype'Split -- ^ @"split"@
  | E'Subtype'Stock_distribution -- ^ @"stock distribution"@
  | E'Subtype'Tax -- ^ @"tax"@
  | E'Subtype'Tax_withheld -- ^ @"tax withheld"@
  | E'Subtype'Transfer -- ^ @"transfer"@
  | E'Subtype'Transfer_fee -- ^ @"transfer fee"@
  | E'Subtype'Trust_fee -- ^ @"trust fee"@
  | E'Subtype'Unqualified_gain -- ^ @"unqualified gain"@
  | E'Subtype'Withdrawal -- ^ @"withdrawal"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Subtype where toJSON = A.toJSON . fromE'Subtype
instance A.FromJSON E'Subtype where parseJSON o = P.either P.fail (pure . P.id) . toE'Subtype =<< A.parseJSON o
instance WH.ToHttpApiData E'Subtype where toQueryParam = WH.toQueryParam . fromE'Subtype
instance WH.FromHttpApiData E'Subtype where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Subtype
instance MimeRender MimeMultipartFormData E'Subtype where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Subtype' enum
fromE'Subtype :: E'Subtype -> Text
fromE'Subtype = \case
  E'Subtype'Account_fee -> "account fee"
  E'Subtype'Assignment -> "assignment"
  E'Subtype'Buy -> "buy"
  E'Subtype'Buy_to_cover -> "buy to cover"
  E'Subtype'Contribution -> "contribution"
  E'Subtype'Deposit -> "deposit"
  E'Subtype'Distribution -> "distribution"
  E'Subtype'Dividend -> "dividend"
  E'Subtype'Dividend_reinvestment -> "dividend reinvestment"
  E'Subtype'Exercise -> "exercise"
  E'Subtype'Expire -> "expire"
  E'Subtype'Fund_fee -> "fund fee"
  E'Subtype'Interest -> "interest"
  E'Subtype'Interest_receivable -> "interest receivable"
  E'Subtype'Interest_reinvestment -> "interest reinvestment"
  E'Subtype'Legal_fee -> "legal fee"
  E'Subtype'Loan_payment -> "loan payment"
  E'Subtype'Long_term_capital_gain -> "long-term capital gain"
  E'Subtype'Long_term_capital_gain_reinvestment -> "long-term capital gain reinvestment"
  E'Subtype'Management_fee -> "management fee"
  E'Subtype'Margin_expense -> "margin expense"
  E'Subtype'Merger -> "merger"
  E'Subtype'Miscellaneous_fee -> "miscellaneous fee"
  E'Subtype'Non_qualified_dividend -> "non-qualified dividend"
  E'Subtype'Non_resident_tax -> "non-resident tax"
  E'Subtype'Pending_credit -> "pending credit"
  E'Subtype'Pending_debit -> "pending debit"
  E'Subtype'Qualified_dividend -> "qualified dividend"
  E'Subtype'Rebalance -> "rebalance"
  E'Subtype'Return_of_principal -> "return of principal"
  E'Subtype'Sell -> "sell"
  E'Subtype'Sell_short -> "sell short"
  E'Subtype'Short_term_capital_gain -> "short-term capital gain"
  E'Subtype'Short_term_capital_gain_reinvestment -> "short-term capital gain reinvestment"
  E'Subtype'Spin_off -> "spin off"
  E'Subtype'Split -> "split"
  E'Subtype'Stock_distribution -> "stock distribution"
  E'Subtype'Tax -> "tax"
  E'Subtype'Tax_withheld -> "tax withheld"
  E'Subtype'Transfer -> "transfer"
  E'Subtype'Transfer_fee -> "transfer fee"
  E'Subtype'Trust_fee -> "trust fee"
  E'Subtype'Unqualified_gain -> "unqualified gain"
  E'Subtype'Withdrawal -> "withdrawal"

-- | parse 'E'Subtype' enum
toE'Subtype :: Text -> P.Either String E'Subtype
toE'Subtype = \case
  "account fee" -> P.Right E'Subtype'Account_fee
  "assignment" -> P.Right E'Subtype'Assignment
  "buy" -> P.Right E'Subtype'Buy
  "buy to cover" -> P.Right E'Subtype'Buy_to_cover
  "contribution" -> P.Right E'Subtype'Contribution
  "deposit" -> P.Right E'Subtype'Deposit
  "distribution" -> P.Right E'Subtype'Distribution
  "dividend" -> P.Right E'Subtype'Dividend
  "dividend reinvestment" -> P.Right E'Subtype'Dividend_reinvestment
  "exercise" -> P.Right E'Subtype'Exercise
  "expire" -> P.Right E'Subtype'Expire
  "fund fee" -> P.Right E'Subtype'Fund_fee
  "interest" -> P.Right E'Subtype'Interest
  "interest receivable" -> P.Right E'Subtype'Interest_receivable
  "interest reinvestment" -> P.Right E'Subtype'Interest_reinvestment
  "legal fee" -> P.Right E'Subtype'Legal_fee
  "loan payment" -> P.Right E'Subtype'Loan_payment
  "long-term capital gain" -> P.Right E'Subtype'Long_term_capital_gain
  "long-term capital gain reinvestment" -> P.Right E'Subtype'Long_term_capital_gain_reinvestment
  "management fee" -> P.Right E'Subtype'Management_fee
  "margin expense" -> P.Right E'Subtype'Margin_expense
  "merger" -> P.Right E'Subtype'Merger
  "miscellaneous fee" -> P.Right E'Subtype'Miscellaneous_fee
  "non-qualified dividend" -> P.Right E'Subtype'Non_qualified_dividend
  "non-resident tax" -> P.Right E'Subtype'Non_resident_tax
  "pending credit" -> P.Right E'Subtype'Pending_credit
  "pending debit" -> P.Right E'Subtype'Pending_debit
  "qualified dividend" -> P.Right E'Subtype'Qualified_dividend
  "rebalance" -> P.Right E'Subtype'Rebalance
  "return of principal" -> P.Right E'Subtype'Return_of_principal
  "sell" -> P.Right E'Subtype'Sell
  "sell short" -> P.Right E'Subtype'Sell_short
  "short-term capital gain" -> P.Right E'Subtype'Short_term_capital_gain
  "short-term capital gain reinvestment" -> P.Right E'Subtype'Short_term_capital_gain_reinvestment
  "spin off" -> P.Right E'Subtype'Spin_off
  "split" -> P.Right E'Subtype'Split
  "stock distribution" -> P.Right E'Subtype'Stock_distribution
  "tax" -> P.Right E'Subtype'Tax
  "tax withheld" -> P.Right E'Subtype'Tax_withheld
  "transfer" -> P.Right E'Subtype'Transfer
  "transfer fee" -> P.Right E'Subtype'Transfer_fee
  "trust fee" -> P.Right E'Subtype'Trust_fee
  "unqualified gain" -> P.Right E'Subtype'Unqualified_gain
  "withdrawal" -> P.Right E'Subtype'Withdrawal
  s -> P.Left $ "toE'Subtype: enum parse failure: " P.++ P.show s


-- ** E'TransactionType

-- | Enum of 'Text' .
-- Please use the `payment_channel` field, `transaction_type` will be deprecated in the future.  `digital:` transactions that took place online.  `place:` transactions that were made at a physical location.  `special:` transactions that relate to banks, e.g. fees or deposits.  `unresolved:` transactions that do not fit into the other three types. 
data E'TransactionType
  = E'TransactionType'Digital -- ^ @"digital"@
  | E'TransactionType'Place -- ^ @"place"@
  | E'TransactionType'Special -- ^ @"special"@
  | E'TransactionType'Unresolved -- ^ @"unresolved"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'TransactionType where toJSON = A.toJSON . fromE'TransactionType
instance A.FromJSON E'TransactionType where parseJSON o = P.either P.fail (pure . P.id) . toE'TransactionType =<< A.parseJSON o
instance WH.ToHttpApiData E'TransactionType where toQueryParam = WH.toQueryParam . fromE'TransactionType
instance WH.FromHttpApiData E'TransactionType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'TransactionType
instance MimeRender MimeMultipartFormData E'TransactionType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'TransactionType' enum
fromE'TransactionType :: E'TransactionType -> Text
fromE'TransactionType = \case
  E'TransactionType'Digital -> "digital"
  E'TransactionType'Place -> "place"
  E'TransactionType'Special -> "special"
  E'TransactionType'Unresolved -> "unresolved"

-- | parse 'E'TransactionType' enum
toE'TransactionType :: Text -> P.Either String E'TransactionType
toE'TransactionType = \case
  "digital" -> P.Right E'TransactionType'Digital
  "place" -> P.Right E'TransactionType'Place
  "special" -> P.Right E'TransactionType'Special
  "unresolved" -> P.Right E'TransactionType'Unresolved
  s -> P.Left $ "toE'TransactionType: enum parse failure: " P.++ P.show s


-- ** E'Type

-- | Enum of 'Text' .
-- The type of phone number.
data E'Type
  = E'Type'Home -- ^ @"home"@
  | E'Type'Work -- ^ @"work"@
  | E'Type'Office -- ^ @"office"@
  | E'Type'Mobile -- ^ @"mobile"@
  | E'Type'Mobile1 -- ^ @"mobile1"@
  | E'Type'Other -- ^ @"other"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Type where toJSON = A.toJSON . fromE'Type
instance A.FromJSON E'Type where parseJSON o = P.either P.fail (pure . P.id) . toE'Type =<< A.parseJSON o
instance WH.ToHttpApiData E'Type where toQueryParam = WH.toQueryParam . fromE'Type
instance WH.FromHttpApiData E'Type where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Type
instance MimeRender MimeMultipartFormData E'Type where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Type' enum
fromE'Type :: E'Type -> Text
fromE'Type = \case
  E'Type'Home -> "home"
  E'Type'Work -> "work"
  E'Type'Office -> "office"
  E'Type'Mobile -> "mobile"
  E'Type'Mobile1 -> "mobile1"
  E'Type'Other -> "other"

-- | parse 'E'Type' enum
toE'Type :: Text -> P.Either String E'Type
toE'Type = \case
  "home" -> P.Right E'Type'Home
  "work" -> P.Right E'Type'Work
  "office" -> P.Right E'Type'Office
  "mobile" -> P.Right E'Type'Mobile
  "mobile1" -> P.Right E'Type'Mobile1
  "other" -> P.Right E'Type'Other
  s -> P.Left $ "toE'Type: enum parse failure: " P.++ P.show s


-- ** E'Type2

-- | Enum of 'Text' .
-- The type of email account as described by the financial institution.
data E'Type2
  = E'Type2'Primary -- ^ @"primary"@
  | E'Type2'Secondary -- ^ @"secondary"@
  | E'Type2'Other -- ^ @"other"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Type2 where toJSON = A.toJSON . fromE'Type2
instance A.FromJSON E'Type2 where parseJSON o = P.either P.fail (pure . P.id) . toE'Type2 =<< A.parseJSON o
instance WH.ToHttpApiData E'Type2 where toQueryParam = WH.toQueryParam . fromE'Type2
instance WH.FromHttpApiData E'Type2 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Type2
instance MimeRender MimeMultipartFormData E'Type2 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Type2' enum
fromE'Type2 :: E'Type2 -> Text
fromE'Type2 = \case
  E'Type2'Primary -> "primary"
  E'Type2'Secondary -> "secondary"
  E'Type2'Other -> "other"

-- | parse 'E'Type2' enum
toE'Type2 :: Text -> P.Either String E'Type2
toE'Type2 = \case
  "primary" -> P.Right E'Type2'Primary
  "secondary" -> P.Right E'Type2'Secondary
  "other" -> P.Right E'Type2'Other
  s -> P.Left $ "toE'Type2: enum parse failure: " P.++ P.show s


-- ** E'Type3

-- | Enum of 'Text' .
-- The status type of the student loan
data E'Type3
  = E'Type3'Cancelled -- ^ @"cancelled"@
  | E'Type3'Charged_off -- ^ @"charged off"@
  | E'Type3'Claim -- ^ @"claim"@
  | E'Type3'Consolidated -- ^ @"consolidated"@
  | E'Type3'Deferment -- ^ @"deferment"@
  | E'Type3'Delinquent -- ^ @"delinquent"@
  | E'Type3'Discharged -- ^ @"discharged"@
  | E'Type3'Extension -- ^ @"extension"@
  | E'Type3'Forbearance -- ^ @"forbearance"@
  | E'Type3'In_grace -- ^ @"in grace"@
  | E'Type3'In_military -- ^ @"in military"@
  | E'Type3'In_school -- ^ @"in school"@
  | E'Type3'Not_fully_disbursed -- ^ @"not fully disbursed"@
  | E'Type3'Other -- ^ @"other"@
  | E'Type3'Paid_in_full -- ^ @"paid in full"@
  | E'Type3'Refunded -- ^ @"refunded"@
  | E'Type3'Repayment -- ^ @"repayment"@
  | E'Type3'Transferred -- ^ @"transferred"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Type3 where toJSON = A.toJSON . fromE'Type3
instance A.FromJSON E'Type3 where parseJSON o = P.either P.fail (pure . P.id) . toE'Type3 =<< A.parseJSON o
instance WH.ToHttpApiData E'Type3 where toQueryParam = WH.toQueryParam . fromE'Type3
instance WH.FromHttpApiData E'Type3 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Type3
instance MimeRender MimeMultipartFormData E'Type3 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Type3' enum
fromE'Type3 :: E'Type3 -> Text
fromE'Type3 = \case
  E'Type3'Cancelled -> "cancelled"
  E'Type3'Charged_off -> "charged off"
  E'Type3'Claim -> "claim"
  E'Type3'Consolidated -> "consolidated"
  E'Type3'Deferment -> "deferment"
  E'Type3'Delinquent -> "delinquent"
  E'Type3'Discharged -> "discharged"
  E'Type3'Extension -> "extension"
  E'Type3'Forbearance -> "forbearance"
  E'Type3'In_grace -> "in grace"
  E'Type3'In_military -> "in military"
  E'Type3'In_school -> "in school"
  E'Type3'Not_fully_disbursed -> "not fully disbursed"
  E'Type3'Other -> "other"
  E'Type3'Paid_in_full -> "paid in full"
  E'Type3'Refunded -> "refunded"
  E'Type3'Repayment -> "repayment"
  E'Type3'Transferred -> "transferred"

-- | parse 'E'Type3' enum
toE'Type3 :: Text -> P.Either String E'Type3
toE'Type3 = \case
  "cancelled" -> P.Right E'Type3'Cancelled
  "charged off" -> P.Right E'Type3'Charged_off
  "claim" -> P.Right E'Type3'Claim
  "consolidated" -> P.Right E'Type3'Consolidated
  "deferment" -> P.Right E'Type3'Deferment
  "delinquent" -> P.Right E'Type3'Delinquent
  "discharged" -> P.Right E'Type3'Discharged
  "extension" -> P.Right E'Type3'Extension
  "forbearance" -> P.Right E'Type3'Forbearance
  "in grace" -> P.Right E'Type3'In_grace
  "in military" -> P.Right E'Type3'In_military
  "in school" -> P.Right E'Type3'In_school
  "not fully disbursed" -> P.Right E'Type3'Not_fully_disbursed
  "other" -> P.Right E'Type3'Other
  "paid in full" -> P.Right E'Type3'Paid_in_full
  "refunded" -> P.Right E'Type3'Refunded
  "repayment" -> P.Right E'Type3'Repayment
  "transferred" -> P.Right E'Type3'Transferred
  s -> P.Left $ "toE'Type3: enum parse failure: " P.++ P.show s


-- ** E'Type4

-- | Enum of 'Text' .
-- The type of the repayment plan.
data E'Type4
  = E'Type4'Extended_graduated -- ^ @"extended graduated"@
  | E'Type4'Extended_standard -- ^ @"extended standard"@
  | E'Type4'Graduated -- ^ @"graduated"@
  | E'Type4'Income_contingent_repayment -- ^ @"income-contingent repayment"@
  | E'Type4'Income_based_repayment -- ^ @"income-based repayment"@
  | E'Type4'Interest_only -- ^ @"interest-only"@
  | E'Type4'Other -- ^ @"other"@
  | E'Type4'Pay_as_you_earn -- ^ @"pay as you earn"@
  | E'Type4'Revised_pay_as_you_earn -- ^ @"revised pay as you earn"@
  | E'Type4'Standard -- ^ @"standard"@
  | E'Type4'SavingOnAValuableEducation -- ^ @"saving on a valuable education"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Type4 where toJSON = A.toJSON . fromE'Type4
instance A.FromJSON E'Type4 where parseJSON o = P.either P.fail (pure . P.id) . toE'Type4 =<< A.parseJSON o
instance WH.ToHttpApiData E'Type4 where toQueryParam = WH.toQueryParam . fromE'Type4
instance WH.FromHttpApiData E'Type4 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Type4
instance MimeRender MimeMultipartFormData E'Type4 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Type4' enum
fromE'Type4 :: E'Type4 -> Text
fromE'Type4 = \case
  E'Type4'Extended_graduated -> "extended graduated"
  E'Type4'Extended_standard -> "extended standard"
  E'Type4'Graduated -> "graduated"
  E'Type4'Income_contingent_repayment -> "income-contingent repayment"
  E'Type4'Income_based_repayment -> "income-based repayment"
  E'Type4'Interest_only -> "interest-only"
  E'Type4'Other -> "other"
  E'Type4'Pay_as_you_earn -> "pay as you earn"
  E'Type4'Revised_pay_as_you_earn -> "revised pay as you earn"
  E'Type4'Standard -> "standard"
  E'Type4'SavingOnAValuableEducation -> "saving on a valuable education"

-- | parse 'E'Type4' enum
toE'Type4 :: Text -> P.Either String E'Type4
toE'Type4 = \case
  "extended graduated" -> P.Right E'Type4'Extended_graduated
  "extended standard" -> P.Right E'Type4'Extended_standard
  "graduated" -> P.Right E'Type4'Graduated
  "income-contingent repayment" -> P.Right E'Type4'Income_contingent_repayment
  "income-based repayment" -> P.Right E'Type4'Income_based_repayment
  "interest-only" -> P.Right E'Type4'Interest_only
  "other" -> P.Right E'Type4'Other
  "pay as you earn" -> P.Right E'Type4'Pay_as_you_earn
  "revised pay as you earn" -> P.Right E'Type4'Revised_pay_as_you_earn
  "standard" -> P.Right E'Type4'Standard
  "saving on a valuable education" -> P.Right E'Type4'SavingOnAValuableEducation
  s -> P.Left $ "toE'Type4: enum parse failure: " P.++ P.show s


-- ** E'Type5

-- | Enum of 'Text' .
-- Value is one of the following: `buy`: Buying an investment `sell`: Selling an investment `cancel`: A cancellation of a pending transaction  `cash`: Activity that modifies a cash position `fee`: A fee on the account `transfer`: Activity which modifies a position, but not through buy/sell activity e.g. options exercise, portfolio transfer
data E'Type5
  = E'Type5'Buy -- ^ @"buy"@
  | E'Type5'Sell -- ^ @"sell"@
  | E'Type5'Cancel -- ^ @"cancel"@
  | E'Type5'Cash -- ^ @"cash"@
  | E'Type5'Fee -- ^ @"fee"@
  | E'Type5'Transfer -- ^ @"transfer"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Type5 where toJSON = A.toJSON . fromE'Type5
instance A.FromJSON E'Type5 where parseJSON o = P.either P.fail (pure . P.id) . toE'Type5 =<< A.parseJSON o
instance WH.ToHttpApiData E'Type5 where toQueryParam = WH.toQueryParam . fromE'Type5
instance WH.FromHttpApiData E'Type5 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Type5
instance MimeRender MimeMultipartFormData E'Type5 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Type5' enum
fromE'Type5 :: E'Type5 -> Text
fromE'Type5 = \case
  E'Type5'Buy -> "buy"
  E'Type5'Sell -> "sell"
  E'Type5'Cancel -> "cancel"
  E'Type5'Cash -> "cash"
  E'Type5'Fee -> "fee"
  E'Type5'Transfer -> "transfer"

-- | parse 'E'Type5' enum
toE'Type5 :: Text -> P.Either String E'Type5
toE'Type5 = \case
  "buy" -> P.Right E'Type5'Buy
  "sell" -> P.Right E'Type5'Sell
  "cancel" -> P.Right E'Type5'Cancel
  "cash" -> P.Right E'Type5'Cash
  "fee" -> P.Right E'Type5'Fee
  "transfer" -> P.Right E'Type5'Transfer
  s -> P.Left $ "toE'Type5: enum parse failure: " P.++ P.show s


-- ** E'UpdateType

-- | Enum of 'Text' .
-- Indicates whether an Item requires user interaction to be updated, which can be the case for Items with some forms of two-factor authentication.  `background` - Item can be updated in the background  `requires_user_authentication` - Item requires user interaction to be updated
data E'UpdateType
  = E'UpdateType'Background -- ^ @"background"@
  | E'UpdateType'Requires_user_authentication -- ^ @"requires_user_authentication"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'UpdateType where toJSON = A.toJSON . fromE'UpdateType
instance A.FromJSON E'UpdateType where parseJSON o = P.either P.fail (pure . P.id) . toE'UpdateType =<< A.parseJSON o
instance WH.ToHttpApiData E'UpdateType where toQueryParam = WH.toQueryParam . fromE'UpdateType
instance WH.FromHttpApiData E'UpdateType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'UpdateType
instance MimeRender MimeMultipartFormData E'UpdateType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'UpdateType' enum
fromE'UpdateType :: E'UpdateType -> Text
fromE'UpdateType = \case
  E'UpdateType'Background -> "background"
  E'UpdateType'Requires_user_authentication -> "requires_user_authentication"

-- | parse 'E'UpdateType' enum
toE'UpdateType :: Text -> P.Either String E'UpdateType
toE'UpdateType = \case
  "background" -> P.Right E'UpdateType'Background
  "requires_user_authentication" -> P.Right E'UpdateType'Requires_user_authentication
  s -> P.Left $ "toE'UpdateType: enum parse failure: " P.++ P.show s


-- ** E'Value

-- | Enum of 'Text' .
-- The frequency of the pay period.
data E'Value
  = E'Value'Monthly -- ^ @"monthly"@
  | E'Value'Semimonthly -- ^ @"semimonthly"@
  | E'Value'Weekly -- ^ @"weekly"@
  | E'Value'Biweekly -- ^ @"biweekly"@
  | E'Value'Unknown -- ^ @"unknown"@
  | E'Value'Null -- ^ @"null"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Value where toJSON = A.toJSON . fromE'Value
instance A.FromJSON E'Value where parseJSON o = P.either P.fail (pure . P.id) . toE'Value =<< A.parseJSON o
instance WH.ToHttpApiData E'Value where toQueryParam = WH.toQueryParam . fromE'Value
instance WH.FromHttpApiData E'Value where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Value
instance MimeRender MimeMultipartFormData E'Value where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Value' enum
fromE'Value :: E'Value -> Text
fromE'Value = \case
  E'Value'Monthly -> "monthly"
  E'Value'Semimonthly -> "semimonthly"
  E'Value'Weekly -> "weekly"
  E'Value'Biweekly -> "biweekly"
  E'Value'Unknown -> "unknown"
  E'Value'Null -> "null"

-- | parse 'E'Value' enum
toE'Value :: Text -> P.Either String E'Value
toE'Value = \case
  "monthly" -> P.Right E'Value'Monthly
  "semimonthly" -> P.Right E'Value'Semimonthly
  "weekly" -> P.Right E'Value'Weekly
  "biweekly" -> P.Right E'Value'Biweekly
  "unknown" -> P.Right E'Value'Unknown
  "null" -> P.Right E'Value'Null
  s -> P.Left $ "toE'Value: enum parse failure: " P.++ P.show s


-- ** E'VerificationStatus

-- | Enum of 'Text' .
-- The verification status to set the account to.
data E'VerificationStatus
  = E'VerificationStatus'Automatically_verified -- ^ @"automatically_verified"@
  | E'VerificationStatus'Verification_expired -- ^ @"verification_expired"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'VerificationStatus where toJSON = A.toJSON . fromE'VerificationStatus
instance A.FromJSON E'VerificationStatus where parseJSON o = P.either P.fail (pure . P.id) . toE'VerificationStatus =<< A.parseJSON o
instance WH.ToHttpApiData E'VerificationStatus where toQueryParam = WH.toQueryParam . fromE'VerificationStatus
instance WH.FromHttpApiData E'VerificationStatus where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'VerificationStatus
instance MimeRender MimeMultipartFormData E'VerificationStatus where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'VerificationStatus' enum
fromE'VerificationStatus :: E'VerificationStatus -> Text
fromE'VerificationStatus = \case
  E'VerificationStatus'Automatically_verified -> "automatically_verified"
  E'VerificationStatus'Verification_expired -> "verification_expired"

-- | parse 'E'VerificationStatus' enum
toE'VerificationStatus :: Text -> P.Either String E'VerificationStatus
toE'VerificationStatus = \case
  "automatically_verified" -> P.Right E'VerificationStatus'Automatically_verified
  "verification_expired" -> P.Right E'VerificationStatus'Verification_expired
  s -> P.Left $ "toE'VerificationStatus: enum parse failure: " P.++ P.show s


-- ** E'VerificationStatus2

-- | Enum of 'Text' .
-- The current verification status of an Auth Item initiated through Automated or Manual micro-deposits.  Returned for Auth Items only.  `pending_automatic_verification`: The Item is pending automatic verification  `pending_manual_verification`: The Item is pending manual micro-deposit verification. Items remain in this state until the user successfully verifies the two amounts.  `automatically_verified`: The Item has successfully been automatically verified   `manually_verified`: The Item has successfully been manually verified  `verification_expired`: Plaid was unable to automatically verify the deposit within 7 calendar days and will no longer attempt to validate the Item. Users may retry by submitting their information again through Link.  `verification_failed`: The Item failed manual micro-deposit verification because the user exhausted all 3 verification attempts. Users may retry by submitting their information again through Link.   
data E'VerificationStatus2
  = E'VerificationStatus2'Pending_automatic_verification -- ^ @"pending_automatic_verification"@
  | E'VerificationStatus2'Pending_manual_verification -- ^ @"pending_manual_verification"@
  | E'VerificationStatus2'Manually_verified -- ^ @"manually_verified"@
  | E'VerificationStatus2'Automatically_verified -- ^ @"automatically_verified"@
  | E'VerificationStatus2'Verification_expired -- ^ @"verification_expired"@
  | E'VerificationStatus2'Verification_failed -- ^ @"verification_failed"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'VerificationStatus2 where toJSON = A.toJSON . fromE'VerificationStatus2
instance A.FromJSON E'VerificationStatus2 where parseJSON o = P.either P.fail (pure . P.id) . toE'VerificationStatus2 =<< A.parseJSON o
instance WH.ToHttpApiData E'VerificationStatus2 where toQueryParam = WH.toQueryParam . fromE'VerificationStatus2
instance WH.FromHttpApiData E'VerificationStatus2 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'VerificationStatus2
instance MimeRender MimeMultipartFormData E'VerificationStatus2 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'VerificationStatus2' enum
fromE'VerificationStatus2 :: E'VerificationStatus2 -> Text
fromE'VerificationStatus2 = \case
  E'VerificationStatus2'Pending_automatic_verification -> "pending_automatic_verification"
  E'VerificationStatus2'Pending_manual_verification -> "pending_manual_verification"
  E'VerificationStatus2'Manually_verified -> "manually_verified"
  E'VerificationStatus2'Automatically_verified -> "automatically_verified"
  E'VerificationStatus2'Verification_expired -> "verification_expired"
  E'VerificationStatus2'Verification_failed -> "verification_failed"

-- | parse 'E'VerificationStatus2' enum
toE'VerificationStatus2 :: Text -> P.Either String E'VerificationStatus2
toE'VerificationStatus2 = \case
  "pending_automatic_verification" -> P.Right E'VerificationStatus2'Pending_automatic_verification
  "pending_manual_verification" -> P.Right E'VerificationStatus2'Pending_manual_verification
  "manually_verified" -> P.Right E'VerificationStatus2'Manually_verified
  "automatically_verified" -> P.Right E'VerificationStatus2'Automatically_verified
  "verification_expired" -> P.Right E'VerificationStatus2'Verification_expired
  "verification_failed" -> P.Right E'VerificationStatus2'Verification_failed
  s -> P.Left $ "toE'VerificationStatus2: enum parse failure: " P.++ P.show s


-- ** E'WebhookCode

-- | Enum of 'Text' .
-- The following values for `webhook_code` are supported:  * `DEFAULT_UPDATE`
data E'WebhookCode
  = E'WebhookCode'DEFAULT_UPDATE -- ^ @"DEFAULT_UPDATE"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'WebhookCode where toJSON = A.toJSON . fromE'WebhookCode
instance A.FromJSON E'WebhookCode where parseJSON o = P.either P.fail (pure . P.id) . toE'WebhookCode =<< A.parseJSON o
instance WH.ToHttpApiData E'WebhookCode where toQueryParam = WH.toQueryParam . fromE'WebhookCode
instance WH.FromHttpApiData E'WebhookCode where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'WebhookCode
instance MimeRender MimeMultipartFormData E'WebhookCode where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'WebhookCode' enum
fromE'WebhookCode :: E'WebhookCode -> Text
fromE'WebhookCode = \case
  E'WebhookCode'DEFAULT_UPDATE -> "DEFAULT_UPDATE"

-- | parse 'E'WebhookCode' enum
toE'WebhookCode :: Text -> P.Either String E'WebhookCode
toE'WebhookCode = \case
  "DEFAULT_UPDATE" -> P.Right E'WebhookCode'DEFAULT_UPDATE
  s -> P.Left $ "toE'WebhookCode: enum parse failure: " P.++ P.show s


-- ** Products

-- | Enum of 'Text' .
-- A list of products that an institution can support. All Items must be initialized with at least one product. The Balance product is always available and does not need to be specified during initialization.
data Products
  = Products'Assets -- ^ @"assets"@
  | Products'Auth -- ^ @"auth"@
  | Products'Balance_plus -- ^ @"balance_plus"@
  | Products'Identity -- ^ @"identity"@
  | Products'Investments -- ^ @"investments"@
  | Products'Liabilities -- ^ @"liabilities"@
  | Products'Payment_initiation -- ^ @"payment_initiation"@
  | Products'Transactions -- ^ @"transactions"@
  | Products'Credit_details -- ^ @"credit_details"@
  | Products'Income -- ^ @"income"@
  | Products'Deposit_switch -- ^ @"deposit_switch"@
  | Products'RecurringTransactions -- ^ @"recurring_transactions"@
  | Products'UNKNOWN Text -- ^ asimuskov: Plaid could dynamically add new products. Exclude fails for such cases.
  deriving (P.Show, P.Eq, P.Typeable, P.Ord)

instance P.Bounded Products where
  minBound = P.toEnum 0
  maxBound = P.toEnum 12

instance P.Enum Products where
  fromEnum = \case
    Products'Assets -> 0
    Products'Auth -> 1
    Products'Balance_plus -> 2
    Products'Identity -> 3
    Products'Investments -> 4
    Products'Liabilities -> 5
    Products'Payment_initiation -> 6
    Products'Transactions -> 7
    Products'Credit_details -> 8
    Products'Income -> 9
    Products'Deposit_switch -> 10
    Products'RecurringTransactions -> 11
    Products'UNKNOWN _ -> 12

  toEnum = \case
    0 -> Products'Assets
    1 -> Products'Auth
    2 -> Products'Balance_plus
    3 -> Products'Identity
    4 -> Products'Investments 
    5 -> Products'Liabilities
    6 -> Products'Payment_initiation
    7 -> Products'Transactions
    8 -> Products'Credit_details
    9 -> Products'Income
    10 -> Products'Deposit_switch
    11 -> Products'RecurringTransactions 
    _ -> Products'UNKNOWN ""


instance A.ToJSON Products where toJSON = A.toJSON . fromProducts
instance A.FromJSON Products where parseJSON o = P.either P.fail (pure . P.id) . toProducts =<< A.parseJSON o
instance WH.ToHttpApiData Products where toQueryParam = WH.toQueryParam . fromProducts
instance WH.FromHttpApiData Products where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toProducts
instance MimeRender MimeMultipartFormData Products where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'Products' enum
fromProducts :: Products -> Text
fromProducts = \case
  Products'Assets -> "assets"
  Products'Auth -> "auth"
  Products'Balance_plus -> "balance_plus"
  Products'Identity -> "identity"
  Products'Investments -> "investments"
  Products'Liabilities -> "liabilities"
  Products'Payment_initiation -> "payment_initiation"
  Products'Transactions -> "transactions"
  Products'Credit_details -> "credit_details"
  Products'Income -> "income"
  Products'Deposit_switch -> "deposit_switch"
  Products'RecurringTransactions -> "recurring_transactions"
  Products'UNKNOWN unknownProduct -> unknownProduct

-- | parse 'Products' enum
toProducts :: Text -> P.Either String Products
toProducts = \case
  "assets" -> P.Right Products'Assets
  "auth" -> P.Right Products'Auth
  "balance_plus" -> P.Right Products'Balance_plus
  "identity" -> P.Right Products'Identity
  "investments" -> P.Right Products'Investments
  "liabilities" -> P.Right Products'Liabilities
  "payment_initiation" -> P.Right Products'Payment_initiation
  "transactions" -> P.Right Products'Transactions
  "credit_details" -> P.Right Products'Credit_details
  "income" -> P.Right Products'Income
  "deposit_switch" -> P.Right Products'Deposit_switch
  "recurring_transactions" -> P.Right Products'RecurringTransactions
  unknownProduct -> P.Right (Products'UNKNOWN unknownProduct)
  s -> P.Left $ "toProducts: enum parse failure: " P.++ P.show s
  


-- ** RequiredIfSupportedProducts

data RequiredIfSupportedProducts
  = RequiredIfSupportedProducts'Auth -- ^ @"auth"@
  | RequiredIfSupportedProducts'Identity -- ^ @"identity"@
  | RequiredIfSupportedProducts'Investments -- ^ @"investments"@
  | RequiredIfSupportedProducts'Liabilities -- ^ @"liabilities"@
  | RequiredIfSupportedProducts'Transactions -- ^ @"transactions"@
  | RequiredIfSupportedProducts'Statements -- ^ @"statements"@
  | RequiredIfSupportedProducts'UNKNOWN Text -- Plaid could dynamically add new RequiredIfSupportedProducts. Exclude fails for such cases.
  deriving (P.Show, P.Eq, P.Typeable, P.Ord)

instance P.Bounded RequiredIfSupportedProducts where
  minBound = P.toEnum 0
  maxBound = P.toEnum 12

instance P.Enum RequiredIfSupportedProducts where
  fromEnum = \case
    RequiredIfSupportedProducts'Auth -> 0
    RequiredIfSupportedProducts'Identity -> 1
    RequiredIfSupportedProducts'Investments -> 2
    RequiredIfSupportedProducts'Liabilities -> 3
    RequiredIfSupportedProducts'Transactions -> 4
    RequiredIfSupportedProducts'Statements -> 5
    RequiredIfSupportedProducts'UNKNOWN _ -> 6

  toEnum = \case
    0 -> RequiredIfSupportedProducts'Auth 
    1 -> RequiredIfSupportedProducts'Identity 
    2 -> RequiredIfSupportedProducts'Investments 
    3 -> RequiredIfSupportedProducts'Liabilities 
    4 -> RequiredIfSupportedProducts'Transactions
    5 -> RequiredIfSupportedProducts'Statements
    _ -> RequiredIfSupportedProducts'UNKNOWN ""


instance A.ToJSON RequiredIfSupportedProducts where toJSON = A.toJSON . fromRequiredIfSupportedProducts
instance A.FromJSON RequiredIfSupportedProducts where parseJSON o = P.either P.fail (pure . P.id) . toRequiredIfSupportedProducts =<< A.parseJSON o
instance WH.ToHttpApiData RequiredIfSupportedProducts where toQueryParam = WH.toQueryParam . fromRequiredIfSupportedProducts
instance WH.FromHttpApiData RequiredIfSupportedProducts where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toRequiredIfSupportedProducts
instance MimeRender MimeMultipartFormData RequiredIfSupportedProducts where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'RequiredIfSupportedProducts' enum
fromRequiredIfSupportedProducts :: RequiredIfSupportedProducts -> Text
fromRequiredIfSupportedProducts = \case
  RequiredIfSupportedProducts'Auth -> "auth"
  RequiredIfSupportedProducts'Identity -> "identity"
  RequiredIfSupportedProducts'Investments -> "investments"
  RequiredIfSupportedProducts'Liabilities -> "liabilities"
  RequiredIfSupportedProducts'Transactions -> "transactions"
  RequiredIfSupportedProducts'Statements -> "statements"
  RequiredIfSupportedProducts'UNKNOWN unknownProduct -> unknownProduct

-- | parse 'RequiredIfSupportedProducts' enum
toRequiredIfSupportedProducts :: Text -> P.Either String RequiredIfSupportedProducts
toRequiredIfSupportedProducts = \case
  "auth" -> P.Right RequiredIfSupportedProducts'Auth
  "identity" -> P.Right RequiredIfSupportedProducts'Identity
  "investments" -> P.Right RequiredIfSupportedProducts'Investments
  "liabilities" -> P.Right RequiredIfSupportedProducts'Liabilities
  "transactions" -> P.Right RequiredIfSupportedProducts'Transactions
  "statements" -> P.Right RequiredIfSupportedProducts'Statements
  unknownProduct -> P.Right (RequiredIfSupportedProducts'UNKNOWN unknownProduct)
  s -> P.Left $ "toRequiredIfSupportedProducts: enum parse failure: " P.++ P.show s


-- ** AdditionalConsentedProducts

data AdditionalConsentedProducts
  = AdditionalConsentedProducts'Auth -- ^ @"auth"@
  | AdditionalConsentedProducts'Balance_plus -- ^ @"balance_plus"@
  | AdditionalConsentedProducts'Identity -- ^ @"identity"@
  | AdditionalConsentedProducts'Investments -- ^ @"investments"@
  | AdditionalConsentedProducts'Liabilities -- ^ @"liabilities"@
  | AdditionalConsentedProducts'Transactions -- ^ @"transactions"@
  | AdditionalConsentedProducts'Signal -- ^ @"signal"@
  | AdditionalConsentedProducts'UNKNOWN Text -- Plaid could dynamically add new AdditionalConsentedProducts. Exclude fails for such cases.
  deriving (P.Show, P.Eq, P.Typeable, P.Ord)

instance P.Bounded AdditionalConsentedProducts where
  minBound = P.toEnum 0
  maxBound = P.toEnum 12

instance P.Enum AdditionalConsentedProducts where
  fromEnum = \case
    AdditionalConsentedProducts'Auth -> 0
    AdditionalConsentedProducts'Balance_plus -> 1
    AdditionalConsentedProducts'Identity -> 2
    AdditionalConsentedProducts'Investments -> 3
    AdditionalConsentedProducts'Liabilities -> 4
    AdditionalConsentedProducts'Transactions -> 5
    AdditionalConsentedProducts'Signal -> 6
    AdditionalConsentedProducts'UNKNOWN _ -> 7

  toEnum = \case
    0 -> AdditionalConsentedProducts'Auth 
    1 -> AdditionalConsentedProducts'Balance_plus 
    2 -> AdditionalConsentedProducts'Identity 
    3 -> AdditionalConsentedProducts'Investments 
    4 -> AdditionalConsentedProducts'Liabilities 
    5 -> AdditionalConsentedProducts'Transactions
    6 -> AdditionalConsentedProducts'Signal
    _ -> AdditionalConsentedProducts'UNKNOWN ""


instance A.ToJSON AdditionalConsentedProducts where toJSON = A.toJSON . fromAdditionalConsentedProducts
instance A.FromJSON AdditionalConsentedProducts where parseJSON o = P.either P.fail (pure . P.id) . toAdditionalConsentedProducts =<< A.parseJSON o
instance WH.ToHttpApiData AdditionalConsentedProducts where toQueryParam = WH.toQueryParam . fromAdditionalConsentedProducts
instance WH.FromHttpApiData AdditionalConsentedProducts where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toAdditionalConsentedProducts
instance MimeRender MimeMultipartFormData AdditionalConsentedProducts where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'AdditionalConsentedProducts' enum
fromAdditionalConsentedProducts :: AdditionalConsentedProducts -> Text
fromAdditionalConsentedProducts = \case
  AdditionalConsentedProducts'Auth -> "auth"
  AdditionalConsentedProducts'Balance_plus -> "balance_plus"
  AdditionalConsentedProducts'Identity -> "identity"
  AdditionalConsentedProducts'Investments -> "investments"
  AdditionalConsentedProducts'Liabilities -> "liabilities"
  AdditionalConsentedProducts'Transactions -> "transactions"
  AdditionalConsentedProducts'Signal -> "signal"
  AdditionalConsentedProducts'UNKNOWN unknownProduct -> unknownProduct

-- | parse 'AdditionalConsentedProducts' enum
toAdditionalConsentedProducts :: Text -> P.Either String AdditionalConsentedProducts
toAdditionalConsentedProducts = \case
  "auth" -> P.Right AdditionalConsentedProducts'Auth
  "balance_plus" -> P.Right AdditionalConsentedProducts'Balance_plus
  "identity" -> P.Right AdditionalConsentedProducts'Identity
  "investments" -> P.Right AdditionalConsentedProducts'Investments
  "liabilities" -> P.Right AdditionalConsentedProducts'Liabilities
  "transactions" -> P.Right AdditionalConsentedProducts'Transactions
  "signal" -> P.Right AdditionalConsentedProducts'Signal
  unknownProduct -> P.Right (AdditionalConsentedProducts'UNKNOWN unknownProduct)
  s -> P.Left $ "toAdditionalConsentedProducts: enum parse failure: " P.++ P.show s


-- ** TransactionCode

-- | Enum of 'Text' .
-- An identifier classifying the transaction type.  This field is only populated for European institutions. For institutions in the US and Canada, this field is set to `null`.  `adjustment:` Bank adjustment  `atm:` Cash deposit or withdrawal via an automated teller machine  `bank charge:` Charge or fee levied by the institution  `bill payment`: Payment of a bill  `cash:` Cash deposit or withdrawal  `cashback:` Cash withdrawal while making a debit card purchase  `cheque:` Document ordering the payment of money to another person or organization  `direct debit:` Automatic withdrawal of funds initiated by a third party at a regular interval  `interest:` Interest earned or incurred  `purchase:` Purchase made with a debit or credit card  `standing order:` Payment instructed by the account holder to a third party at a regular interval  `transfer:` Transfer of money between accounts
data TransactionCode
  = TransactionCode'Adjustment -- ^ @"adjustment"@
  | TransactionCode'Atm -- ^ @"atm"@
  | TransactionCode'Bank_charge -- ^ @"bank charge"@
  | TransactionCode'Bill_payment -- ^ @"bill payment"@
  | TransactionCode'Cash -- ^ @"cash"@
  | TransactionCode'Cashback -- ^ @"cashback"@
  | TransactionCode'Cheque -- ^ @"cheque"@
  | TransactionCode'Direct_debit -- ^ @"direct debit"@
  | TransactionCode'Interest -- ^ @"interest"@
  | TransactionCode'Purchase -- ^ @"purchase"@
  | TransactionCode'Standing_order -- ^ @"standing order"@
  | TransactionCode'Transfer -- ^ @"transfer"@
  | TransactionCode'Null -- ^ @"null"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON TransactionCode where toJSON = A.toJSON . fromTransactionCode
instance A.FromJSON TransactionCode where parseJSON o = P.either P.fail (pure . P.id) . toTransactionCode =<< A.parseJSON o
instance WH.ToHttpApiData TransactionCode where toQueryParam = WH.toQueryParam . fromTransactionCode
instance WH.FromHttpApiData TransactionCode where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toTransactionCode
instance MimeRender MimeMultipartFormData TransactionCode where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'TransactionCode' enum
fromTransactionCode :: TransactionCode -> Text
fromTransactionCode = \case
  TransactionCode'Adjustment -> "adjustment"
  TransactionCode'Atm -> "atm"
  TransactionCode'Bank_charge -> "bank charge"
  TransactionCode'Bill_payment -> "bill payment"
  TransactionCode'Cash -> "cash"
  TransactionCode'Cashback -> "cashback"
  TransactionCode'Cheque -> "cheque"
  TransactionCode'Direct_debit -> "direct debit"
  TransactionCode'Interest -> "interest"
  TransactionCode'Purchase -> "purchase"
  TransactionCode'Standing_order -> "standing order"
  TransactionCode'Transfer -> "transfer"
  TransactionCode'Null -> "null"

-- | parse 'TransactionCode' enum
toTransactionCode :: Text -> P.Either String TransactionCode
toTransactionCode = \case
  "adjustment" -> P.Right TransactionCode'Adjustment
  "atm" -> P.Right TransactionCode'Atm
  "bank charge" -> P.Right TransactionCode'Bank_charge
  "bill payment" -> P.Right TransactionCode'Bill_payment
  "cash" -> P.Right TransactionCode'Cash
  "cashback" -> P.Right TransactionCode'Cashback
  "cheque" -> P.Right TransactionCode'Cheque
  "direct debit" -> P.Right TransactionCode'Direct_debit
  "interest" -> P.Right TransactionCode'Interest
  "purchase" -> P.Right TransactionCode'Purchase
  "standing order" -> P.Right TransactionCode'Standing_order
  "transfer" -> P.Right TransactionCode'Transfer
  "null" -> P.Right TransactionCode'Null
  s -> P.Left $ "toTransactionCode: enum parse failure: " P.++ P.show s


-- ** VerificationStatus

-- | Enum of 'Text' .
-- The verification status. One of the following:  `\"VERIFIED\"`: The information was successfully verified.  `\"UNVERIFIED\"`: The verification has not yet been performed.  `\"NEEDS_INFO\"`: The verification was attempted but could not be completed due to missing information.  \"`UNABLE_TO_VERIFY`\": The verification was performed and the information could not be verified.  `\"UNKNOWN\"`: The verification status is unknown.
data VerificationStatus
  = VerificationStatus'VERIFIED -- ^ @"VERIFIED"@
  | VerificationStatus'UNVERIFIED -- ^ @"UNVERIFIED"@
  | VerificationStatus'NEEDS_INFO -- ^ @"NEEDS_INFO"@
  | VerificationStatus'UNABLE_TO_VERIFY -- ^ @"UNABLE_TO_VERIFY"@
  | VerificationStatus'UNKNOWN -- ^ @"UNKNOWN"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON VerificationStatus where toJSON = A.toJSON . fromVerificationStatus
instance A.FromJSON VerificationStatus where parseJSON o = P.either P.fail (pure . P.id) . toVerificationStatus =<< A.parseJSON o
instance WH.ToHttpApiData VerificationStatus where toQueryParam = WH.toQueryParam . fromVerificationStatus
instance WH.FromHttpApiData VerificationStatus where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toVerificationStatus
instance MimeRender MimeMultipartFormData VerificationStatus where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'VerificationStatus' enum
fromVerificationStatus :: VerificationStatus -> Text
fromVerificationStatus = \case
  VerificationStatus'VERIFIED -> "VERIFIED"
  VerificationStatus'UNVERIFIED -> "UNVERIFIED"
  VerificationStatus'NEEDS_INFO -> "NEEDS_INFO"
  VerificationStatus'UNABLE_TO_VERIFY -> "UNABLE_TO_VERIFY"
  VerificationStatus'UNKNOWN -> "UNKNOWN"

-- | parse 'VerificationStatus' enum
toVerificationStatus :: Text -> P.Either String VerificationStatus
toVerificationStatus = \case
  "VERIFIED" -> P.Right VerificationStatus'VERIFIED
  "UNVERIFIED" -> P.Right VerificationStatus'UNVERIFIED
  "NEEDS_INFO" -> P.Right VerificationStatus'NEEDS_INFO
  "UNABLE_TO_VERIFY" -> P.Right VerificationStatus'UNABLE_TO_VERIFY
  "UNKNOWN" -> P.Right VerificationStatus'UNKNOWN
  s -> P.Left $ "toVerificationStatus: enum parse failure: " P.++ P.show s


-- * Auth Methods

-- ** AuthApiKeyClientId
data AuthApiKeyClientId =
  AuthApiKeyClientId Text -- ^ secret
  deriving (P.Eq, P.Show, P.Typeable)

instance AuthMethod AuthApiKeyClientId where
  applyAuthMethod _ a@(AuthApiKeyClientId secret) req =
    P.pure $
    if (P.typeOf a `P.elem` rAuthTypes req)
      then req `setHeader` toHeader ("PLAID-CLIENT-ID", secret)
           & L.over rAuthTypesL (P.filter (/= P.typeOf a))
      else req

-- ** AuthApiKeyPlaidVersion
data AuthApiKeyPlaidVersion =
  AuthApiKeyPlaidVersion Text -- ^ secret
  deriving (P.Eq, P.Show, P.Typeable)

instance AuthMethod AuthApiKeyPlaidVersion where
  applyAuthMethod _ a@(AuthApiKeyPlaidVersion secret) req =
    P.pure $
    if (P.typeOf a `P.elem` rAuthTypes req)
      then req `setHeader` toHeader ("Plaid-Version", secret)
           & L.over rAuthTypesL (P.filter (/= P.typeOf a))
      else req

-- ** AuthApiKeySecret
data AuthApiKeySecret =
  AuthApiKeySecret Text -- ^ secret
  deriving (P.Eq, P.Show, P.Typeable)

instance AuthMethod AuthApiKeySecret where
  applyAuthMethod _ a@(AuthApiKeySecret secret) req =
    P.pure $
    if (P.typeOf a `P.elem` rAuthTypes req)
      then req `setHeader` toHeader ("PLAID-SECRET", secret)
           & L.over rAuthTypesL (P.filter (/= P.typeOf a))
      else req


